CMMS Android App – Backend API SpecifikációEz a dokumentum leírja, milyen REST API végpontokra és adatszerkezetekre van szüksége az Android alkalmazásnak. A cél, hogy a backend rendszer könnyen implementálható legyen (FastAPI, Node.js/Express, Django REST, PHP stb.).Alapok•Base URL (ajánlott): http://<host>:<port>/api/v1/•Tartalom típus: application/json•Auth: Bearer token (Authorization: Bearer <access_token>) a védett végpontokra•Időzítések: TIMEOUT ~30s•Cleartext HTTP: Fejlesztés alatt engedélyezhető; élesben HTTPS javasoltEgészség/Info•GET /api/health/•Válasz: { "status": "ok", "version": "1.0.0" }•GET /api/v1/info•Válasz: { "name": "cmms-api", "version": "1.0.0", "env": "prod" }1)Authentikáció•POST /api/v1/auth/login•Body (REQUIRED): { "username": "string", "password": "string" }•Megjegyzés (Swagger validáció): az API schema KIZÁRÓLAG "username" mezőt fogad el. Az "email" mező küldése 422 Unprocessable Entity hibát okoz.•Success 200 (TokenResponse): { "access_token": "string", "token_type": "Bearer", "expires_in": 3600, "user_id": 123, "username": "user@example.com", "role_name": "ADMIN" }•Hibák:•401 Unauthorized: { "detail": "Invalid credentials" } – tipikusan jelszó-ellenőrzés vagy nem létező user•404 Not Found: útvonal téves (helyes path: /api/v1/auth/login)•422 Unprocessable Entity: kötelező mező hiányzik (pl. username)•POST /api/v1/auth/logout (opcionális)•Header: Authorization: Bearer <token>•Success 204•POST /api/v1/auth/register (opcionális)•Body: { "email": "string", "password": "string", "role": "USER|ADMIN" }•Success 201: { "user_id": 123 }Auth – jelszó ellenőrzés (bcrypt ajánlott)•A users.password_hash mezőben bcrypt hash tárolása javasolt.•Ellenőrzéskor bcrypt.compare(plain_password, password_hash) / pwd_context.verify használata szükséges.Példa – FastAPIfrom fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from passlib.context import CryptContext

app = FastAPI()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class LoginBody(BaseModel):
    username: str
    password: str

# Példa DB rekord
FAKE_DB = {
    "a.geleta": {
        "id": 1,
        "username": "a.geleta",
        "email": "a.geleta",
        "role": "ADMIN",
        # bcrypt hash példa (csere valós hashre)
        "password_hash": pwd_context.hash("Gele007ta")
    }
}

@app.post("/api/v1/auth/login")
def login(body: LoginBody):
    user = FAKE_DB.get(body.username)
    if not user or not pwd_context.verify(body.password, user["password_hash"]):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    return {
        "access_token": "dummy-token",
        "token_type": "Bearer",
        "expires_in": 3600,
        "user_id": user["id"],
        "username": user["email"],
        "role_name": user["role"],
    }Gyors seed/ellenőrzés (MySQL)•Ha a tárolt jelszó bcrypt, a hash-t előállíthatod Python/Node.js-ből és írd be a users.password_hash mezőbe.•Ha a user létezik:UPDATE users SET password_hash = '<BCRYPT_HASH>' WHERE username = 'a.geleta' OR email = 'a.geleta';•Ha újra kell létrehozni:INSERT INTO users (email, username, password_hash, role) VALUES ('a.geleta', 'a.geleta', '<BCRYPT_HASH>', 'ADMIN');Terminálteszt (Windows PowerShell)$body = '{"username":"a.geleta","password":"Gele007ta"}'
curl.exe -s -X POST "http://<host>:<port>/api/v1/auth/login" -H "Content-Type: application/json" -d $body•Elvárt válasz: 200 és TokenResponse JSON. 401 esetén ellenőrizd, hogy a bcrypt hash a megadott jelszóhoz tartozik és a verify függvényt használod.2)Felhasználók•GET /api/v1/users/me•Header: Authorization: Bearer <token>•Success 200: { "id": 123, "email": "user@example.com", "username": "user@example.com", "role": "ADMIN", "created_at": "2025-12-15T12:00:00Z" }•GET /api/v1/users (ADMIN)•Success 200: [ UserDto, ... ]•POST /api/v1/users (ADMIN)•Body: { "email": "string", "password": "string", "role": "USER|ADMIN" }•Success 201: { "id": 456 }UserDto példa: { "id": 123, "email": "user@example.com", "role": "ADMIN", "created_at": "2025-12-15T12:00:00Z" }3)Gépek (Machines)•GET /api/v1/machines•Query (opcionális): status=OPERATIONAL|MAINTENANCE|BREAKDOWN|OFFLINE•Success 200: [ MachineDto, ... ]•GET /api/v1/machines/{id}•Success 200: MachineDto•POST /api/v1/machines (CREATE)•Body: CreateMachineDto•Success 201: MachineDto•PUT /api/v1/machines/{id} (UPDATE)•Body: UpdateMachineDto•Success 200: MachineDto•DELETE /api/v1/machines/{id}•Success 204MachineDto: { "id": 1, "production_line_id": 10, "name": "Press 1", "serial_number": "SN-0001", "model": "MX-100", "manufacturer": "ABB", "status": "OPERATIONAL", "asset_tag": "TAG-001", "description": "Primary press", "install_date": "2024-01-01", "created_at": "2024-01-10T12:00:00Z", "updated_at": "2024-06-10T12:00:00Z" }CreateMachineDto: { "production_line_id": 10, "name": "Press 1", "serial_number": "SN-0001", "model": "MX-100", "manufacturer": "ABB", "status": "OPERATIONAL", "asset_tag": "TAG-001", "description": "Primary press", "install_date": "2024-01-01" }UpdateMachineDto: ugyanazok a mezők, mind opcionális.4)Eszközök (Assets)•GET /api/v1/assets•GET /api/v1/assets/{id}•POST /api/v1/assets•Body: CreateAssetDto•PUT /api/v1/assets/{id}•Body: UpdateAssetDto•DELETE /api/v1/assets/{id}AssetDto: { "id": 1, "name": "Bearing", "category": "Spare", "asset_tag": "AST-001", "location": "Warehouse A", "purchase_date": "2024-02-01", "purchase_price": 100.50, "warranty_expiry": "2026-02-01", "description": "Spare bearing" }CreateAssetDto/UpdateAssetDto: a fenti mezők (update esetén opcionális).5)Raktár (Inventory)•GET /api/v1/inventory•Query (opcionális): search, category, min_stock_level•GET /api/v1/inventory/{id}•POST /api/v1/inventory•Body: CreateInventoryDto { name, sku, quantity, min_stock_level, location, unit_price }•PUT /api/v1/inventory/{id}•Body: UpdateInventoryDto•DELETE /api/v1/inventory/{id}InventoryDto: { "id": 1, "name": "Bearing", "sku": "BR-001", "quantity": 100, "min_stock_level": 10, "location": "Warehouse A", "unit_price": 100.50, "created_at": "2024-02-01T10:00:00Z" }6)Munkalapok (Worksheets)•GET /api/v1/worksheets•Query: status=PENDING|IN_PROGRESS|COMPLETED|CANCELLED•GET /api/v1/worksheets/{id}•POST /api/v1/worksheets•Body: CreateWorksheetDto•PUT /api/v1/worksheets/{id}•Body: UpdateWorksheetDto•DELETE /api/v1/worksheets/{id}WorksheetDto: { "id": 1, "worksheet_number": "WS-2024-0001", "title": "Fix press", "description": "Replace bearing", "type": "CORRECTIVE", "priority": "HIGH", "status": "PENDING", "assigned_to_user_id": 123, "scheduled_start_date": "2024-03-01T08:00:00Z", "scheduled_end_date": "2024-03-01T16:00:00Z", "actual_start_date": null, "actual_end_date": null, "completion_notes": null, "parts_used": [ { "inventory_id": 1, "qty": 2 } ] }CreateWorksheetDto: { "worksheet_number": "WS-2024-0001", "title": "Fix press", "description": "Replace bearing", "type": "CORRECTIVE|PREVENTIVE", "priority": "LOW|MEDIUM|HIGH|URGENT", "assigned_to_user_id": 123, "scheduled_start_date": "2024-03-01T08:00:00Z", "scheduled_end_date": "2024-03-01T16:00:00Z" }UpdateWorksheetDto: fenti mezők opcionálisan.7)PM (Preventive Maintenance)•GET /api/v1/pm/tasks•GET /api/v1/pm/tasks/{id}•POST /api/v1/pm/tasks•Body: CreatePMTaskDto { machine_id, title, description, frequency, next_due_date }•PUT /api/v1/pm/tasks/{id}•Body: UpdatePMTaskDto•DELETE /api/v1/pm/tasks/{id}PMTaskDto: { "id": 1, "machine_id": 10, "title": "Monthly inspection", "description": "Check lubrication", "frequency": "MONTHLY", "next_due_date": "2024-04-01" }8)Dashboard/Reports (opcionális aggregációk)•GET /api/v1/reports/summary•Válasz: { "machines_total": 25, "worksheets_open": 12, "inventory_low_stock": 5, "pm_due_this_week": 3 }•GET /api/v1/reports/trends (opcionális)Állapotkódok és hibák•200 OK, 201 Created, 204 No Content•400 Bad Request (érvénytelen input)•401 Unauthorized (invalid token / login hiba)•403 Forbidden (nincs jogosultság)•404 Not Found (rossz útvonal vagy erőforrás nem létezik)•409 Conflict (ütközés pl. duplikált azonosító)•500 Internal Server ErrorAutorizáció•Login után az app a kapott access_token-t Bearer módban küldi.•Védett végpontok (machines, assets, inventory, worksheets, pm, users) tokennel hívandók.Adatbázis sémák – javaslat (MySQL)•users(id PK, email UNIQUE, password_hash, role, created_at)•machines(id PK, production_line_id, name, serial_number, model, manufacturer, status, asset_tag, description, install_date, created_at, updated_at)•assets(id PK, name, category, asset_tag, location, purchase_date, purchase_price DECIMAL(10,2), warranty_expiry, description)•inventory(id PK, name, sku, quantity INT, min_stock_level INT, location, unit_price DECIMAL(10,2), created_at)•worksheets(id PK, worksheet_number UNIQUE, title, description, type, priority, status, assigned_to_user_id FK users(id), scheduled_start_date, scheduled_end_date, actual_start_date, actual_end_date, completion_notes)•worksheet_parts(id PK, worksheet_id FK worksheets(id), inventory_id FK inventory(id), qty INT)•pm_tasks(id PK, machine_id FK machines(id), title, description, frequency, next_due_date)Megjegyzések az app kompatibilitáshoz•Login: az app jelenleg {"username","password"} párost küld. A backend fogadja el ezt.•TokenResponse: az app az alábbi kulcsokat várja: access_token, token_type, expires_in, user_id, username, role_name.•Szövegmezők: üres string helyett lehet null is; a backend igazítsa konzisztensen.•Dátumok: ISO8601 javasolt (YYYY-MM-DD vagy YYYY-MM-DDTHH:MM:SSZ).Példa gyors implementáció (Node.js/Express)•POST /api/v1/auth/login: ellenőrizd a users táblát (email==username), bcrypt.compare(password, password_hash), JWT generálás.•CRUD végpontok: standard REST (GET list, GET by id, POST create, PUT update, DELETE).Ezzel a specifikációval a teljes backend funkcionalitás felépíthető és kompatibilis lesz az Android alkalmazással. A Swagger/Redoc generálásához a fenti DTO-kat használd modellként.