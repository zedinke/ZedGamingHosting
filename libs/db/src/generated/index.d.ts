
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model SystemLicense
 * 
 */
export type SystemLicense = $Result.DefaultSelection<Prisma.$SystemLicensePayload>
/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Node
 * 
 */
export type Node = $Result.DefaultSelection<Prisma.$NodePayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model NetworkAllocation
 * 
 */
export type NetworkAllocation = $Result.DefaultSelection<Prisma.$NetworkAllocationPayload>
/**
 * Model Subdomain
 * 
 */
export type Subdomain = $Result.DefaultSelection<Prisma.$SubdomainPayload>
/**
 * Model GameServer
 * 
 */
export type GameServer = $Result.DefaultSelection<Prisma.$GameServerPayload>
/**
 * Model GameCluster
 * 
 */
export type GameCluster = $Result.DefaultSelection<Prisma.$GameClusterPayload>
/**
 * Model Backup
 * 
 */
export type Backup = $Result.DefaultSelection<Prisma.$BackupPayload>
/**
 * Model Metric
 * 
 */
export type Metric = $Result.DefaultSelection<Prisma.$MetricPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model ResourceQuota
 * 
 */
export type ResourceQuota = $Result.DefaultSelection<Prisma.$ResourceQuotaPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model Incident
 * 
 */
export type Incident = $Result.DefaultSelection<Prisma.$IncidentPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model Promotion
 * 
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model PaymentEvent
 * 
 */
export type PaymentEvent = $Result.DefaultSelection<Prisma.$PaymentEventPayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model SlaPolicy
 * 
 */
export type SlaPolicy = $Result.DefaultSelection<Prisma.$SlaPolicyPayload>
/**
 * Model TicketComment
 * 
 */
export type TicketComment = $Result.DefaultSelection<Prisma.$TicketCommentPayload>
/**
 * Model KnowledgeBaseArticle
 * 
 */
export type KnowledgeBaseArticle = $Result.DefaultSelection<Prisma.$KnowledgeBaseArticlePayload>
/**
 * Model KnowledgeBaseCategory
 * 
 */
export type KnowledgeBaseCategory = $Result.DefaultSelection<Prisma.$KnowledgeBaseCategoryPayload>
/**
 * Model ArticleVersion
 * 
 */
export type ArticleVersion = $Result.DefaultSelection<Prisma.$ArticleVersionPayload>
/**
 * Model InvoiceMetadata
 * 
 */
export type InvoiceMetadata = $Result.DefaultSelection<Prisma.$InvoiceMetadataPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const LicenseStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  EXPIRED: 'EXPIRED',
  GRACE_PERIOD: 'GRACE_PERIOD'
};

export type LicenseStatus = (typeof LicenseStatus)[keyof typeof LicenseStatus]


export const UserRole: {
  SUPERADMIN: 'SUPERADMIN',
  RESELLER_ADMIN: 'RESELLER_ADMIN',
  USER: 'USER',
  SUPPORT: 'SUPPORT',
  SUPPORTER: 'SUPPORTER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const DiskType: {
  NVME: 'NVME',
  SSD: 'SSD',
  HDD: 'HDD'
};

export type DiskType = (typeof DiskType)[keyof typeof DiskType]


export const NodeStatus: {
  PROVISIONING: 'PROVISIONING',
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE',
  MAINTENANCE: 'MAINTENANCE'
};

export type NodeStatus = (typeof NodeStatus)[keyof typeof NodeStatus]


export const TaskType: {
  PROVISION: 'PROVISION',
  DEPROVISION: 'DEPROVISION',
  START: 'START',
  STOP: 'STOP',
  RESTART: 'RESTART',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  EXECUTE_COMMAND: 'EXECUTE_COMMAND'
};

export type TaskType = (typeof TaskType)[keyof typeof TaskType]


export const TaskStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const Protocol: {
  UDP: 'UDP',
  TCP: 'TCP'
};

export type Protocol = (typeof Protocol)[keyof typeof Protocol]


export const PortType: {
  GAME: 'GAME',
  RCON: 'RCON',
  QUERY: 'QUERY',
  APP: 'APP',
  TV: 'TV'
};

export type PortType = (typeof PortType)[keyof typeof PortType]


export const GameType: {
  ARK: 'ARK',
  RUST: 'RUST',
  MINECRAFT: 'MINECRAFT',
  CS2: 'CS2',
  PALWORLD: 'PALWORLD',
  ATLAS: 'ATLAS'
};

export type GameType = (typeof GameType)[keyof typeof GameType]


export const ServerStatus: {
  INSTALLING: 'INSTALLING',
  RUNNING: 'RUNNING',
  STOPPED: 'STOPPED',
  STARTING: 'STARTING',
  STOPPING: 'STOPPING',
  CRASHED: 'CRASHED',
  UPDATING: 'UPDATING'
};

export type ServerStatus = (typeof ServerStatus)[keyof typeof ServerStatus]


export const BackupLocation: {
  LOCAL: 'LOCAL',
  S3: 'S3',
  HETZNER_BOX: 'HETZNER_BOX'
};

export type BackupLocation = (typeof BackupLocation)[keyof typeof BackupLocation]


export const AlertSeverity: {
  CRITICAL: 'CRITICAL',
  WARNING: 'WARNING',
  INFO: 'INFO'
};

export type AlertSeverity = (typeof AlertSeverity)[keyof typeof AlertSeverity]


export const ResourceType: {
  NODE: 'NODE',
  SERVER: 'SERVER',
  SYSTEM: 'SYSTEM'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]


export const IncidentSeverity: {
  P0: 'P0',
  P1: 'P1',
  P2: 'P2',
  P3: 'P3'
};

export type IncidentSeverity = (typeof IncidentSeverity)[keyof typeof IncidentSeverity]


export const IncidentStatus: {
  OPEN: 'OPEN',
  INVESTIGATING: 'INVESTIGATING',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type IncidentStatus = (typeof IncidentStatus)[keyof typeof IncidentStatus]


export const PlanStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  ARCHIVED: 'ARCHIVED'
};

export type PlanStatus = (typeof PlanStatus)[keyof typeof PlanStatus]


export const PromotionScope: {
  GLOBAL: 'GLOBAL',
  GAME: 'GAME',
  PLAN: 'PLAN'
};

export type PromotionScope = (typeof PromotionScope)[keyof typeof PromotionScope]


export const OrderStatus: {
  PENDING: 'PENDING',
  PAYMENT_PENDING: 'PAYMENT_PENDING',
  PAID: 'PAID',
  PROVISIONING: 'PROVISIONING',
  ACTIVE: 'ACTIVE',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const PaymentProvider: {
  BARION: 'BARION',
  PAYPAL: 'PAYPAL',
  UPAY: 'UPAY'
};

export type PaymentProvider = (typeof PaymentProvider)[keyof typeof PaymentProvider]


export const PaymentEventStatus: {
  RECEIVED: 'RECEIVED',
  PROCESSED: 'PROCESSED',
  FAILED: 'FAILED'
};

export type PaymentEventStatus = (typeof PaymentEventStatus)[keyof typeof PaymentEventStatus]


export const TicketPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type TicketPriority = (typeof TicketPriority)[keyof typeof TicketPriority]


export const TicketStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  WAITING_CUSTOMER: 'WAITING_CUSTOMER',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]

}

export type LicenseStatus = $Enums.LicenseStatus

export const LicenseStatus: typeof $Enums.LicenseStatus

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type DiskType = $Enums.DiskType

export const DiskType: typeof $Enums.DiskType

export type NodeStatus = $Enums.NodeStatus

export const NodeStatus: typeof $Enums.NodeStatus

export type TaskType = $Enums.TaskType

export const TaskType: typeof $Enums.TaskType

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type Protocol = $Enums.Protocol

export const Protocol: typeof $Enums.Protocol

export type PortType = $Enums.PortType

export const PortType: typeof $Enums.PortType

export type GameType = $Enums.GameType

export const GameType: typeof $Enums.GameType

export type ServerStatus = $Enums.ServerStatus

export const ServerStatus: typeof $Enums.ServerStatus

export type BackupLocation = $Enums.BackupLocation

export const BackupLocation: typeof $Enums.BackupLocation

export type AlertSeverity = $Enums.AlertSeverity

export const AlertSeverity: typeof $Enums.AlertSeverity

export type ResourceType = $Enums.ResourceType

export const ResourceType: typeof $Enums.ResourceType

export type IncidentSeverity = $Enums.IncidentSeverity

export const IncidentSeverity: typeof $Enums.IncidentSeverity

export type IncidentStatus = $Enums.IncidentStatus

export const IncidentStatus: typeof $Enums.IncidentStatus

export type PlanStatus = $Enums.PlanStatus

export const PlanStatus: typeof $Enums.PlanStatus

export type PromotionScope = $Enums.PromotionScope

export const PromotionScope: typeof $Enums.PromotionScope

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type PaymentProvider = $Enums.PaymentProvider

export const PaymentProvider: typeof $Enums.PaymentProvider

export type PaymentEventStatus = $Enums.PaymentEventStatus

export const PaymentEventStatus: typeof $Enums.PaymentEventStatus

export type TicketPriority = $Enums.TicketPriority

export const TicketPriority: typeof $Enums.TicketPriority

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SystemLicenses
 * const systemLicenses = await prisma.systemLicense.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SystemLicenses
   * const systemLicenses = await prisma.systemLicense.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.systemLicense`: Exposes CRUD operations for the **SystemLicense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemLicenses
    * const systemLicenses = await prisma.systemLicense.findMany()
    * ```
    */
  get systemLicense(): Prisma.SystemLicenseDelegate<ExtArgs>;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.node`: Exposes CRUD operations for the **Node** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nodes
    * const nodes = await prisma.node.findMany()
    * ```
    */
  get node(): Prisma.NodeDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.networkAllocation`: Exposes CRUD operations for the **NetworkAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NetworkAllocations
    * const networkAllocations = await prisma.networkAllocation.findMany()
    * ```
    */
  get networkAllocation(): Prisma.NetworkAllocationDelegate<ExtArgs>;

  /**
   * `prisma.subdomain`: Exposes CRUD operations for the **Subdomain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subdomains
    * const subdomains = await prisma.subdomain.findMany()
    * ```
    */
  get subdomain(): Prisma.SubdomainDelegate<ExtArgs>;

  /**
   * `prisma.gameServer`: Exposes CRUD operations for the **GameServer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameServers
    * const gameServers = await prisma.gameServer.findMany()
    * ```
    */
  get gameServer(): Prisma.GameServerDelegate<ExtArgs>;

  /**
   * `prisma.gameCluster`: Exposes CRUD operations for the **GameCluster** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameClusters
    * const gameClusters = await prisma.gameCluster.findMany()
    * ```
    */
  get gameCluster(): Prisma.GameClusterDelegate<ExtArgs>;

  /**
   * `prisma.backup`: Exposes CRUD operations for the **Backup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Backups
    * const backups = await prisma.backup.findMany()
    * ```
    */
  get backup(): Prisma.BackupDelegate<ExtArgs>;

  /**
   * `prisma.metric`: Exposes CRUD operations for the **Metric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Metrics
    * const metrics = await prisma.metric.findMany()
    * ```
    */
  get metric(): Prisma.MetricDelegate<ExtArgs>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs>;

  /**
   * `prisma.resourceQuota`: Exposes CRUD operations for the **ResourceQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResourceQuotas
    * const resourceQuotas = await prisma.resourceQuota.findMany()
    * ```
    */
  get resourceQuota(): Prisma.ResourceQuotaDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.incident`: Exposes CRUD operations for the **Incident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incidents
    * const incidents = await prisma.incident.findMany()
    * ```
    */
  get incident(): Prisma.IncidentDelegate<ExtArgs>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.paymentEvent`: Exposes CRUD operations for the **PaymentEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentEvents
    * const paymentEvents = await prisma.paymentEvent.findMany()
    * ```
    */
  get paymentEvent(): Prisma.PaymentEventDelegate<ExtArgs>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs>;

  /**
   * `prisma.slaPolicy`: Exposes CRUD operations for the **SlaPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SlaPolicies
    * const slaPolicies = await prisma.slaPolicy.findMany()
    * ```
    */
  get slaPolicy(): Prisma.SlaPolicyDelegate<ExtArgs>;

  /**
   * `prisma.ticketComment`: Exposes CRUD operations for the **TicketComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketComments
    * const ticketComments = await prisma.ticketComment.findMany()
    * ```
    */
  get ticketComment(): Prisma.TicketCommentDelegate<ExtArgs>;

  /**
   * `prisma.knowledgeBaseArticle`: Exposes CRUD operations for the **KnowledgeBaseArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeBaseArticles
    * const knowledgeBaseArticles = await prisma.knowledgeBaseArticle.findMany()
    * ```
    */
  get knowledgeBaseArticle(): Prisma.KnowledgeBaseArticleDelegate<ExtArgs>;

  /**
   * `prisma.knowledgeBaseCategory`: Exposes CRUD operations for the **KnowledgeBaseCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeBaseCategories
    * const knowledgeBaseCategories = await prisma.knowledgeBaseCategory.findMany()
    * ```
    */
  get knowledgeBaseCategory(): Prisma.KnowledgeBaseCategoryDelegate<ExtArgs>;

  /**
   * `prisma.articleVersion`: Exposes CRUD operations for the **ArticleVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticleVersions
    * const articleVersions = await prisma.articleVersion.findMany()
    * ```
    */
  get articleVersion(): Prisma.ArticleVersionDelegate<ExtArgs>;

  /**
   * `prisma.invoiceMetadata`: Exposes CRUD operations for the **InvoiceMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceMetadata
    * const invoiceMetadata = await prisma.invoiceMetadata.findMany()
    * ```
    */
  get invoiceMetadata(): Prisma.InvoiceMetadataDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    SystemLicense: 'SystemLicense',
    Tenant: 'Tenant',
    User: 'User',
    AuditLog: 'AuditLog',
    Node: 'Node',
    Task: 'Task',
    NetworkAllocation: 'NetworkAllocation',
    Subdomain: 'Subdomain',
    GameServer: 'GameServer',
    GameCluster: 'GameCluster',
    Backup: 'Backup',
    Metric: 'Metric',
    Alert: 'Alert',
    ResourceQuota: 'ResourceQuota',
    ApiKey: 'ApiKey',
    Incident: 'Incident',
    Plan: 'Plan',
    Promotion: 'Promotion',
    Order: 'Order',
    PaymentEvent: 'PaymentEvent',
    SupportTicket: 'SupportTicket',
    SlaPolicy: 'SlaPolicy',
    TicketComment: 'TicketComment',
    KnowledgeBaseArticle: 'KnowledgeBaseArticle',
    KnowledgeBaseCategory: 'KnowledgeBaseCategory',
    ArticleVersion: 'ArticleVersion',
    InvoiceMetadata: 'InvoiceMetadata'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "systemLicense" | "tenant" | "user" | "auditLog" | "node" | "task" | "networkAllocation" | "subdomain" | "gameServer" | "gameCluster" | "backup" | "metric" | "alert" | "resourceQuota" | "apiKey" | "incident" | "plan" | "promotion" | "order" | "paymentEvent" | "supportTicket" | "slaPolicy" | "ticketComment" | "knowledgeBaseArticle" | "knowledgeBaseCategory" | "articleVersion" | "invoiceMetadata"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      SystemLicense: {
        payload: Prisma.$SystemLicensePayload<ExtArgs>
        fields: Prisma.SystemLicenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemLicenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLicensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemLicenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLicensePayload>
          }
          findFirst: {
            args: Prisma.SystemLicenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLicensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemLicenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLicensePayload>
          }
          findMany: {
            args: Prisma.SystemLicenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLicensePayload>[]
          }
          create: {
            args: Prisma.SystemLicenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLicensePayload>
          }
          createMany: {
            args: Prisma.SystemLicenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemLicenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLicensePayload>
          }
          update: {
            args: Prisma.SystemLicenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLicensePayload>
          }
          deleteMany: {
            args: Prisma.SystemLicenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemLicenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemLicenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLicensePayload>
          }
          aggregate: {
            args: Prisma.SystemLicenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemLicense>
          }
          groupBy: {
            args: Prisma.SystemLicenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemLicenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemLicenseCountArgs<ExtArgs>
            result: $Utils.Optional<SystemLicenseCountAggregateOutputType> | number
          }
        }
      }
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Node: {
        payload: Prisma.$NodePayload<ExtArgs>
        fields: Prisma.NodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          findFirst: {
            args: Prisma.NodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          findMany: {
            args: Prisma.NodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>[]
          }
          create: {
            args: Prisma.NodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          createMany: {
            args: Prisma.NodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          update: {
            args: Prisma.NodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          deleteMany: {
            args: Prisma.NodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          aggregate: {
            args: Prisma.NodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNode>
          }
          groupBy: {
            args: Prisma.NodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NodeCountArgs<ExtArgs>
            result: $Utils.Optional<NodeCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      NetworkAllocation: {
        payload: Prisma.$NetworkAllocationPayload<ExtArgs>
        fields: Prisma.NetworkAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NetworkAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NetworkAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkAllocationPayload>
          }
          findFirst: {
            args: Prisma.NetworkAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NetworkAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkAllocationPayload>
          }
          findMany: {
            args: Prisma.NetworkAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkAllocationPayload>[]
          }
          create: {
            args: Prisma.NetworkAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkAllocationPayload>
          }
          createMany: {
            args: Prisma.NetworkAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NetworkAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkAllocationPayload>
          }
          update: {
            args: Prisma.NetworkAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkAllocationPayload>
          }
          deleteMany: {
            args: Prisma.NetworkAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NetworkAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NetworkAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkAllocationPayload>
          }
          aggregate: {
            args: Prisma.NetworkAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNetworkAllocation>
          }
          groupBy: {
            args: Prisma.NetworkAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NetworkAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NetworkAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<NetworkAllocationCountAggregateOutputType> | number
          }
        }
      }
      Subdomain: {
        payload: Prisma.$SubdomainPayload<ExtArgs>
        fields: Prisma.SubdomainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubdomainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdomainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubdomainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdomainPayload>
          }
          findFirst: {
            args: Prisma.SubdomainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdomainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubdomainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdomainPayload>
          }
          findMany: {
            args: Prisma.SubdomainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdomainPayload>[]
          }
          create: {
            args: Prisma.SubdomainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdomainPayload>
          }
          createMany: {
            args: Prisma.SubdomainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubdomainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdomainPayload>
          }
          update: {
            args: Prisma.SubdomainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdomainPayload>
          }
          deleteMany: {
            args: Prisma.SubdomainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubdomainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubdomainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdomainPayload>
          }
          aggregate: {
            args: Prisma.SubdomainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubdomain>
          }
          groupBy: {
            args: Prisma.SubdomainGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubdomainGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubdomainCountArgs<ExtArgs>
            result: $Utils.Optional<SubdomainCountAggregateOutputType> | number
          }
        }
      }
      GameServer: {
        payload: Prisma.$GameServerPayload<ExtArgs>
        fields: Prisma.GameServerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameServerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameServerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameServerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameServerPayload>
          }
          findFirst: {
            args: Prisma.GameServerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameServerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameServerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameServerPayload>
          }
          findMany: {
            args: Prisma.GameServerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameServerPayload>[]
          }
          create: {
            args: Prisma.GameServerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameServerPayload>
          }
          createMany: {
            args: Prisma.GameServerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GameServerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameServerPayload>
          }
          update: {
            args: Prisma.GameServerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameServerPayload>
          }
          deleteMany: {
            args: Prisma.GameServerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameServerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameServerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameServerPayload>
          }
          aggregate: {
            args: Prisma.GameServerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameServer>
          }
          groupBy: {
            args: Prisma.GameServerGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameServerGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameServerCountArgs<ExtArgs>
            result: $Utils.Optional<GameServerCountAggregateOutputType> | number
          }
        }
      }
      GameCluster: {
        payload: Prisma.$GameClusterPayload<ExtArgs>
        fields: Prisma.GameClusterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameClusterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameClusterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameClusterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameClusterPayload>
          }
          findFirst: {
            args: Prisma.GameClusterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameClusterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameClusterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameClusterPayload>
          }
          findMany: {
            args: Prisma.GameClusterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameClusterPayload>[]
          }
          create: {
            args: Prisma.GameClusterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameClusterPayload>
          }
          createMany: {
            args: Prisma.GameClusterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GameClusterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameClusterPayload>
          }
          update: {
            args: Prisma.GameClusterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameClusterPayload>
          }
          deleteMany: {
            args: Prisma.GameClusterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameClusterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GameClusterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameClusterPayload>
          }
          aggregate: {
            args: Prisma.GameClusterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameCluster>
          }
          groupBy: {
            args: Prisma.GameClusterGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameClusterGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameClusterCountArgs<ExtArgs>
            result: $Utils.Optional<GameClusterCountAggregateOutputType> | number
          }
        }
      }
      Backup: {
        payload: Prisma.$BackupPayload<ExtArgs>
        fields: Prisma.BackupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BackupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BackupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupPayload>
          }
          findFirst: {
            args: Prisma.BackupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BackupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupPayload>
          }
          findMany: {
            args: Prisma.BackupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupPayload>[]
          }
          create: {
            args: Prisma.BackupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupPayload>
          }
          createMany: {
            args: Prisma.BackupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BackupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupPayload>
          }
          update: {
            args: Prisma.BackupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupPayload>
          }
          deleteMany: {
            args: Prisma.BackupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BackupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BackupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BackupPayload>
          }
          aggregate: {
            args: Prisma.BackupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBackup>
          }
          groupBy: {
            args: Prisma.BackupGroupByArgs<ExtArgs>
            result: $Utils.Optional<BackupGroupByOutputType>[]
          }
          count: {
            args: Prisma.BackupCountArgs<ExtArgs>
            result: $Utils.Optional<BackupCountAggregateOutputType> | number
          }
        }
      }
      Metric: {
        payload: Prisma.$MetricPayload<ExtArgs>
        fields: Prisma.MetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          findFirst: {
            args: Prisma.MetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          findMany: {
            args: Prisma.MetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>[]
          }
          create: {
            args: Prisma.MetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          createMany: {
            args: Prisma.MetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          update: {
            args: Prisma.MetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          deleteMany: {
            args: Prisma.MetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetricPayload>
          }
          aggregate: {
            args: Prisma.MetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetric>
          }
          groupBy: {
            args: Prisma.MetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetricCountArgs<ExtArgs>
            result: $Utils.Optional<MetricCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      ResourceQuota: {
        payload: Prisma.$ResourceQuotaPayload<ExtArgs>
        fields: Prisma.ResourceQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceQuotaPayload>
          }
          findFirst: {
            args: Prisma.ResourceQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceQuotaPayload>
          }
          findMany: {
            args: Prisma.ResourceQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceQuotaPayload>[]
          }
          create: {
            args: Prisma.ResourceQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceQuotaPayload>
          }
          createMany: {
            args: Prisma.ResourceQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ResourceQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceQuotaPayload>
          }
          update: {
            args: Prisma.ResourceQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceQuotaPayload>
          }
          deleteMany: {
            args: Prisma.ResourceQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResourceQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceQuotaPayload>
          }
          aggregate: {
            args: Prisma.ResourceQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResourceQuota>
          }
          groupBy: {
            args: Prisma.ResourceQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceQuotaCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      Incident: {
        payload: Prisma.$IncidentPayload<ExtArgs>
        fields: Prisma.IncidentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncidentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncidentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findFirst: {
            args: Prisma.IncidentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncidentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          findMany: {
            args: Prisma.IncidentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>[]
          }
          create: {
            args: Prisma.IncidentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          createMany: {
            args: Prisma.IncidentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IncidentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          update: {
            args: Prisma.IncidentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          deleteMany: {
            args: Prisma.IncidentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncidentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncidentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncidentPayload>
          }
          aggregate: {
            args: Prisma.IncidentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncident>
          }
          groupBy: {
            args: Prisma.IncidentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncidentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncidentCountArgs<ExtArgs>
            result: $Utils.Optional<IncidentCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      PaymentEvent: {
        payload: Prisma.$PaymentEventPayload<ExtArgs>
        fields: Prisma.PaymentEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          findFirst: {
            args: Prisma.PaymentEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          findMany: {
            args: Prisma.PaymentEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>[]
          }
          create: {
            args: Prisma.PaymentEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          createMany: {
            args: Prisma.PaymentEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          update: {
            args: Prisma.PaymentEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          deleteMany: {
            args: Prisma.PaymentEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentEventPayload>
          }
          aggregate: {
            args: Prisma.PaymentEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentEvent>
          }
          groupBy: {
            args: Prisma.PaymentEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentEventCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentEventCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      SlaPolicy: {
        payload: Prisma.$SlaPolicyPayload<ExtArgs>
        fields: Prisma.SlaPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SlaPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlaPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SlaPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlaPolicyPayload>
          }
          findFirst: {
            args: Prisma.SlaPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlaPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SlaPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlaPolicyPayload>
          }
          findMany: {
            args: Prisma.SlaPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlaPolicyPayload>[]
          }
          create: {
            args: Prisma.SlaPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlaPolicyPayload>
          }
          createMany: {
            args: Prisma.SlaPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SlaPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlaPolicyPayload>
          }
          update: {
            args: Prisma.SlaPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlaPolicyPayload>
          }
          deleteMany: {
            args: Prisma.SlaPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SlaPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SlaPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SlaPolicyPayload>
          }
          aggregate: {
            args: Prisma.SlaPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSlaPolicy>
          }
          groupBy: {
            args: Prisma.SlaPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SlaPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SlaPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<SlaPolicyCountAggregateOutputType> | number
          }
        }
      }
      TicketComment: {
        payload: Prisma.$TicketCommentPayload<ExtArgs>
        fields: Prisma.TicketCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findFirst: {
            args: Prisma.TicketCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findMany: {
            args: Prisma.TicketCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          create: {
            args: Prisma.TicketCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          createMany: {
            args: Prisma.TicketCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TicketCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          update: {
            args: Prisma.TicketCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          deleteMany: {
            args: Prisma.TicketCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          aggregate: {
            args: Prisma.TicketCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketComment>
          }
          groupBy: {
            args: Prisma.TicketCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCommentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeBaseArticle: {
        payload: Prisma.$KnowledgeBaseArticlePayload<ExtArgs>
        fields: Prisma.KnowledgeBaseArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeBaseArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeBaseArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseArticlePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeBaseArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeBaseArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseArticlePayload>
          }
          findMany: {
            args: Prisma.KnowledgeBaseArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseArticlePayload>[]
          }
          create: {
            args: Prisma.KnowledgeBaseArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseArticlePayload>
          }
          createMany: {
            args: Prisma.KnowledgeBaseArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KnowledgeBaseArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseArticlePayload>
          }
          update: {
            args: Prisma.KnowledgeBaseArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseArticlePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeBaseArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeBaseArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KnowledgeBaseArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseArticlePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeBaseArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeBaseArticle>
          }
          groupBy: {
            args: Prisma.KnowledgeBaseArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeBaseArticleCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseArticleCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeBaseCategory: {
        payload: Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>
        fields: Prisma.KnowledgeBaseCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeBaseCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeBaseCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseCategoryPayload>
          }
          findFirst: {
            args: Prisma.KnowledgeBaseCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeBaseCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseCategoryPayload>
          }
          findMany: {
            args: Prisma.KnowledgeBaseCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseCategoryPayload>[]
          }
          create: {
            args: Prisma.KnowledgeBaseCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseCategoryPayload>
          }
          createMany: {
            args: Prisma.KnowledgeBaseCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KnowledgeBaseCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseCategoryPayload>
          }
          update: {
            args: Prisma.KnowledgeBaseCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseCategoryPayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeBaseCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeBaseCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KnowledgeBaseCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeBaseCategoryPayload>
          }
          aggregate: {
            args: Prisma.KnowledgeBaseCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeBaseCategory>
          }
          groupBy: {
            args: Prisma.KnowledgeBaseCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeBaseCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeBaseCategoryCountAggregateOutputType> | number
          }
        }
      }
      ArticleVersion: {
        payload: Prisma.$ArticleVersionPayload<ExtArgs>
        fields: Prisma.ArticleVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>
          }
          findFirst: {
            args: Prisma.ArticleVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>
          }
          findMany: {
            args: Prisma.ArticleVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>[]
          }
          create: {
            args: Prisma.ArticleVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>
          }
          createMany: {
            args: Prisma.ArticleVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ArticleVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>
          }
          update: {
            args: Prisma.ArticleVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>
          }
          deleteMany: {
            args: Prisma.ArticleVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArticleVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleVersionPayload>
          }
          aggregate: {
            args: Prisma.ArticleVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticleVersion>
          }
          groupBy: {
            args: Prisma.ArticleVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleVersionCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleVersionCountAggregateOutputType> | number
          }
        }
      }
      InvoiceMetadata: {
        payload: Prisma.$InvoiceMetadataPayload<ExtArgs>
        fields: Prisma.InvoiceMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMetadataPayload>
          }
          findFirst: {
            args: Prisma.InvoiceMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMetadataPayload>
          }
          findMany: {
            args: Prisma.InvoiceMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMetadataPayload>[]
          }
          create: {
            args: Prisma.InvoiceMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMetadataPayload>
          }
          createMany: {
            args: Prisma.InvoiceMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMetadataPayload>
          }
          update: {
            args: Prisma.InvoiceMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMetadataPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMetadataPayload>
          }
          aggregate: {
            args: Prisma.InvoiceMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceMetadata>
          }
          groupBy: {
            args: Prisma.InvoiceMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceMetadataCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    resourceQuotas: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    resourceQuotas?: boolean | TenantCountOutputTypeCountResourceQuotasArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountResourceQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceQuotaWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedServers: number
    auditLogs: number
    resolvedAlerts: number
    resourceQuotas: number
    apiKeys: number
    assignedIncidents: number
    orders: number
    supportTickets: number
    ticketComments: number
    assignedTickets: number
    knowledgeBaseArticles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedServers?: boolean | UserCountOutputTypeCountOwnedServersArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    resolvedAlerts?: boolean | UserCountOutputTypeCountResolvedAlertsArgs
    resourceQuotas?: boolean | UserCountOutputTypeCountResourceQuotasArgs
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
    assignedIncidents?: boolean | UserCountOutputTypeCountAssignedIncidentsArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    supportTickets?: boolean | UserCountOutputTypeCountSupportTicketsArgs
    ticketComments?: boolean | UserCountOutputTypeCountTicketCommentsArgs
    assignedTickets?: boolean | UserCountOutputTypeCountAssignedTicketsArgs
    knowledgeBaseArticles?: boolean | UserCountOutputTypeCountKnowledgeBaseArticlesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedServersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameServerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResolvedAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResourceQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceQuotaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKnowledgeBaseArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseArticleWhereInput
  }


  /**
   * Count Type NodeCountOutputType
   */

  export type NodeCountOutputType = {
    servers: number
    networkAllocations: number
    metrics: number
    alerts: number
    storageClusters: number
    tasks: number
  }

  export type NodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servers?: boolean | NodeCountOutputTypeCountServersArgs
    networkAllocations?: boolean | NodeCountOutputTypeCountNetworkAllocationsArgs
    metrics?: boolean | NodeCountOutputTypeCountMetricsArgs
    alerts?: boolean | NodeCountOutputTypeCountAlertsArgs
    storageClusters?: boolean | NodeCountOutputTypeCountStorageClustersArgs
    tasks?: boolean | NodeCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeCountOutputType
     */
    select?: NodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountServersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameServerWhereInput
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountNetworkAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkAllocationWhereInput
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetricWhereInput
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountStorageClustersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameClusterWhereInput
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type GameServerCountOutputType
   */

  export type GameServerCountOutputType = {
    networkAllocations: number
    subdomains: number
    backups: number
    metrics: number
    alerts: number
    orders: number
  }

  export type GameServerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    networkAllocations?: boolean | GameServerCountOutputTypeCountNetworkAllocationsArgs
    subdomains?: boolean | GameServerCountOutputTypeCountSubdomainsArgs
    backups?: boolean | GameServerCountOutputTypeCountBackupsArgs
    metrics?: boolean | GameServerCountOutputTypeCountMetricsArgs
    alerts?: boolean | GameServerCountOutputTypeCountAlertsArgs
    orders?: boolean | GameServerCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * GameServerCountOutputType without action
   */
  export type GameServerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServerCountOutputType
     */
    select?: GameServerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameServerCountOutputType without action
   */
  export type GameServerCountOutputTypeCountNetworkAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkAllocationWhereInput
  }

  /**
   * GameServerCountOutputType without action
   */
  export type GameServerCountOutputTypeCountSubdomainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubdomainWhereInput
  }

  /**
   * GameServerCountOutputType without action
   */
  export type GameServerCountOutputTypeCountBackupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackupWhereInput
  }

  /**
   * GameServerCountOutputType without action
   */
  export type GameServerCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetricWhereInput
  }

  /**
   * GameServerCountOutputType without action
   */
  export type GameServerCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * GameServerCountOutputType without action
   */
  export type GameServerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type GameClusterCountOutputType
   */

  export type GameClusterCountOutputType = {
    servers: number
  }

  export type GameClusterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servers?: boolean | GameClusterCountOutputTypeCountServersArgs
  }

  // Custom InputTypes
  /**
   * GameClusterCountOutputType without action
   */
  export type GameClusterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameClusterCountOutputType
     */
    select?: GameClusterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameClusterCountOutputType without action
   */
  export type GameClusterCountOutputTypeCountServersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameServerWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    servers: number
    orders: number
    promotions: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servers?: boolean | PlanCountOutputTypeCountServersArgs
    orders?: boolean | PlanCountOutputTypeCountOrdersArgs
    promotions?: boolean | PlanCountOutputTypeCountPromotionsArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountServersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameServerWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountPromotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
  }


  /**
   * Count Type SupportTicketCountOutputType
   */

  export type SupportTicketCountOutputType = {
    comments: number
  }

  export type SupportTicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | SupportTicketCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketCountOutputType
     */
    select?: SupportTicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }


  /**
   * Count Type KnowledgeBaseArticleCountOutputType
   */

  export type KnowledgeBaseArticleCountOutputType = {
    versions: number
  }

  export type KnowledgeBaseArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | KnowledgeBaseArticleCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * KnowledgeBaseArticleCountOutputType without action
   */
  export type KnowledgeBaseArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticleCountOutputType
     */
    select?: KnowledgeBaseArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KnowledgeBaseArticleCountOutputType without action
   */
  export type KnowledgeBaseArticleCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleVersionWhereInput
  }


  /**
   * Count Type KnowledgeBaseCategoryCountOutputType
   */

  export type KnowledgeBaseCategoryCountOutputType = {
    children: number
    articles: number
  }

  export type KnowledgeBaseCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | KnowledgeBaseCategoryCountOutputTypeCountChildrenArgs
    articles?: boolean | KnowledgeBaseCategoryCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * KnowledgeBaseCategoryCountOutputType without action
   */
  export type KnowledgeBaseCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategoryCountOutputType
     */
    select?: KnowledgeBaseCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KnowledgeBaseCategoryCountOutputType without action
   */
  export type KnowledgeBaseCategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseCategoryWhereInput
  }

  /**
   * KnowledgeBaseCategoryCountOutputType without action
   */
  export type KnowledgeBaseCategoryCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseArticleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model SystemLicense
   */

  export type AggregateSystemLicense = {
    _count: SystemLicenseCountAggregateOutputType | null
    _avg: SystemLicenseAvgAggregateOutputType | null
    _sum: SystemLicenseSumAggregateOutputType | null
    _min: SystemLicenseMinAggregateOutputType | null
    _max: SystemLicenseMaxAggregateOutputType | null
  }

  export type SystemLicenseAvgAggregateOutputType = {
    maxNodesAllowed: number | null
  }

  export type SystemLicenseSumAggregateOutputType = {
    maxNodesAllowed: number | null
  }

  export type SystemLicenseMinAggregateOutputType = {
    id: string | null
    licenseKey: string | null
    status: $Enums.LicenseStatus | null
    validUntil: Date | null
    maxNodesAllowed: number | null
    whitelabelEnabled: boolean | null
    signature: string | null
    gracePeriodEnds: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemLicenseMaxAggregateOutputType = {
    id: string | null
    licenseKey: string | null
    status: $Enums.LicenseStatus | null
    validUntil: Date | null
    maxNodesAllowed: number | null
    whitelabelEnabled: boolean | null
    signature: string | null
    gracePeriodEnds: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemLicenseCountAggregateOutputType = {
    id: number
    licenseKey: number
    status: number
    validUntil: number
    maxNodesAllowed: number
    whitelabelEnabled: number
    signature: number
    gracePeriodEnds: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemLicenseAvgAggregateInputType = {
    maxNodesAllowed?: true
  }

  export type SystemLicenseSumAggregateInputType = {
    maxNodesAllowed?: true
  }

  export type SystemLicenseMinAggregateInputType = {
    id?: true
    licenseKey?: true
    status?: true
    validUntil?: true
    maxNodesAllowed?: true
    whitelabelEnabled?: true
    signature?: true
    gracePeriodEnds?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemLicenseMaxAggregateInputType = {
    id?: true
    licenseKey?: true
    status?: true
    validUntil?: true
    maxNodesAllowed?: true
    whitelabelEnabled?: true
    signature?: true
    gracePeriodEnds?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemLicenseCountAggregateInputType = {
    id?: true
    licenseKey?: true
    status?: true
    validUntil?: true
    maxNodesAllowed?: true
    whitelabelEnabled?: true
    signature?: true
    gracePeriodEnds?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemLicenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLicense to aggregate.
     */
    where?: SystemLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLicenses to fetch.
     */
    orderBy?: SystemLicenseOrderByWithRelationInput | SystemLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLicenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemLicenses
    **/
    _count?: true | SystemLicenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemLicenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemLicenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemLicenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemLicenseMaxAggregateInputType
  }

  export type GetSystemLicenseAggregateType<T extends SystemLicenseAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemLicense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemLicense[P]>
      : GetScalarType<T[P], AggregateSystemLicense[P]>
  }




  export type SystemLicenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLicenseWhereInput
    orderBy?: SystemLicenseOrderByWithAggregationInput | SystemLicenseOrderByWithAggregationInput[]
    by: SystemLicenseScalarFieldEnum[] | SystemLicenseScalarFieldEnum
    having?: SystemLicenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemLicenseCountAggregateInputType | true
    _avg?: SystemLicenseAvgAggregateInputType
    _sum?: SystemLicenseSumAggregateInputType
    _min?: SystemLicenseMinAggregateInputType
    _max?: SystemLicenseMaxAggregateInputType
  }

  export type SystemLicenseGroupByOutputType = {
    id: string
    licenseKey: string
    status: $Enums.LicenseStatus
    validUntil: Date
    maxNodesAllowed: number
    whitelabelEnabled: boolean
    signature: string
    gracePeriodEnds: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SystemLicenseCountAggregateOutputType | null
    _avg: SystemLicenseAvgAggregateOutputType | null
    _sum: SystemLicenseSumAggregateOutputType | null
    _min: SystemLicenseMinAggregateOutputType | null
    _max: SystemLicenseMaxAggregateOutputType | null
  }

  type GetSystemLicenseGroupByPayload<T extends SystemLicenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemLicenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemLicenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemLicenseGroupByOutputType[P]>
            : GetScalarType<T[P], SystemLicenseGroupByOutputType[P]>
        }
      >
    >


  export type SystemLicenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    licenseKey?: boolean
    status?: boolean
    validUntil?: boolean
    maxNodesAllowed?: boolean
    whitelabelEnabled?: boolean
    signature?: boolean
    gracePeriodEnds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemLicense"]>


  export type SystemLicenseSelectScalar = {
    id?: boolean
    licenseKey?: boolean
    status?: boolean
    validUntil?: boolean
    maxNodesAllowed?: boolean
    whitelabelEnabled?: boolean
    signature?: boolean
    gracePeriodEnds?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SystemLicensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemLicense"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      licenseKey: string
      status: $Enums.LicenseStatus
      validUntil: Date
      maxNodesAllowed: number
      whitelabelEnabled: boolean
      signature: string
      gracePeriodEnds: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemLicense"]>
    composites: {}
  }

  type SystemLicenseGetPayload<S extends boolean | null | undefined | SystemLicenseDefaultArgs> = $Result.GetResult<Prisma.$SystemLicensePayload, S>

  type SystemLicenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemLicenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemLicenseCountAggregateInputType | true
    }

  export interface SystemLicenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemLicense'], meta: { name: 'SystemLicense' } }
    /**
     * Find zero or one SystemLicense that matches the filter.
     * @param {SystemLicenseFindUniqueArgs} args - Arguments to find a SystemLicense
     * @example
     * // Get one SystemLicense
     * const systemLicense = await prisma.systemLicense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemLicenseFindUniqueArgs>(args: SelectSubset<T, SystemLicenseFindUniqueArgs<ExtArgs>>): Prisma__SystemLicenseClient<$Result.GetResult<Prisma.$SystemLicensePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemLicense that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemLicenseFindUniqueOrThrowArgs} args - Arguments to find a SystemLicense
     * @example
     * // Get one SystemLicense
     * const systemLicense = await prisma.systemLicense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemLicenseFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemLicenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemLicenseClient<$Result.GetResult<Prisma.$SystemLicensePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemLicense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLicenseFindFirstArgs} args - Arguments to find a SystemLicense
     * @example
     * // Get one SystemLicense
     * const systemLicense = await prisma.systemLicense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemLicenseFindFirstArgs>(args?: SelectSubset<T, SystemLicenseFindFirstArgs<ExtArgs>>): Prisma__SystemLicenseClient<$Result.GetResult<Prisma.$SystemLicensePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemLicense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLicenseFindFirstOrThrowArgs} args - Arguments to find a SystemLicense
     * @example
     * // Get one SystemLicense
     * const systemLicense = await prisma.systemLicense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemLicenseFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemLicenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemLicenseClient<$Result.GetResult<Prisma.$SystemLicensePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemLicenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLicenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemLicenses
     * const systemLicenses = await prisma.systemLicense.findMany()
     * 
     * // Get first 10 SystemLicenses
     * const systemLicenses = await prisma.systemLicense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemLicenseWithIdOnly = await prisma.systemLicense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemLicenseFindManyArgs>(args?: SelectSubset<T, SystemLicenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLicensePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemLicense.
     * @param {SystemLicenseCreateArgs} args - Arguments to create a SystemLicense.
     * @example
     * // Create one SystemLicense
     * const SystemLicense = await prisma.systemLicense.create({
     *   data: {
     *     // ... data to create a SystemLicense
     *   }
     * })
     * 
     */
    create<T extends SystemLicenseCreateArgs>(args: SelectSubset<T, SystemLicenseCreateArgs<ExtArgs>>): Prisma__SystemLicenseClient<$Result.GetResult<Prisma.$SystemLicensePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemLicenses.
     * @param {SystemLicenseCreateManyArgs} args - Arguments to create many SystemLicenses.
     * @example
     * // Create many SystemLicenses
     * const systemLicense = await prisma.systemLicense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemLicenseCreateManyArgs>(args?: SelectSubset<T, SystemLicenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemLicense.
     * @param {SystemLicenseDeleteArgs} args - Arguments to delete one SystemLicense.
     * @example
     * // Delete one SystemLicense
     * const SystemLicense = await prisma.systemLicense.delete({
     *   where: {
     *     // ... filter to delete one SystemLicense
     *   }
     * })
     * 
     */
    delete<T extends SystemLicenseDeleteArgs>(args: SelectSubset<T, SystemLicenseDeleteArgs<ExtArgs>>): Prisma__SystemLicenseClient<$Result.GetResult<Prisma.$SystemLicensePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemLicense.
     * @param {SystemLicenseUpdateArgs} args - Arguments to update one SystemLicense.
     * @example
     * // Update one SystemLicense
     * const systemLicense = await prisma.systemLicense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemLicenseUpdateArgs>(args: SelectSubset<T, SystemLicenseUpdateArgs<ExtArgs>>): Prisma__SystemLicenseClient<$Result.GetResult<Prisma.$SystemLicensePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemLicenses.
     * @param {SystemLicenseDeleteManyArgs} args - Arguments to filter SystemLicenses to delete.
     * @example
     * // Delete a few SystemLicenses
     * const { count } = await prisma.systemLicense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemLicenseDeleteManyArgs>(args?: SelectSubset<T, SystemLicenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemLicenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLicenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemLicenses
     * const systemLicense = await prisma.systemLicense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemLicenseUpdateManyArgs>(args: SelectSubset<T, SystemLicenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemLicense.
     * @param {SystemLicenseUpsertArgs} args - Arguments to update or create a SystemLicense.
     * @example
     * // Update or create a SystemLicense
     * const systemLicense = await prisma.systemLicense.upsert({
     *   create: {
     *     // ... data to create a SystemLicense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemLicense we want to update
     *   }
     * })
     */
    upsert<T extends SystemLicenseUpsertArgs>(args: SelectSubset<T, SystemLicenseUpsertArgs<ExtArgs>>): Prisma__SystemLicenseClient<$Result.GetResult<Prisma.$SystemLicensePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemLicenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLicenseCountArgs} args - Arguments to filter SystemLicenses to count.
     * @example
     * // Count the number of SystemLicenses
     * const count = await prisma.systemLicense.count({
     *   where: {
     *     // ... the filter for the SystemLicenses we want to count
     *   }
     * })
    **/
    count<T extends SystemLicenseCountArgs>(
      args?: Subset<T, SystemLicenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemLicenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemLicense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLicenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemLicenseAggregateArgs>(args: Subset<T, SystemLicenseAggregateArgs>): Prisma.PrismaPromise<GetSystemLicenseAggregateType<T>>

    /**
     * Group by SystemLicense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLicenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemLicenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemLicenseGroupByArgs['orderBy'] }
        : { orderBy?: SystemLicenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemLicenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemLicenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemLicense model
   */
  readonly fields: SystemLicenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemLicense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemLicenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemLicense model
   */ 
  interface SystemLicenseFieldRefs {
    readonly id: FieldRef<"SystemLicense", 'String'>
    readonly licenseKey: FieldRef<"SystemLicense", 'String'>
    readonly status: FieldRef<"SystemLicense", 'LicenseStatus'>
    readonly validUntil: FieldRef<"SystemLicense", 'DateTime'>
    readonly maxNodesAllowed: FieldRef<"SystemLicense", 'Int'>
    readonly whitelabelEnabled: FieldRef<"SystemLicense", 'Boolean'>
    readonly signature: FieldRef<"SystemLicense", 'String'>
    readonly gracePeriodEnds: FieldRef<"SystemLicense", 'DateTime'>
    readonly createdAt: FieldRef<"SystemLicense", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemLicense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemLicense findUnique
   */
  export type SystemLicenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLicense
     */
    select?: SystemLicenseSelect<ExtArgs> | null
    /**
     * Filter, which SystemLicense to fetch.
     */
    where: SystemLicenseWhereUniqueInput
  }

  /**
   * SystemLicense findUniqueOrThrow
   */
  export type SystemLicenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLicense
     */
    select?: SystemLicenseSelect<ExtArgs> | null
    /**
     * Filter, which SystemLicense to fetch.
     */
    where: SystemLicenseWhereUniqueInput
  }

  /**
   * SystemLicense findFirst
   */
  export type SystemLicenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLicense
     */
    select?: SystemLicenseSelect<ExtArgs> | null
    /**
     * Filter, which SystemLicense to fetch.
     */
    where?: SystemLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLicenses to fetch.
     */
    orderBy?: SystemLicenseOrderByWithRelationInput | SystemLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLicenses.
     */
    cursor?: SystemLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLicenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLicenses.
     */
    distinct?: SystemLicenseScalarFieldEnum | SystemLicenseScalarFieldEnum[]
  }

  /**
   * SystemLicense findFirstOrThrow
   */
  export type SystemLicenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLicense
     */
    select?: SystemLicenseSelect<ExtArgs> | null
    /**
     * Filter, which SystemLicense to fetch.
     */
    where?: SystemLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLicenses to fetch.
     */
    orderBy?: SystemLicenseOrderByWithRelationInput | SystemLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLicenses.
     */
    cursor?: SystemLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLicenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLicenses.
     */
    distinct?: SystemLicenseScalarFieldEnum | SystemLicenseScalarFieldEnum[]
  }

  /**
   * SystemLicense findMany
   */
  export type SystemLicenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLicense
     */
    select?: SystemLicenseSelect<ExtArgs> | null
    /**
     * Filter, which SystemLicenses to fetch.
     */
    where?: SystemLicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLicenses to fetch.
     */
    orderBy?: SystemLicenseOrderByWithRelationInput | SystemLicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemLicenses.
     */
    cursor?: SystemLicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLicenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLicenses.
     */
    skip?: number
    distinct?: SystemLicenseScalarFieldEnum | SystemLicenseScalarFieldEnum[]
  }

  /**
   * SystemLicense create
   */
  export type SystemLicenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLicense
     */
    select?: SystemLicenseSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemLicense.
     */
    data: XOR<SystemLicenseCreateInput, SystemLicenseUncheckedCreateInput>
  }

  /**
   * SystemLicense createMany
   */
  export type SystemLicenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemLicenses.
     */
    data: SystemLicenseCreateManyInput | SystemLicenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemLicense update
   */
  export type SystemLicenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLicense
     */
    select?: SystemLicenseSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemLicense.
     */
    data: XOR<SystemLicenseUpdateInput, SystemLicenseUncheckedUpdateInput>
    /**
     * Choose, which SystemLicense to update.
     */
    where: SystemLicenseWhereUniqueInput
  }

  /**
   * SystemLicense updateMany
   */
  export type SystemLicenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemLicenses.
     */
    data: XOR<SystemLicenseUpdateManyMutationInput, SystemLicenseUncheckedUpdateManyInput>
    /**
     * Filter which SystemLicenses to update
     */
    where?: SystemLicenseWhereInput
  }

  /**
   * SystemLicense upsert
   */
  export type SystemLicenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLicense
     */
    select?: SystemLicenseSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemLicense to update in case it exists.
     */
    where: SystemLicenseWhereUniqueInput
    /**
     * In case the SystemLicense found by the `where` argument doesn't exist, create a new SystemLicense with this data.
     */
    create: XOR<SystemLicenseCreateInput, SystemLicenseUncheckedCreateInput>
    /**
     * In case the SystemLicense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemLicenseUpdateInput, SystemLicenseUncheckedUpdateInput>
  }

  /**
   * SystemLicense delete
   */
  export type SystemLicenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLicense
     */
    select?: SystemLicenseSelect<ExtArgs> | null
    /**
     * Filter which SystemLicense to delete.
     */
    where: SystemLicenseWhereUniqueInput
  }

  /**
   * SystemLicense deleteMany
   */
  export type SystemLicenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLicenses to delete
     */
    where?: SystemLicenseWhereInput
  }

  /**
   * SystemLicense without action
   */
  export type SystemLicenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLicense
     */
    select?: SystemLicenseSelect<ExtArgs> | null
  }


  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    themeConfig: number
    smtpConfig: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    themeConfig?: true
    smtpConfig?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    domain: string
    themeConfig: JsonValue | null
    smtpConfig: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    themeConfig?: boolean
    smtpConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    resourceQuotas?: boolean | Tenant$resourceQuotasArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>


  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    themeConfig?: boolean
    smtpConfig?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    resourceQuotas?: boolean | Tenant$resourceQuotasArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      resourceQuotas: Prisma.$ResourceQuotaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string
      themeConfig: Prisma.JsonValue | null
      smtpConfig: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    resourceQuotas<T extends Tenant$resourceQuotasArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$resourceQuotasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceQuotaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly domain: FieldRef<"Tenant", 'String'>
    readonly themeConfig: FieldRef<"Tenant", 'Json'>
    readonly smtpConfig: FieldRef<"Tenant", 'Json'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.resourceQuotas
   */
  export type Tenant$resourceQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceQuota
     */
    select?: ResourceQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceQuotaInclude<ExtArgs> | null
    where?: ResourceQuotaWhereInput
    orderBy?: ResourceQuotaOrderByWithRelationInput | ResourceQuotaOrderByWithRelationInput[]
    cursor?: ResourceQuotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceQuotaScalarFieldEnum | ResourceQuotaScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    balance: number | null
  }

  export type UserSumAggregateOutputType = {
    balance: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    twoFactorMethod: string | null
    twoFactorBackupCodes: string | null
    resetToken: string | null
    resetTokenExpires: Date | null
    balance: number | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    twoFactorSecret: string | null
    twoFactorEnabled: boolean | null
    twoFactorMethod: string | null
    twoFactorBackupCodes: string | null
    resetToken: string | null
    resetTokenExpires: Date | null
    balance: number | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    role: number
    twoFactorSecret: number
    twoFactorEnabled: number
    twoFactorMethod: number
    twoFactorBackupCodes: number
    resetToken: number
    resetTokenExpires: number
    balance: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    balance?: true
  }

  export type UserSumAggregateInputType = {
    balance?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    twoFactorMethod?: true
    twoFactorBackupCodes?: true
    resetToken?: true
    resetTokenExpires?: true
    balance?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    twoFactorMethod?: true
    twoFactorBackupCodes?: true
    resetToken?: true
    resetTokenExpires?: true
    balance?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    twoFactorSecret?: true
    twoFactorEnabled?: true
    twoFactorMethod?: true
    twoFactorBackupCodes?: true
    resetToken?: true
    resetTokenExpires?: true
    balance?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret: string | null
    twoFactorEnabled: boolean
    twoFactorMethod: string | null
    twoFactorBackupCodes: string | null
    resetToken: string | null
    resetTokenExpires: Date | null
    balance: number
    tenantId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: boolean
    twoFactorBackupCodes?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
    balance?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
    ownedServers?: boolean | User$ownedServersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    resolvedAlerts?: boolean | User$resolvedAlertsArgs<ExtArgs>
    resourceQuotas?: boolean | User$resourceQuotasArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    assignedIncidents?: boolean | User$assignedIncidentsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    ticketComments?: boolean | User$ticketCommentsArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    knowledgeBaseArticles?: boolean | User$knowledgeBaseArticlesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    twoFactorSecret?: boolean
    twoFactorEnabled?: boolean
    twoFactorMethod?: boolean
    twoFactorBackupCodes?: boolean
    resetToken?: boolean
    resetTokenExpires?: boolean
    balance?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
    ownedServers?: boolean | User$ownedServersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    resolvedAlerts?: boolean | User$resolvedAlertsArgs<ExtArgs>
    resourceQuotas?: boolean | User$resourceQuotasArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    assignedIncidents?: boolean | User$assignedIncidentsArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    ticketComments?: boolean | User$ticketCommentsArgs<ExtArgs>
    assignedTickets?: boolean | User$assignedTicketsArgs<ExtArgs>
    knowledgeBaseArticles?: boolean | User$knowledgeBaseArticlesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      ownedServers: Prisma.$GameServerPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      resolvedAlerts: Prisma.$AlertPayload<ExtArgs>[]
      resourceQuotas: Prisma.$ResourceQuotaPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      assignedIncidents: Prisma.$IncidentPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      supportTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      ticketComments: Prisma.$TicketCommentPayload<ExtArgs>[]
      assignedTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
      knowledgeBaseArticles: Prisma.$KnowledgeBaseArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      role: $Enums.UserRole
      twoFactorSecret: string | null
      twoFactorEnabled: boolean
      twoFactorMethod: string | null
      twoFactorBackupCodes: string | null
      resetToken: string | null
      resetTokenExpires: Date | null
      balance: number
      tenantId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends User$tenantArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ownedServers<T extends User$ownedServersArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedServersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    resolvedAlerts<T extends User$resolvedAlertsArgs<ExtArgs> = {}>(args?: Subset<T, User$resolvedAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    resourceQuotas<T extends User$resourceQuotasArgs<ExtArgs> = {}>(args?: Subset<T, User$resourceQuotasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceQuotaPayload<ExtArgs>, T, "findMany"> | Null>
    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany"> | Null>
    assignedIncidents<T extends User$assignedIncidentsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedIncidentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    supportTickets<T extends User$supportTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$supportTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany"> | Null>
    ticketComments<T extends User$ticketCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany"> | Null>
    assignedTickets<T extends User$assignedTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany"> | Null>
    knowledgeBaseArticles<T extends User$knowledgeBaseArticlesArgs<ExtArgs> = {}>(args?: Subset<T, User$knowledgeBaseArticlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseArticlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorMethod: FieldRef<"User", 'String'>
    readonly twoFactorBackupCodes: FieldRef<"User", 'String'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpires: FieldRef<"User", 'DateTime'>
    readonly balance: FieldRef<"User", 'Float'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.tenant
   */
  export type User$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * User.ownedServers
   */
  export type User$ownedServersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    where?: GameServerWhereInput
    orderBy?: GameServerOrderByWithRelationInput | GameServerOrderByWithRelationInput[]
    cursor?: GameServerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameServerScalarFieldEnum | GameServerScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.resolvedAlerts
   */
  export type User$resolvedAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * User.resourceQuotas
   */
  export type User$resourceQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceQuota
     */
    select?: ResourceQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceQuotaInclude<ExtArgs> | null
    where?: ResourceQuotaWhereInput
    orderBy?: ResourceQuotaOrderByWithRelationInput | ResourceQuotaOrderByWithRelationInput[]
    cursor?: ResourceQuotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceQuotaScalarFieldEnum | ResourceQuotaScalarFieldEnum[]
  }

  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * User.assignedIncidents
   */
  export type User$assignedIncidentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    cursor?: IncidentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.supportTickets
   */
  export type User$supportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.ticketComments
   */
  export type User$ticketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * User.assignedTickets
   */
  export type User$assignedTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User.knowledgeBaseArticles
   */
  export type User$knowledgeBaseArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticle
     */
    select?: KnowledgeBaseArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseArticleInclude<ExtArgs> | null
    where?: KnowledgeBaseArticleWhereInput
    orderBy?: KnowledgeBaseArticleOrderByWithRelationInput | KnowledgeBaseArticleOrderByWithRelationInput[]
    cursor?: KnowledgeBaseArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeBaseArticleScalarFieldEnum | KnowledgeBaseArticleScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resourceId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resourceId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resourceId: number
    ipAddress: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resourceId?: true
    ipAddress?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    resourceId: string
    ipAddress: string
    details: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>


  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resourceId?: boolean
    ipAddress?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      resourceId: string
      ipAddress: string
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Node
   */

  export type AggregateNode = {
    _count: NodeCountAggregateOutputType | null
    _avg: NodeAvgAggregateOutputType | null
    _sum: NodeSumAggregateOutputType | null
    _min: NodeMinAggregateOutputType | null
    _max: NodeMaxAggregateOutputType | null
  }

  export type NodeAvgAggregateOutputType = {
    totalRam: number | null
    totalCpu: number | null
    maxConcurrentUpdates: number | null
  }

  export type NodeSumAggregateOutputType = {
    totalRam: number | null
    totalCpu: number | null
    maxConcurrentUpdates: number | null
  }

  export type NodeMinAggregateOutputType = {
    id: string | null
    name: string | null
    apiKey: string | null
    ipAddress: string | null
    publicFqdn: string | null
    totalRam: number | null
    totalCpu: number | null
    diskType: $Enums.DiskType | null
    isClusterStorage: boolean | null
    maintenanceMode: boolean | null
    maxConcurrentUpdates: number | null
    status: $Enums.NodeStatus | null
    lastHeartbeat: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NodeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    apiKey: string | null
    ipAddress: string | null
    publicFqdn: string | null
    totalRam: number | null
    totalCpu: number | null
    diskType: $Enums.DiskType | null
    isClusterStorage: boolean | null
    maintenanceMode: boolean | null
    maxConcurrentUpdates: number | null
    status: $Enums.NodeStatus | null
    lastHeartbeat: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NodeCountAggregateOutputType = {
    id: number
    name: number
    apiKey: number
    ipAddress: number
    publicFqdn: number
    totalRam: number
    totalCpu: number
    diskType: number
    isClusterStorage: number
    maintenanceMode: number
    maxConcurrentUpdates: number
    status: number
    lastHeartbeat: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NodeAvgAggregateInputType = {
    totalRam?: true
    totalCpu?: true
    maxConcurrentUpdates?: true
  }

  export type NodeSumAggregateInputType = {
    totalRam?: true
    totalCpu?: true
    maxConcurrentUpdates?: true
  }

  export type NodeMinAggregateInputType = {
    id?: true
    name?: true
    apiKey?: true
    ipAddress?: true
    publicFqdn?: true
    totalRam?: true
    totalCpu?: true
    diskType?: true
    isClusterStorage?: true
    maintenanceMode?: true
    maxConcurrentUpdates?: true
    status?: true
    lastHeartbeat?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NodeMaxAggregateInputType = {
    id?: true
    name?: true
    apiKey?: true
    ipAddress?: true
    publicFqdn?: true
    totalRam?: true
    totalCpu?: true
    diskType?: true
    isClusterStorage?: true
    maintenanceMode?: true
    maxConcurrentUpdates?: true
    status?: true
    lastHeartbeat?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NodeCountAggregateInputType = {
    id?: true
    name?: true
    apiKey?: true
    ipAddress?: true
    publicFqdn?: true
    totalRam?: true
    totalCpu?: true
    diskType?: true
    isClusterStorage?: true
    maintenanceMode?: true
    maxConcurrentUpdates?: true
    status?: true
    lastHeartbeat?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Node to aggregate.
     */
    where?: NodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nodes to fetch.
     */
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nodes
    **/
    _count?: true | NodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NodeMaxAggregateInputType
  }

  export type GetNodeAggregateType<T extends NodeAggregateArgs> = {
        [P in keyof T & keyof AggregateNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNode[P]>
      : GetScalarType<T[P], AggregateNode[P]>
  }




  export type NodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeWhereInput
    orderBy?: NodeOrderByWithAggregationInput | NodeOrderByWithAggregationInput[]
    by: NodeScalarFieldEnum[] | NodeScalarFieldEnum
    having?: NodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NodeCountAggregateInputType | true
    _avg?: NodeAvgAggregateInputType
    _sum?: NodeSumAggregateInputType
    _min?: NodeMinAggregateInputType
    _max?: NodeMaxAggregateInputType
  }

  export type NodeGroupByOutputType = {
    id: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage: boolean
    maintenanceMode: boolean
    maxConcurrentUpdates: number
    status: $Enums.NodeStatus
    lastHeartbeat: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NodeCountAggregateOutputType | null
    _avg: NodeAvgAggregateOutputType | null
    _sum: NodeSumAggregateOutputType | null
    _min: NodeMinAggregateOutputType | null
    _max: NodeMaxAggregateOutputType | null
  }

  type GetNodeGroupByPayload<T extends NodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NodeGroupByOutputType[P]>
            : GetScalarType<T[P], NodeGroupByOutputType[P]>
        }
      >
    >


  export type NodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    apiKey?: boolean
    ipAddress?: boolean
    publicFqdn?: boolean
    totalRam?: boolean
    totalCpu?: boolean
    diskType?: boolean
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    servers?: boolean | Node$serversArgs<ExtArgs>
    networkAllocations?: boolean | Node$networkAllocationsArgs<ExtArgs>
    metrics?: boolean | Node$metricsArgs<ExtArgs>
    alerts?: boolean | Node$alertsArgs<ExtArgs>
    storageClusters?: boolean | Node$storageClustersArgs<ExtArgs>
    tasks?: boolean | Node$tasksArgs<ExtArgs>
    _count?: boolean | NodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["node"]>


  export type NodeSelectScalar = {
    id?: boolean
    name?: boolean
    apiKey?: boolean
    ipAddress?: boolean
    publicFqdn?: boolean
    totalRam?: boolean
    totalCpu?: boolean
    diskType?: boolean
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: boolean
    status?: boolean
    lastHeartbeat?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servers?: boolean | Node$serversArgs<ExtArgs>
    networkAllocations?: boolean | Node$networkAllocationsArgs<ExtArgs>
    metrics?: boolean | Node$metricsArgs<ExtArgs>
    alerts?: boolean | Node$alertsArgs<ExtArgs>
    storageClusters?: boolean | Node$storageClustersArgs<ExtArgs>
    tasks?: boolean | Node$tasksArgs<ExtArgs>
    _count?: boolean | NodeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $NodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Node"
    objects: {
      servers: Prisma.$GameServerPayload<ExtArgs>[]
      networkAllocations: Prisma.$NetworkAllocationPayload<ExtArgs>[]
      metrics: Prisma.$MetricPayload<ExtArgs>[]
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      storageClusters: Prisma.$GameClusterPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      apiKey: string
      ipAddress: string
      publicFqdn: string | null
      totalRam: number
      totalCpu: number
      diskType: $Enums.DiskType
      isClusterStorage: boolean
      maintenanceMode: boolean
      maxConcurrentUpdates: number
      status: $Enums.NodeStatus
      lastHeartbeat: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["node"]>
    composites: {}
  }

  type NodeGetPayload<S extends boolean | null | undefined | NodeDefaultArgs> = $Result.GetResult<Prisma.$NodePayload, S>

  type NodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NodeCountAggregateInputType | true
    }

  export interface NodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Node'], meta: { name: 'Node' } }
    /**
     * Find zero or one Node that matches the filter.
     * @param {NodeFindUniqueArgs} args - Arguments to find a Node
     * @example
     * // Get one Node
     * const node = await prisma.node.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NodeFindUniqueArgs>(args: SelectSubset<T, NodeFindUniqueArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Node that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NodeFindUniqueOrThrowArgs} args - Arguments to find a Node
     * @example
     * // Get one Node
     * const node = await prisma.node.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NodeFindUniqueOrThrowArgs>(args: SelectSubset<T, NodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Node that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeFindFirstArgs} args - Arguments to find a Node
     * @example
     * // Get one Node
     * const node = await prisma.node.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NodeFindFirstArgs>(args?: SelectSubset<T, NodeFindFirstArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Node that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeFindFirstOrThrowArgs} args - Arguments to find a Node
     * @example
     * // Get one Node
     * const node = await prisma.node.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NodeFindFirstOrThrowArgs>(args?: SelectSubset<T, NodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Nodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nodes
     * const nodes = await prisma.node.findMany()
     * 
     * // Get first 10 Nodes
     * const nodes = await prisma.node.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nodeWithIdOnly = await prisma.node.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NodeFindManyArgs>(args?: SelectSubset<T, NodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Node.
     * @param {NodeCreateArgs} args - Arguments to create a Node.
     * @example
     * // Create one Node
     * const Node = await prisma.node.create({
     *   data: {
     *     // ... data to create a Node
     *   }
     * })
     * 
     */
    create<T extends NodeCreateArgs>(args: SelectSubset<T, NodeCreateArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Nodes.
     * @param {NodeCreateManyArgs} args - Arguments to create many Nodes.
     * @example
     * // Create many Nodes
     * const node = await prisma.node.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NodeCreateManyArgs>(args?: SelectSubset<T, NodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Node.
     * @param {NodeDeleteArgs} args - Arguments to delete one Node.
     * @example
     * // Delete one Node
     * const Node = await prisma.node.delete({
     *   where: {
     *     // ... filter to delete one Node
     *   }
     * })
     * 
     */
    delete<T extends NodeDeleteArgs>(args: SelectSubset<T, NodeDeleteArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Node.
     * @param {NodeUpdateArgs} args - Arguments to update one Node.
     * @example
     * // Update one Node
     * const node = await prisma.node.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NodeUpdateArgs>(args: SelectSubset<T, NodeUpdateArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Nodes.
     * @param {NodeDeleteManyArgs} args - Arguments to filter Nodes to delete.
     * @example
     * // Delete a few Nodes
     * const { count } = await prisma.node.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NodeDeleteManyArgs>(args?: SelectSubset<T, NodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nodes
     * const node = await prisma.node.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NodeUpdateManyArgs>(args: SelectSubset<T, NodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Node.
     * @param {NodeUpsertArgs} args - Arguments to update or create a Node.
     * @example
     * // Update or create a Node
     * const node = await prisma.node.upsert({
     *   create: {
     *     // ... data to create a Node
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Node we want to update
     *   }
     * })
     */
    upsert<T extends NodeUpsertArgs>(args: SelectSubset<T, NodeUpsertArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeCountArgs} args - Arguments to filter Nodes to count.
     * @example
     * // Count the number of Nodes
     * const count = await prisma.node.count({
     *   where: {
     *     // ... the filter for the Nodes we want to count
     *   }
     * })
    **/
    count<T extends NodeCountArgs>(
      args?: Subset<T, NodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Node.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NodeAggregateArgs>(args: Subset<T, NodeAggregateArgs>): Prisma.PrismaPromise<GetNodeAggregateType<T>>

    /**
     * Group by Node.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NodeGroupByArgs['orderBy'] }
        : { orderBy?: NodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Node model
   */
  readonly fields: NodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Node.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servers<T extends Node$serversArgs<ExtArgs> = {}>(args?: Subset<T, Node$serversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findMany"> | Null>
    networkAllocations<T extends Node$networkAllocationsArgs<ExtArgs> = {}>(args?: Subset<T, Node$networkAllocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkAllocationPayload<ExtArgs>, T, "findMany"> | Null>
    metrics<T extends Node$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Node$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findMany"> | Null>
    alerts<T extends Node$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Node$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    storageClusters<T extends Node$storageClustersArgs<ExtArgs> = {}>(args?: Subset<T, Node$storageClustersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameClusterPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Node$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Node$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Node model
   */ 
  interface NodeFieldRefs {
    readonly id: FieldRef<"Node", 'String'>
    readonly name: FieldRef<"Node", 'String'>
    readonly apiKey: FieldRef<"Node", 'String'>
    readonly ipAddress: FieldRef<"Node", 'String'>
    readonly publicFqdn: FieldRef<"Node", 'String'>
    readonly totalRam: FieldRef<"Node", 'Int'>
    readonly totalCpu: FieldRef<"Node", 'Int'>
    readonly diskType: FieldRef<"Node", 'DiskType'>
    readonly isClusterStorage: FieldRef<"Node", 'Boolean'>
    readonly maintenanceMode: FieldRef<"Node", 'Boolean'>
    readonly maxConcurrentUpdates: FieldRef<"Node", 'Int'>
    readonly status: FieldRef<"Node", 'NodeStatus'>
    readonly lastHeartbeat: FieldRef<"Node", 'DateTime'>
    readonly createdAt: FieldRef<"Node", 'DateTime'>
    readonly updatedAt: FieldRef<"Node", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Node findUnique
   */
  export type NodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Node to fetch.
     */
    where: NodeWhereUniqueInput
  }

  /**
   * Node findUniqueOrThrow
   */
  export type NodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Node to fetch.
     */
    where: NodeWhereUniqueInput
  }

  /**
   * Node findFirst
   */
  export type NodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Node to fetch.
     */
    where?: NodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nodes to fetch.
     */
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nodes.
     */
    cursor?: NodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nodes.
     */
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Node findFirstOrThrow
   */
  export type NodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Node to fetch.
     */
    where?: NodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nodes to fetch.
     */
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nodes.
     */
    cursor?: NodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nodes.
     */
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Node findMany
   */
  export type NodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Nodes to fetch.
     */
    where?: NodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nodes to fetch.
     */
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nodes.
     */
    cursor?: NodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nodes.
     */
    skip?: number
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Node create
   */
  export type NodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * The data needed to create a Node.
     */
    data: XOR<NodeCreateInput, NodeUncheckedCreateInput>
  }

  /**
   * Node createMany
   */
  export type NodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nodes.
     */
    data: NodeCreateManyInput | NodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Node update
   */
  export type NodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * The data needed to update a Node.
     */
    data: XOR<NodeUpdateInput, NodeUncheckedUpdateInput>
    /**
     * Choose, which Node to update.
     */
    where: NodeWhereUniqueInput
  }

  /**
   * Node updateMany
   */
  export type NodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nodes.
     */
    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyInput>
    /**
     * Filter which Nodes to update
     */
    where?: NodeWhereInput
  }

  /**
   * Node upsert
   */
  export type NodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * The filter to search for the Node to update in case it exists.
     */
    where: NodeWhereUniqueInput
    /**
     * In case the Node found by the `where` argument doesn't exist, create a new Node with this data.
     */
    create: XOR<NodeCreateInput, NodeUncheckedCreateInput>
    /**
     * In case the Node was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NodeUpdateInput, NodeUncheckedUpdateInput>
  }

  /**
   * Node delete
   */
  export type NodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter which Node to delete.
     */
    where: NodeWhereUniqueInput
  }

  /**
   * Node deleteMany
   */
  export type NodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nodes to delete
     */
    where?: NodeWhereInput
  }

  /**
   * Node.servers
   */
  export type Node$serversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    where?: GameServerWhereInput
    orderBy?: GameServerOrderByWithRelationInput | GameServerOrderByWithRelationInput[]
    cursor?: GameServerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameServerScalarFieldEnum | GameServerScalarFieldEnum[]
  }

  /**
   * Node.networkAllocations
   */
  export type Node$networkAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkAllocation
     */
    select?: NetworkAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkAllocationInclude<ExtArgs> | null
    where?: NetworkAllocationWhereInput
    orderBy?: NetworkAllocationOrderByWithRelationInput | NetworkAllocationOrderByWithRelationInput[]
    cursor?: NetworkAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkAllocationScalarFieldEnum | NetworkAllocationScalarFieldEnum[]
  }

  /**
   * Node.metrics
   */
  export type Node$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricInclude<ExtArgs> | null
    where?: MetricWhereInput
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    cursor?: MetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Node.alerts
   */
  export type Node$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Node.storageClusters
   */
  export type Node$storageClustersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCluster
     */
    select?: GameClusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameClusterInclude<ExtArgs> | null
    where?: GameClusterWhereInput
    orderBy?: GameClusterOrderByWithRelationInput | GameClusterOrderByWithRelationInput[]
    cursor?: GameClusterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameClusterScalarFieldEnum | GameClusterScalarFieldEnum[]
  }

  /**
   * Node.tasks
   */
  export type Node$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Node without action
   */
  export type NodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    nodeId: string | null
    type: $Enums.TaskType | null
    status: $Enums.TaskStatus | null
    error: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    nodeId: string | null
    type: $Enums.TaskType | null
    status: $Enums.TaskStatus | null
    error: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    nodeId: number
    type: number
    status: number
    data: number
    error: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    nodeId?: true
    type?: true
    status?: true
    error?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    nodeId?: true
    type?: true
    status?: true
    error?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    nodeId?: true
    type?: true
    status?: true
    data?: true
    error?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    nodeId: string
    type: $Enums.TaskType
    status: $Enums.TaskStatus
    data: JsonValue
    error: string | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    error?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    node?: boolean | NodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>


  export type TaskSelectScalar = {
    id?: boolean
    nodeId?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    error?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    node?: boolean | NodeDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      node: Prisma.$NodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nodeId: string
      type: $Enums.TaskType
      status: $Enums.TaskStatus
      data: Prisma.JsonValue
      error: string | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    node<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly nodeId: FieldRef<"Task", 'String'>
    readonly type: FieldRef<"Task", 'TaskType'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly data: FieldRef<"Task", 'Json'>
    readonly error: FieldRef<"Task", 'String'>
    readonly completedAt: FieldRef<"Task", 'DateTime'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model NetworkAllocation
   */

  export type AggregateNetworkAllocation = {
    _count: NetworkAllocationCountAggregateOutputType | null
    _avg: NetworkAllocationAvgAggregateOutputType | null
    _sum: NetworkAllocationSumAggregateOutputType | null
    _min: NetworkAllocationMinAggregateOutputType | null
    _max: NetworkAllocationMaxAggregateOutputType | null
  }

  export type NetworkAllocationAvgAggregateOutputType = {
    port: number | null
  }

  export type NetworkAllocationSumAggregateOutputType = {
    port: number | null
  }

  export type NetworkAllocationMinAggregateOutputType = {
    id: string | null
    nodeId: string | null
    port: number | null
    protocol: $Enums.Protocol | null
    type: $Enums.PortType | null
    serverUuid: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NetworkAllocationMaxAggregateOutputType = {
    id: string | null
    nodeId: string | null
    port: number | null
    protocol: $Enums.Protocol | null
    type: $Enums.PortType | null
    serverUuid: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NetworkAllocationCountAggregateOutputType = {
    id: number
    nodeId: number
    port: number
    protocol: number
    type: number
    serverUuid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NetworkAllocationAvgAggregateInputType = {
    port?: true
  }

  export type NetworkAllocationSumAggregateInputType = {
    port?: true
  }

  export type NetworkAllocationMinAggregateInputType = {
    id?: true
    nodeId?: true
    port?: true
    protocol?: true
    type?: true
    serverUuid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NetworkAllocationMaxAggregateInputType = {
    id?: true
    nodeId?: true
    port?: true
    protocol?: true
    type?: true
    serverUuid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NetworkAllocationCountAggregateInputType = {
    id?: true
    nodeId?: true
    port?: true
    protocol?: true
    type?: true
    serverUuid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NetworkAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkAllocation to aggregate.
     */
    where?: NetworkAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkAllocations to fetch.
     */
    orderBy?: NetworkAllocationOrderByWithRelationInput | NetworkAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NetworkAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NetworkAllocations
    **/
    _count?: true | NetworkAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NetworkAllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NetworkAllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NetworkAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NetworkAllocationMaxAggregateInputType
  }

  export type GetNetworkAllocationAggregateType<T extends NetworkAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregateNetworkAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNetworkAllocation[P]>
      : GetScalarType<T[P], AggregateNetworkAllocation[P]>
  }




  export type NetworkAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkAllocationWhereInput
    orderBy?: NetworkAllocationOrderByWithAggregationInput | NetworkAllocationOrderByWithAggregationInput[]
    by: NetworkAllocationScalarFieldEnum[] | NetworkAllocationScalarFieldEnum
    having?: NetworkAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NetworkAllocationCountAggregateInputType | true
    _avg?: NetworkAllocationAvgAggregateInputType
    _sum?: NetworkAllocationSumAggregateInputType
    _min?: NetworkAllocationMinAggregateInputType
    _max?: NetworkAllocationMaxAggregateInputType
  }

  export type NetworkAllocationGroupByOutputType = {
    id: string
    nodeId: string
    port: number
    protocol: $Enums.Protocol
    type: $Enums.PortType
    serverUuid: string | null
    createdAt: Date
    updatedAt: Date
    _count: NetworkAllocationCountAggregateOutputType | null
    _avg: NetworkAllocationAvgAggregateOutputType | null
    _sum: NetworkAllocationSumAggregateOutputType | null
    _min: NetworkAllocationMinAggregateOutputType | null
    _max: NetworkAllocationMaxAggregateOutputType | null
  }

  type GetNetworkAllocationGroupByPayload<T extends NetworkAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NetworkAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NetworkAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NetworkAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], NetworkAllocationGroupByOutputType[P]>
        }
      >
    >


  export type NetworkAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    port?: boolean
    protocol?: boolean
    type?: boolean
    serverUuid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    node?: boolean | NodeDefaultArgs<ExtArgs>
    server?: boolean | NetworkAllocation$serverArgs<ExtArgs>
  }, ExtArgs["result"]["networkAllocation"]>


  export type NetworkAllocationSelectScalar = {
    id?: boolean
    nodeId?: boolean
    port?: boolean
    protocol?: boolean
    type?: boolean
    serverUuid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NetworkAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    node?: boolean | NodeDefaultArgs<ExtArgs>
    server?: boolean | NetworkAllocation$serverArgs<ExtArgs>
  }

  export type $NetworkAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NetworkAllocation"
    objects: {
      node: Prisma.$NodePayload<ExtArgs>
      server: Prisma.$GameServerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nodeId: string
      port: number
      protocol: $Enums.Protocol
      type: $Enums.PortType
      serverUuid: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["networkAllocation"]>
    composites: {}
  }

  type NetworkAllocationGetPayload<S extends boolean | null | undefined | NetworkAllocationDefaultArgs> = $Result.GetResult<Prisma.$NetworkAllocationPayload, S>

  type NetworkAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NetworkAllocationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NetworkAllocationCountAggregateInputType | true
    }

  export interface NetworkAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NetworkAllocation'], meta: { name: 'NetworkAllocation' } }
    /**
     * Find zero or one NetworkAllocation that matches the filter.
     * @param {NetworkAllocationFindUniqueArgs} args - Arguments to find a NetworkAllocation
     * @example
     * // Get one NetworkAllocation
     * const networkAllocation = await prisma.networkAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NetworkAllocationFindUniqueArgs>(args: SelectSubset<T, NetworkAllocationFindUniqueArgs<ExtArgs>>): Prisma__NetworkAllocationClient<$Result.GetResult<Prisma.$NetworkAllocationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NetworkAllocation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NetworkAllocationFindUniqueOrThrowArgs} args - Arguments to find a NetworkAllocation
     * @example
     * // Get one NetworkAllocation
     * const networkAllocation = await prisma.networkAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NetworkAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, NetworkAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NetworkAllocationClient<$Result.GetResult<Prisma.$NetworkAllocationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NetworkAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkAllocationFindFirstArgs} args - Arguments to find a NetworkAllocation
     * @example
     * // Get one NetworkAllocation
     * const networkAllocation = await prisma.networkAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NetworkAllocationFindFirstArgs>(args?: SelectSubset<T, NetworkAllocationFindFirstArgs<ExtArgs>>): Prisma__NetworkAllocationClient<$Result.GetResult<Prisma.$NetworkAllocationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NetworkAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkAllocationFindFirstOrThrowArgs} args - Arguments to find a NetworkAllocation
     * @example
     * // Get one NetworkAllocation
     * const networkAllocation = await prisma.networkAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NetworkAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, NetworkAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NetworkAllocationClient<$Result.GetResult<Prisma.$NetworkAllocationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NetworkAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NetworkAllocations
     * const networkAllocations = await prisma.networkAllocation.findMany()
     * 
     * // Get first 10 NetworkAllocations
     * const networkAllocations = await prisma.networkAllocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const networkAllocationWithIdOnly = await prisma.networkAllocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NetworkAllocationFindManyArgs>(args?: SelectSubset<T, NetworkAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkAllocationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NetworkAllocation.
     * @param {NetworkAllocationCreateArgs} args - Arguments to create a NetworkAllocation.
     * @example
     * // Create one NetworkAllocation
     * const NetworkAllocation = await prisma.networkAllocation.create({
     *   data: {
     *     // ... data to create a NetworkAllocation
     *   }
     * })
     * 
     */
    create<T extends NetworkAllocationCreateArgs>(args: SelectSubset<T, NetworkAllocationCreateArgs<ExtArgs>>): Prisma__NetworkAllocationClient<$Result.GetResult<Prisma.$NetworkAllocationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NetworkAllocations.
     * @param {NetworkAllocationCreateManyArgs} args - Arguments to create many NetworkAllocations.
     * @example
     * // Create many NetworkAllocations
     * const networkAllocation = await prisma.networkAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NetworkAllocationCreateManyArgs>(args?: SelectSubset<T, NetworkAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NetworkAllocation.
     * @param {NetworkAllocationDeleteArgs} args - Arguments to delete one NetworkAllocation.
     * @example
     * // Delete one NetworkAllocation
     * const NetworkAllocation = await prisma.networkAllocation.delete({
     *   where: {
     *     // ... filter to delete one NetworkAllocation
     *   }
     * })
     * 
     */
    delete<T extends NetworkAllocationDeleteArgs>(args: SelectSubset<T, NetworkAllocationDeleteArgs<ExtArgs>>): Prisma__NetworkAllocationClient<$Result.GetResult<Prisma.$NetworkAllocationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NetworkAllocation.
     * @param {NetworkAllocationUpdateArgs} args - Arguments to update one NetworkAllocation.
     * @example
     * // Update one NetworkAllocation
     * const networkAllocation = await prisma.networkAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NetworkAllocationUpdateArgs>(args: SelectSubset<T, NetworkAllocationUpdateArgs<ExtArgs>>): Prisma__NetworkAllocationClient<$Result.GetResult<Prisma.$NetworkAllocationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NetworkAllocations.
     * @param {NetworkAllocationDeleteManyArgs} args - Arguments to filter NetworkAllocations to delete.
     * @example
     * // Delete a few NetworkAllocations
     * const { count } = await prisma.networkAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NetworkAllocationDeleteManyArgs>(args?: SelectSubset<T, NetworkAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NetworkAllocations
     * const networkAllocation = await prisma.networkAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NetworkAllocationUpdateManyArgs>(args: SelectSubset<T, NetworkAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NetworkAllocation.
     * @param {NetworkAllocationUpsertArgs} args - Arguments to update or create a NetworkAllocation.
     * @example
     * // Update or create a NetworkAllocation
     * const networkAllocation = await prisma.networkAllocation.upsert({
     *   create: {
     *     // ... data to create a NetworkAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NetworkAllocation we want to update
     *   }
     * })
     */
    upsert<T extends NetworkAllocationUpsertArgs>(args: SelectSubset<T, NetworkAllocationUpsertArgs<ExtArgs>>): Prisma__NetworkAllocationClient<$Result.GetResult<Prisma.$NetworkAllocationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NetworkAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkAllocationCountArgs} args - Arguments to filter NetworkAllocations to count.
     * @example
     * // Count the number of NetworkAllocations
     * const count = await prisma.networkAllocation.count({
     *   where: {
     *     // ... the filter for the NetworkAllocations we want to count
     *   }
     * })
    **/
    count<T extends NetworkAllocationCountArgs>(
      args?: Subset<T, NetworkAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NetworkAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NetworkAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NetworkAllocationAggregateArgs>(args: Subset<T, NetworkAllocationAggregateArgs>): Prisma.PrismaPromise<GetNetworkAllocationAggregateType<T>>

    /**
     * Group by NetworkAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NetworkAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NetworkAllocationGroupByArgs['orderBy'] }
        : { orderBy?: NetworkAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NetworkAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNetworkAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NetworkAllocation model
   */
  readonly fields: NetworkAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NetworkAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NetworkAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    node<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    server<T extends NetworkAllocation$serverArgs<ExtArgs> = {}>(args?: Subset<T, NetworkAllocation$serverArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NetworkAllocation model
   */ 
  interface NetworkAllocationFieldRefs {
    readonly id: FieldRef<"NetworkAllocation", 'String'>
    readonly nodeId: FieldRef<"NetworkAllocation", 'String'>
    readonly port: FieldRef<"NetworkAllocation", 'Int'>
    readonly protocol: FieldRef<"NetworkAllocation", 'Protocol'>
    readonly type: FieldRef<"NetworkAllocation", 'PortType'>
    readonly serverUuid: FieldRef<"NetworkAllocation", 'String'>
    readonly createdAt: FieldRef<"NetworkAllocation", 'DateTime'>
    readonly updatedAt: FieldRef<"NetworkAllocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NetworkAllocation findUnique
   */
  export type NetworkAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkAllocation
     */
    select?: NetworkAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkAllocationInclude<ExtArgs> | null
    /**
     * Filter, which NetworkAllocation to fetch.
     */
    where: NetworkAllocationWhereUniqueInput
  }

  /**
   * NetworkAllocation findUniqueOrThrow
   */
  export type NetworkAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkAllocation
     */
    select?: NetworkAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkAllocationInclude<ExtArgs> | null
    /**
     * Filter, which NetworkAllocation to fetch.
     */
    where: NetworkAllocationWhereUniqueInput
  }

  /**
   * NetworkAllocation findFirst
   */
  export type NetworkAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkAllocation
     */
    select?: NetworkAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkAllocationInclude<ExtArgs> | null
    /**
     * Filter, which NetworkAllocation to fetch.
     */
    where?: NetworkAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkAllocations to fetch.
     */
    orderBy?: NetworkAllocationOrderByWithRelationInput | NetworkAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkAllocations.
     */
    cursor?: NetworkAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkAllocations.
     */
    distinct?: NetworkAllocationScalarFieldEnum | NetworkAllocationScalarFieldEnum[]
  }

  /**
   * NetworkAllocation findFirstOrThrow
   */
  export type NetworkAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkAllocation
     */
    select?: NetworkAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkAllocationInclude<ExtArgs> | null
    /**
     * Filter, which NetworkAllocation to fetch.
     */
    where?: NetworkAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkAllocations to fetch.
     */
    orderBy?: NetworkAllocationOrderByWithRelationInput | NetworkAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkAllocations.
     */
    cursor?: NetworkAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkAllocations.
     */
    distinct?: NetworkAllocationScalarFieldEnum | NetworkAllocationScalarFieldEnum[]
  }

  /**
   * NetworkAllocation findMany
   */
  export type NetworkAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkAllocation
     */
    select?: NetworkAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkAllocationInclude<ExtArgs> | null
    /**
     * Filter, which NetworkAllocations to fetch.
     */
    where?: NetworkAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkAllocations to fetch.
     */
    orderBy?: NetworkAllocationOrderByWithRelationInput | NetworkAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NetworkAllocations.
     */
    cursor?: NetworkAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkAllocations.
     */
    skip?: number
    distinct?: NetworkAllocationScalarFieldEnum | NetworkAllocationScalarFieldEnum[]
  }

  /**
   * NetworkAllocation create
   */
  export type NetworkAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkAllocation
     */
    select?: NetworkAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a NetworkAllocation.
     */
    data: XOR<NetworkAllocationCreateInput, NetworkAllocationUncheckedCreateInput>
  }

  /**
   * NetworkAllocation createMany
   */
  export type NetworkAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NetworkAllocations.
     */
    data: NetworkAllocationCreateManyInput | NetworkAllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NetworkAllocation update
   */
  export type NetworkAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkAllocation
     */
    select?: NetworkAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a NetworkAllocation.
     */
    data: XOR<NetworkAllocationUpdateInput, NetworkAllocationUncheckedUpdateInput>
    /**
     * Choose, which NetworkAllocation to update.
     */
    where: NetworkAllocationWhereUniqueInput
  }

  /**
   * NetworkAllocation updateMany
   */
  export type NetworkAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NetworkAllocations.
     */
    data: XOR<NetworkAllocationUpdateManyMutationInput, NetworkAllocationUncheckedUpdateManyInput>
    /**
     * Filter which NetworkAllocations to update
     */
    where?: NetworkAllocationWhereInput
  }

  /**
   * NetworkAllocation upsert
   */
  export type NetworkAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkAllocation
     */
    select?: NetworkAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the NetworkAllocation to update in case it exists.
     */
    where: NetworkAllocationWhereUniqueInput
    /**
     * In case the NetworkAllocation found by the `where` argument doesn't exist, create a new NetworkAllocation with this data.
     */
    create: XOR<NetworkAllocationCreateInput, NetworkAllocationUncheckedCreateInput>
    /**
     * In case the NetworkAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NetworkAllocationUpdateInput, NetworkAllocationUncheckedUpdateInput>
  }

  /**
   * NetworkAllocation delete
   */
  export type NetworkAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkAllocation
     */
    select?: NetworkAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkAllocationInclude<ExtArgs> | null
    /**
     * Filter which NetworkAllocation to delete.
     */
    where: NetworkAllocationWhereUniqueInput
  }

  /**
   * NetworkAllocation deleteMany
   */
  export type NetworkAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkAllocations to delete
     */
    where?: NetworkAllocationWhereInput
  }

  /**
   * NetworkAllocation.server
   */
  export type NetworkAllocation$serverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    where?: GameServerWhereInput
  }

  /**
   * NetworkAllocation without action
   */
  export type NetworkAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkAllocation
     */
    select?: NetworkAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkAllocationInclude<ExtArgs> | null
  }


  /**
   * Model Subdomain
   */

  export type AggregateSubdomain = {
    _count: SubdomainCountAggregateOutputType | null
    _min: SubdomainMinAggregateOutputType | null
    _max: SubdomainMaxAggregateOutputType | null
  }

  export type SubdomainMinAggregateOutputType = {
    id: string | null
    subdomain: string | null
    domain: string | null
    serverUuid: string | null
    cloudflareId: string | null
    targetIP: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubdomainMaxAggregateOutputType = {
    id: string | null
    subdomain: string | null
    domain: string | null
    serverUuid: string | null
    cloudflareId: string | null
    targetIP: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubdomainCountAggregateOutputType = {
    id: number
    subdomain: number
    domain: number
    serverUuid: number
    cloudflareId: number
    targetIP: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubdomainMinAggregateInputType = {
    id?: true
    subdomain?: true
    domain?: true
    serverUuid?: true
    cloudflareId?: true
    targetIP?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubdomainMaxAggregateInputType = {
    id?: true
    subdomain?: true
    domain?: true
    serverUuid?: true
    cloudflareId?: true
    targetIP?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubdomainCountAggregateInputType = {
    id?: true
    subdomain?: true
    domain?: true
    serverUuid?: true
    cloudflareId?: true
    targetIP?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubdomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subdomain to aggregate.
     */
    where?: SubdomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subdomains to fetch.
     */
    orderBy?: SubdomainOrderByWithRelationInput | SubdomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubdomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subdomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subdomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subdomains
    **/
    _count?: true | SubdomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubdomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubdomainMaxAggregateInputType
  }

  export type GetSubdomainAggregateType<T extends SubdomainAggregateArgs> = {
        [P in keyof T & keyof AggregateSubdomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubdomain[P]>
      : GetScalarType<T[P], AggregateSubdomain[P]>
  }




  export type SubdomainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubdomainWhereInput
    orderBy?: SubdomainOrderByWithAggregationInput | SubdomainOrderByWithAggregationInput[]
    by: SubdomainScalarFieldEnum[] | SubdomainScalarFieldEnum
    having?: SubdomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubdomainCountAggregateInputType | true
    _min?: SubdomainMinAggregateInputType
    _max?: SubdomainMaxAggregateInputType
  }

  export type SubdomainGroupByOutputType = {
    id: string
    subdomain: string
    domain: string
    serverUuid: string
    cloudflareId: string
    targetIP: string
    createdAt: Date
    updatedAt: Date
    _count: SubdomainCountAggregateOutputType | null
    _min: SubdomainMinAggregateOutputType | null
    _max: SubdomainMaxAggregateOutputType | null
  }

  type GetSubdomainGroupByPayload<T extends SubdomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubdomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubdomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubdomainGroupByOutputType[P]>
            : GetScalarType<T[P], SubdomainGroupByOutputType[P]>
        }
      >
    >


  export type SubdomainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subdomain?: boolean
    domain?: boolean
    serverUuid?: boolean
    cloudflareId?: boolean
    targetIP?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    server?: boolean | GameServerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subdomain"]>


  export type SubdomainSelectScalar = {
    id?: boolean
    subdomain?: boolean
    domain?: boolean
    serverUuid?: boolean
    cloudflareId?: boolean
    targetIP?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubdomainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    server?: boolean | GameServerDefaultArgs<ExtArgs>
  }

  export type $SubdomainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subdomain"
    objects: {
      server: Prisma.$GameServerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subdomain: string
      domain: string
      serverUuid: string
      cloudflareId: string
      targetIP: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subdomain"]>
    composites: {}
  }

  type SubdomainGetPayload<S extends boolean | null | undefined | SubdomainDefaultArgs> = $Result.GetResult<Prisma.$SubdomainPayload, S>

  type SubdomainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubdomainFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubdomainCountAggregateInputType | true
    }

  export interface SubdomainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subdomain'], meta: { name: 'Subdomain' } }
    /**
     * Find zero or one Subdomain that matches the filter.
     * @param {SubdomainFindUniqueArgs} args - Arguments to find a Subdomain
     * @example
     * // Get one Subdomain
     * const subdomain = await prisma.subdomain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubdomainFindUniqueArgs>(args: SelectSubset<T, SubdomainFindUniqueArgs<ExtArgs>>): Prisma__SubdomainClient<$Result.GetResult<Prisma.$SubdomainPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subdomain that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubdomainFindUniqueOrThrowArgs} args - Arguments to find a Subdomain
     * @example
     * // Get one Subdomain
     * const subdomain = await prisma.subdomain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubdomainFindUniqueOrThrowArgs>(args: SelectSubset<T, SubdomainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubdomainClient<$Result.GetResult<Prisma.$SubdomainPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subdomain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdomainFindFirstArgs} args - Arguments to find a Subdomain
     * @example
     * // Get one Subdomain
     * const subdomain = await prisma.subdomain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubdomainFindFirstArgs>(args?: SelectSubset<T, SubdomainFindFirstArgs<ExtArgs>>): Prisma__SubdomainClient<$Result.GetResult<Prisma.$SubdomainPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subdomain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdomainFindFirstOrThrowArgs} args - Arguments to find a Subdomain
     * @example
     * // Get one Subdomain
     * const subdomain = await prisma.subdomain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubdomainFindFirstOrThrowArgs>(args?: SelectSubset<T, SubdomainFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubdomainClient<$Result.GetResult<Prisma.$SubdomainPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subdomains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdomainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subdomains
     * const subdomains = await prisma.subdomain.findMany()
     * 
     * // Get first 10 Subdomains
     * const subdomains = await prisma.subdomain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subdomainWithIdOnly = await prisma.subdomain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubdomainFindManyArgs>(args?: SelectSubset<T, SubdomainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdomainPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subdomain.
     * @param {SubdomainCreateArgs} args - Arguments to create a Subdomain.
     * @example
     * // Create one Subdomain
     * const Subdomain = await prisma.subdomain.create({
     *   data: {
     *     // ... data to create a Subdomain
     *   }
     * })
     * 
     */
    create<T extends SubdomainCreateArgs>(args: SelectSubset<T, SubdomainCreateArgs<ExtArgs>>): Prisma__SubdomainClient<$Result.GetResult<Prisma.$SubdomainPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subdomains.
     * @param {SubdomainCreateManyArgs} args - Arguments to create many Subdomains.
     * @example
     * // Create many Subdomains
     * const subdomain = await prisma.subdomain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubdomainCreateManyArgs>(args?: SelectSubset<T, SubdomainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subdomain.
     * @param {SubdomainDeleteArgs} args - Arguments to delete one Subdomain.
     * @example
     * // Delete one Subdomain
     * const Subdomain = await prisma.subdomain.delete({
     *   where: {
     *     // ... filter to delete one Subdomain
     *   }
     * })
     * 
     */
    delete<T extends SubdomainDeleteArgs>(args: SelectSubset<T, SubdomainDeleteArgs<ExtArgs>>): Prisma__SubdomainClient<$Result.GetResult<Prisma.$SubdomainPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subdomain.
     * @param {SubdomainUpdateArgs} args - Arguments to update one Subdomain.
     * @example
     * // Update one Subdomain
     * const subdomain = await prisma.subdomain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubdomainUpdateArgs>(args: SelectSubset<T, SubdomainUpdateArgs<ExtArgs>>): Prisma__SubdomainClient<$Result.GetResult<Prisma.$SubdomainPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subdomains.
     * @param {SubdomainDeleteManyArgs} args - Arguments to filter Subdomains to delete.
     * @example
     * // Delete a few Subdomains
     * const { count } = await prisma.subdomain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubdomainDeleteManyArgs>(args?: SelectSubset<T, SubdomainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subdomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subdomains
     * const subdomain = await prisma.subdomain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubdomainUpdateManyArgs>(args: SelectSubset<T, SubdomainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subdomain.
     * @param {SubdomainUpsertArgs} args - Arguments to update or create a Subdomain.
     * @example
     * // Update or create a Subdomain
     * const subdomain = await prisma.subdomain.upsert({
     *   create: {
     *     // ... data to create a Subdomain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subdomain we want to update
     *   }
     * })
     */
    upsert<T extends SubdomainUpsertArgs>(args: SelectSubset<T, SubdomainUpsertArgs<ExtArgs>>): Prisma__SubdomainClient<$Result.GetResult<Prisma.$SubdomainPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subdomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdomainCountArgs} args - Arguments to filter Subdomains to count.
     * @example
     * // Count the number of Subdomains
     * const count = await prisma.subdomain.count({
     *   where: {
     *     // ... the filter for the Subdomains we want to count
     *   }
     * })
    **/
    count<T extends SubdomainCountArgs>(
      args?: Subset<T, SubdomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubdomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subdomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubdomainAggregateArgs>(args: Subset<T, SubdomainAggregateArgs>): Prisma.PrismaPromise<GetSubdomainAggregateType<T>>

    /**
     * Group by Subdomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubdomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubdomainGroupByArgs['orderBy'] }
        : { orderBy?: SubdomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubdomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubdomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subdomain model
   */
  readonly fields: SubdomainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subdomain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubdomainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    server<T extends GameServerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameServerDefaultArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subdomain model
   */ 
  interface SubdomainFieldRefs {
    readonly id: FieldRef<"Subdomain", 'String'>
    readonly subdomain: FieldRef<"Subdomain", 'String'>
    readonly domain: FieldRef<"Subdomain", 'String'>
    readonly serverUuid: FieldRef<"Subdomain", 'String'>
    readonly cloudflareId: FieldRef<"Subdomain", 'String'>
    readonly targetIP: FieldRef<"Subdomain", 'String'>
    readonly createdAt: FieldRef<"Subdomain", 'DateTime'>
    readonly updatedAt: FieldRef<"Subdomain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subdomain findUnique
   */
  export type SubdomainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdomain
     */
    select?: SubdomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdomainInclude<ExtArgs> | null
    /**
     * Filter, which Subdomain to fetch.
     */
    where: SubdomainWhereUniqueInput
  }

  /**
   * Subdomain findUniqueOrThrow
   */
  export type SubdomainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdomain
     */
    select?: SubdomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdomainInclude<ExtArgs> | null
    /**
     * Filter, which Subdomain to fetch.
     */
    where: SubdomainWhereUniqueInput
  }

  /**
   * Subdomain findFirst
   */
  export type SubdomainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdomain
     */
    select?: SubdomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdomainInclude<ExtArgs> | null
    /**
     * Filter, which Subdomain to fetch.
     */
    where?: SubdomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subdomains to fetch.
     */
    orderBy?: SubdomainOrderByWithRelationInput | SubdomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subdomains.
     */
    cursor?: SubdomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subdomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subdomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subdomains.
     */
    distinct?: SubdomainScalarFieldEnum | SubdomainScalarFieldEnum[]
  }

  /**
   * Subdomain findFirstOrThrow
   */
  export type SubdomainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdomain
     */
    select?: SubdomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdomainInclude<ExtArgs> | null
    /**
     * Filter, which Subdomain to fetch.
     */
    where?: SubdomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subdomains to fetch.
     */
    orderBy?: SubdomainOrderByWithRelationInput | SubdomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subdomains.
     */
    cursor?: SubdomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subdomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subdomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subdomains.
     */
    distinct?: SubdomainScalarFieldEnum | SubdomainScalarFieldEnum[]
  }

  /**
   * Subdomain findMany
   */
  export type SubdomainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdomain
     */
    select?: SubdomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdomainInclude<ExtArgs> | null
    /**
     * Filter, which Subdomains to fetch.
     */
    where?: SubdomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subdomains to fetch.
     */
    orderBy?: SubdomainOrderByWithRelationInput | SubdomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subdomains.
     */
    cursor?: SubdomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subdomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subdomains.
     */
    skip?: number
    distinct?: SubdomainScalarFieldEnum | SubdomainScalarFieldEnum[]
  }

  /**
   * Subdomain create
   */
  export type SubdomainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdomain
     */
    select?: SubdomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdomainInclude<ExtArgs> | null
    /**
     * The data needed to create a Subdomain.
     */
    data: XOR<SubdomainCreateInput, SubdomainUncheckedCreateInput>
  }

  /**
   * Subdomain createMany
   */
  export type SubdomainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subdomains.
     */
    data: SubdomainCreateManyInput | SubdomainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subdomain update
   */
  export type SubdomainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdomain
     */
    select?: SubdomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdomainInclude<ExtArgs> | null
    /**
     * The data needed to update a Subdomain.
     */
    data: XOR<SubdomainUpdateInput, SubdomainUncheckedUpdateInput>
    /**
     * Choose, which Subdomain to update.
     */
    where: SubdomainWhereUniqueInput
  }

  /**
   * Subdomain updateMany
   */
  export type SubdomainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subdomains.
     */
    data: XOR<SubdomainUpdateManyMutationInput, SubdomainUncheckedUpdateManyInput>
    /**
     * Filter which Subdomains to update
     */
    where?: SubdomainWhereInput
  }

  /**
   * Subdomain upsert
   */
  export type SubdomainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdomain
     */
    select?: SubdomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdomainInclude<ExtArgs> | null
    /**
     * The filter to search for the Subdomain to update in case it exists.
     */
    where: SubdomainWhereUniqueInput
    /**
     * In case the Subdomain found by the `where` argument doesn't exist, create a new Subdomain with this data.
     */
    create: XOR<SubdomainCreateInput, SubdomainUncheckedCreateInput>
    /**
     * In case the Subdomain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubdomainUpdateInput, SubdomainUncheckedUpdateInput>
  }

  /**
   * Subdomain delete
   */
  export type SubdomainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdomain
     */
    select?: SubdomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdomainInclude<ExtArgs> | null
    /**
     * Filter which Subdomain to delete.
     */
    where: SubdomainWhereUniqueInput
  }

  /**
   * Subdomain deleteMany
   */
  export type SubdomainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subdomains to delete
     */
    where?: SubdomainWhereInput
  }

  /**
   * Subdomain without action
   */
  export type SubdomainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdomain
     */
    select?: SubdomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdomainInclude<ExtArgs> | null
  }


  /**
   * Model GameServer
   */

  export type AggregateGameServer = {
    _count: GameServerCountAggregateOutputType | null
    _avg: GameServerAvgAggregateOutputType | null
    _sum: GameServerSumAggregateOutputType | null
    _min: GameServerMinAggregateOutputType | null
    _max: GameServerMaxAggregateOutputType | null
  }

  export type GameServerAvgAggregateOutputType = {
    startupPriority: number | null
  }

  export type GameServerSumAggregateOutputType = {
    startupPriority: number | null
  }

  export type GameServerMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    gameType: $Enums.GameType | null
    status: $Enums.ServerStatus | null
    nodeId: string | null
    ownerId: string | null
    planId: string | null
    startupPriority: number | null
    clusterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameServerMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    gameType: $Enums.GameType | null
    status: $Enums.ServerStatus | null
    nodeId: string | null
    ownerId: string | null
    planId: string | null
    startupPriority: number | null
    clusterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameServerCountAggregateOutputType = {
    id: number
    uuid: number
    gameType: number
    status: number
    nodeId: number
    ownerId: number
    planId: number
    startupPriority: number
    resources: number
    envVars: number
    clusterId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameServerAvgAggregateInputType = {
    startupPriority?: true
  }

  export type GameServerSumAggregateInputType = {
    startupPriority?: true
  }

  export type GameServerMinAggregateInputType = {
    id?: true
    uuid?: true
    gameType?: true
    status?: true
    nodeId?: true
    ownerId?: true
    planId?: true
    startupPriority?: true
    clusterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameServerMaxAggregateInputType = {
    id?: true
    uuid?: true
    gameType?: true
    status?: true
    nodeId?: true
    ownerId?: true
    planId?: true
    startupPriority?: true
    clusterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameServerCountAggregateInputType = {
    id?: true
    uuid?: true
    gameType?: true
    status?: true
    nodeId?: true
    ownerId?: true
    planId?: true
    startupPriority?: true
    resources?: true
    envVars?: true
    clusterId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameServerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameServer to aggregate.
     */
    where?: GameServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameServers to fetch.
     */
    orderBy?: GameServerOrderByWithRelationInput | GameServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameServers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameServers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameServers
    **/
    _count?: true | GameServerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameServerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameServerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameServerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameServerMaxAggregateInputType
  }

  export type GetGameServerAggregateType<T extends GameServerAggregateArgs> = {
        [P in keyof T & keyof AggregateGameServer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameServer[P]>
      : GetScalarType<T[P], AggregateGameServer[P]>
  }




  export type GameServerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameServerWhereInput
    orderBy?: GameServerOrderByWithAggregationInput | GameServerOrderByWithAggregationInput[]
    by: GameServerScalarFieldEnum[] | GameServerScalarFieldEnum
    having?: GameServerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameServerCountAggregateInputType | true
    _avg?: GameServerAvgAggregateInputType
    _sum?: GameServerSumAggregateInputType
    _min?: GameServerMinAggregateInputType
    _max?: GameServerMaxAggregateInputType
  }

  export type GameServerGroupByOutputType = {
    id: string
    uuid: string
    gameType: $Enums.GameType
    status: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    planId: string | null
    startupPriority: number
    resources: JsonValue
    envVars: JsonValue
    clusterId: string | null
    createdAt: Date
    updatedAt: Date
    _count: GameServerCountAggregateOutputType | null
    _avg: GameServerAvgAggregateOutputType | null
    _sum: GameServerSumAggregateOutputType | null
    _min: GameServerMinAggregateOutputType | null
    _max: GameServerMaxAggregateOutputType | null
  }

  type GetGameServerGroupByPayload<T extends GameServerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameServerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameServerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameServerGroupByOutputType[P]>
            : GetScalarType<T[P], GameServerGroupByOutputType[P]>
        }
      >
    >


  export type GameServerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    gameType?: boolean
    status?: boolean
    nodeId?: boolean
    ownerId?: boolean
    planId?: boolean
    startupPriority?: boolean
    resources?: boolean
    envVars?: boolean
    clusterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    node?: boolean | NodeDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | GameServer$planArgs<ExtArgs>
    cluster?: boolean | GameServer$clusterArgs<ExtArgs>
    networkAllocations?: boolean | GameServer$networkAllocationsArgs<ExtArgs>
    subdomains?: boolean | GameServer$subdomainsArgs<ExtArgs>
    backups?: boolean | GameServer$backupsArgs<ExtArgs>
    metrics?: boolean | GameServer$metricsArgs<ExtArgs>
    alerts?: boolean | GameServer$alertsArgs<ExtArgs>
    orders?: boolean | GameServer$ordersArgs<ExtArgs>
    _count?: boolean | GameServerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameServer"]>


  export type GameServerSelectScalar = {
    id?: boolean
    uuid?: boolean
    gameType?: boolean
    status?: boolean
    nodeId?: boolean
    ownerId?: boolean
    planId?: boolean
    startupPriority?: boolean
    resources?: boolean
    envVars?: boolean
    clusterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameServerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    node?: boolean | NodeDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | GameServer$planArgs<ExtArgs>
    cluster?: boolean | GameServer$clusterArgs<ExtArgs>
    networkAllocations?: boolean | GameServer$networkAllocationsArgs<ExtArgs>
    subdomains?: boolean | GameServer$subdomainsArgs<ExtArgs>
    backups?: boolean | GameServer$backupsArgs<ExtArgs>
    metrics?: boolean | GameServer$metricsArgs<ExtArgs>
    alerts?: boolean | GameServer$alertsArgs<ExtArgs>
    orders?: boolean | GameServer$ordersArgs<ExtArgs>
    _count?: boolean | GameServerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $GameServerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameServer"
    objects: {
      node: Prisma.$NodePayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$PlanPayload<ExtArgs> | null
      cluster: Prisma.$GameClusterPayload<ExtArgs> | null
      networkAllocations: Prisma.$NetworkAllocationPayload<ExtArgs>[]
      subdomains: Prisma.$SubdomainPayload<ExtArgs>[]
      backups: Prisma.$BackupPayload<ExtArgs>[]
      metrics: Prisma.$MetricPayload<ExtArgs>[]
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      gameType: $Enums.GameType
      status: $Enums.ServerStatus
      nodeId: string
      ownerId: string
      planId: string | null
      startupPriority: number
      resources: Prisma.JsonValue
      envVars: Prisma.JsonValue
      clusterId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameServer"]>
    composites: {}
  }

  type GameServerGetPayload<S extends boolean | null | undefined | GameServerDefaultArgs> = $Result.GetResult<Prisma.$GameServerPayload, S>

  type GameServerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameServerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameServerCountAggregateInputType | true
    }

  export interface GameServerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameServer'], meta: { name: 'GameServer' } }
    /**
     * Find zero or one GameServer that matches the filter.
     * @param {GameServerFindUniqueArgs} args - Arguments to find a GameServer
     * @example
     * // Get one GameServer
     * const gameServer = await prisma.gameServer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameServerFindUniqueArgs>(args: SelectSubset<T, GameServerFindUniqueArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GameServer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameServerFindUniqueOrThrowArgs} args - Arguments to find a GameServer
     * @example
     * // Get one GameServer
     * const gameServer = await prisma.gameServer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameServerFindUniqueOrThrowArgs>(args: SelectSubset<T, GameServerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GameServer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerFindFirstArgs} args - Arguments to find a GameServer
     * @example
     * // Get one GameServer
     * const gameServer = await prisma.gameServer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameServerFindFirstArgs>(args?: SelectSubset<T, GameServerFindFirstArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GameServer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerFindFirstOrThrowArgs} args - Arguments to find a GameServer
     * @example
     * // Get one GameServer
     * const gameServer = await prisma.gameServer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameServerFindFirstOrThrowArgs>(args?: SelectSubset<T, GameServerFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GameServers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameServers
     * const gameServers = await prisma.gameServer.findMany()
     * 
     * // Get first 10 GameServers
     * const gameServers = await prisma.gameServer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameServerWithIdOnly = await prisma.gameServer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameServerFindManyArgs>(args?: SelectSubset<T, GameServerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GameServer.
     * @param {GameServerCreateArgs} args - Arguments to create a GameServer.
     * @example
     * // Create one GameServer
     * const GameServer = await prisma.gameServer.create({
     *   data: {
     *     // ... data to create a GameServer
     *   }
     * })
     * 
     */
    create<T extends GameServerCreateArgs>(args: SelectSubset<T, GameServerCreateArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GameServers.
     * @param {GameServerCreateManyArgs} args - Arguments to create many GameServers.
     * @example
     * // Create many GameServers
     * const gameServer = await prisma.gameServer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameServerCreateManyArgs>(args?: SelectSubset<T, GameServerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GameServer.
     * @param {GameServerDeleteArgs} args - Arguments to delete one GameServer.
     * @example
     * // Delete one GameServer
     * const GameServer = await prisma.gameServer.delete({
     *   where: {
     *     // ... filter to delete one GameServer
     *   }
     * })
     * 
     */
    delete<T extends GameServerDeleteArgs>(args: SelectSubset<T, GameServerDeleteArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GameServer.
     * @param {GameServerUpdateArgs} args - Arguments to update one GameServer.
     * @example
     * // Update one GameServer
     * const gameServer = await prisma.gameServer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameServerUpdateArgs>(args: SelectSubset<T, GameServerUpdateArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GameServers.
     * @param {GameServerDeleteManyArgs} args - Arguments to filter GameServers to delete.
     * @example
     * // Delete a few GameServers
     * const { count } = await prisma.gameServer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameServerDeleteManyArgs>(args?: SelectSubset<T, GameServerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameServers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameServers
     * const gameServer = await prisma.gameServer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameServerUpdateManyArgs>(args: SelectSubset<T, GameServerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameServer.
     * @param {GameServerUpsertArgs} args - Arguments to update or create a GameServer.
     * @example
     * // Update or create a GameServer
     * const gameServer = await prisma.gameServer.upsert({
     *   create: {
     *     // ... data to create a GameServer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameServer we want to update
     *   }
     * })
     */
    upsert<T extends GameServerUpsertArgs>(args: SelectSubset<T, GameServerUpsertArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GameServers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerCountArgs} args - Arguments to filter GameServers to count.
     * @example
     * // Count the number of GameServers
     * const count = await prisma.gameServer.count({
     *   where: {
     *     // ... the filter for the GameServers we want to count
     *   }
     * })
    **/
    count<T extends GameServerCountArgs>(
      args?: Subset<T, GameServerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameServerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameServer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameServerAggregateArgs>(args: Subset<T, GameServerAggregateArgs>): Prisma.PrismaPromise<GetGameServerAggregateType<T>>

    /**
     * Group by GameServer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameServerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameServerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameServerGroupByArgs['orderBy'] }
        : { orderBy?: GameServerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameServerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameServerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameServer model
   */
  readonly fields: GameServerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameServer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameServerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    node<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plan<T extends GameServer$planArgs<ExtArgs> = {}>(args?: Subset<T, GameServer$planArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    cluster<T extends GameServer$clusterArgs<ExtArgs> = {}>(args?: Subset<T, GameServer$clusterArgs<ExtArgs>>): Prisma__GameClusterClient<$Result.GetResult<Prisma.$GameClusterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    networkAllocations<T extends GameServer$networkAllocationsArgs<ExtArgs> = {}>(args?: Subset<T, GameServer$networkAllocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkAllocationPayload<ExtArgs>, T, "findMany"> | Null>
    subdomains<T extends GameServer$subdomainsArgs<ExtArgs> = {}>(args?: Subset<T, GameServer$subdomainsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdomainPayload<ExtArgs>, T, "findMany"> | Null>
    backups<T extends GameServer$backupsArgs<ExtArgs> = {}>(args?: Subset<T, GameServer$backupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupPayload<ExtArgs>, T, "findMany"> | Null>
    metrics<T extends GameServer$metricsArgs<ExtArgs> = {}>(args?: Subset<T, GameServer$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findMany"> | Null>
    alerts<T extends GameServer$alertsArgs<ExtArgs> = {}>(args?: Subset<T, GameServer$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends GameServer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, GameServer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameServer model
   */ 
  interface GameServerFieldRefs {
    readonly id: FieldRef<"GameServer", 'String'>
    readonly uuid: FieldRef<"GameServer", 'String'>
    readonly gameType: FieldRef<"GameServer", 'GameType'>
    readonly status: FieldRef<"GameServer", 'ServerStatus'>
    readonly nodeId: FieldRef<"GameServer", 'String'>
    readonly ownerId: FieldRef<"GameServer", 'String'>
    readonly planId: FieldRef<"GameServer", 'String'>
    readonly startupPriority: FieldRef<"GameServer", 'Int'>
    readonly resources: FieldRef<"GameServer", 'Json'>
    readonly envVars: FieldRef<"GameServer", 'Json'>
    readonly clusterId: FieldRef<"GameServer", 'String'>
    readonly createdAt: FieldRef<"GameServer", 'DateTime'>
    readonly updatedAt: FieldRef<"GameServer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameServer findUnique
   */
  export type GameServerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    /**
     * Filter, which GameServer to fetch.
     */
    where: GameServerWhereUniqueInput
  }

  /**
   * GameServer findUniqueOrThrow
   */
  export type GameServerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    /**
     * Filter, which GameServer to fetch.
     */
    where: GameServerWhereUniqueInput
  }

  /**
   * GameServer findFirst
   */
  export type GameServerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    /**
     * Filter, which GameServer to fetch.
     */
    where?: GameServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameServers to fetch.
     */
    orderBy?: GameServerOrderByWithRelationInput | GameServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameServers.
     */
    cursor?: GameServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameServers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameServers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameServers.
     */
    distinct?: GameServerScalarFieldEnum | GameServerScalarFieldEnum[]
  }

  /**
   * GameServer findFirstOrThrow
   */
  export type GameServerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    /**
     * Filter, which GameServer to fetch.
     */
    where?: GameServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameServers to fetch.
     */
    orderBy?: GameServerOrderByWithRelationInput | GameServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameServers.
     */
    cursor?: GameServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameServers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameServers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameServers.
     */
    distinct?: GameServerScalarFieldEnum | GameServerScalarFieldEnum[]
  }

  /**
   * GameServer findMany
   */
  export type GameServerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    /**
     * Filter, which GameServers to fetch.
     */
    where?: GameServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameServers to fetch.
     */
    orderBy?: GameServerOrderByWithRelationInput | GameServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameServers.
     */
    cursor?: GameServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameServers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameServers.
     */
    skip?: number
    distinct?: GameServerScalarFieldEnum | GameServerScalarFieldEnum[]
  }

  /**
   * GameServer create
   */
  export type GameServerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    /**
     * The data needed to create a GameServer.
     */
    data: XOR<GameServerCreateInput, GameServerUncheckedCreateInput>
  }

  /**
   * GameServer createMany
   */
  export type GameServerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameServers.
     */
    data: GameServerCreateManyInput | GameServerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameServer update
   */
  export type GameServerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    /**
     * The data needed to update a GameServer.
     */
    data: XOR<GameServerUpdateInput, GameServerUncheckedUpdateInput>
    /**
     * Choose, which GameServer to update.
     */
    where: GameServerWhereUniqueInput
  }

  /**
   * GameServer updateMany
   */
  export type GameServerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameServers.
     */
    data: XOR<GameServerUpdateManyMutationInput, GameServerUncheckedUpdateManyInput>
    /**
     * Filter which GameServers to update
     */
    where?: GameServerWhereInput
  }

  /**
   * GameServer upsert
   */
  export type GameServerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    /**
     * The filter to search for the GameServer to update in case it exists.
     */
    where: GameServerWhereUniqueInput
    /**
     * In case the GameServer found by the `where` argument doesn't exist, create a new GameServer with this data.
     */
    create: XOR<GameServerCreateInput, GameServerUncheckedCreateInput>
    /**
     * In case the GameServer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameServerUpdateInput, GameServerUncheckedUpdateInput>
  }

  /**
   * GameServer delete
   */
  export type GameServerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    /**
     * Filter which GameServer to delete.
     */
    where: GameServerWhereUniqueInput
  }

  /**
   * GameServer deleteMany
   */
  export type GameServerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameServers to delete
     */
    where?: GameServerWhereInput
  }

  /**
   * GameServer.plan
   */
  export type GameServer$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
  }

  /**
   * GameServer.cluster
   */
  export type GameServer$clusterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCluster
     */
    select?: GameClusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameClusterInclude<ExtArgs> | null
    where?: GameClusterWhereInput
  }

  /**
   * GameServer.networkAllocations
   */
  export type GameServer$networkAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkAllocation
     */
    select?: NetworkAllocationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkAllocationInclude<ExtArgs> | null
    where?: NetworkAllocationWhereInput
    orderBy?: NetworkAllocationOrderByWithRelationInput | NetworkAllocationOrderByWithRelationInput[]
    cursor?: NetworkAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkAllocationScalarFieldEnum | NetworkAllocationScalarFieldEnum[]
  }

  /**
   * GameServer.subdomains
   */
  export type GameServer$subdomainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdomain
     */
    select?: SubdomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdomainInclude<ExtArgs> | null
    where?: SubdomainWhereInput
    orderBy?: SubdomainOrderByWithRelationInput | SubdomainOrderByWithRelationInput[]
    cursor?: SubdomainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubdomainScalarFieldEnum | SubdomainScalarFieldEnum[]
  }

  /**
   * GameServer.backups
   */
  export type GameServer$backupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backup
     */
    select?: BackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupInclude<ExtArgs> | null
    where?: BackupWhereInput
    orderBy?: BackupOrderByWithRelationInput | BackupOrderByWithRelationInput[]
    cursor?: BackupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BackupScalarFieldEnum | BackupScalarFieldEnum[]
  }

  /**
   * GameServer.metrics
   */
  export type GameServer$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricInclude<ExtArgs> | null
    where?: MetricWhereInput
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    cursor?: MetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * GameServer.alerts
   */
  export type GameServer$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * GameServer.orders
   */
  export type GameServer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * GameServer without action
   */
  export type GameServerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
  }


  /**
   * Model GameCluster
   */

  export type AggregateGameCluster = {
    _count: GameClusterCountAggregateOutputType | null
    _min: GameClusterMinAggregateOutputType | null
    _max: GameClusterMaxAggregateOutputType | null
  }

  export type GameClusterMinAggregateOutputType = {
    id: string | null
    gameType: $Enums.GameType | null
    sharedSecret: string | null
    storageNodeId: string | null
    mountPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameClusterMaxAggregateOutputType = {
    id: string | null
    gameType: $Enums.GameType | null
    sharedSecret: string | null
    storageNodeId: string | null
    mountPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GameClusterCountAggregateOutputType = {
    id: number
    gameType: number
    sharedSecret: number
    storageNodeId: number
    mountPath: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GameClusterMinAggregateInputType = {
    id?: true
    gameType?: true
    sharedSecret?: true
    storageNodeId?: true
    mountPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameClusterMaxAggregateInputType = {
    id?: true
    gameType?: true
    sharedSecret?: true
    storageNodeId?: true
    mountPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GameClusterCountAggregateInputType = {
    id?: true
    gameType?: true
    sharedSecret?: true
    storageNodeId?: true
    mountPath?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GameClusterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameCluster to aggregate.
     */
    where?: GameClusterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameClusters to fetch.
     */
    orderBy?: GameClusterOrderByWithRelationInput | GameClusterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameClusterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameClusters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameClusters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameClusters
    **/
    _count?: true | GameClusterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameClusterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameClusterMaxAggregateInputType
  }

  export type GetGameClusterAggregateType<T extends GameClusterAggregateArgs> = {
        [P in keyof T & keyof AggregateGameCluster]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameCluster[P]>
      : GetScalarType<T[P], AggregateGameCluster[P]>
  }




  export type GameClusterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameClusterWhereInput
    orderBy?: GameClusterOrderByWithAggregationInput | GameClusterOrderByWithAggregationInput[]
    by: GameClusterScalarFieldEnum[] | GameClusterScalarFieldEnum
    having?: GameClusterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameClusterCountAggregateInputType | true
    _min?: GameClusterMinAggregateInputType
    _max?: GameClusterMaxAggregateInputType
  }

  export type GameClusterGroupByOutputType = {
    id: string
    gameType: $Enums.GameType
    sharedSecret: string
    storageNodeId: string
    mountPath: string
    createdAt: Date
    updatedAt: Date
    _count: GameClusterCountAggregateOutputType | null
    _min: GameClusterMinAggregateOutputType | null
    _max: GameClusterMaxAggregateOutputType | null
  }

  type GetGameClusterGroupByPayload<T extends GameClusterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameClusterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameClusterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameClusterGroupByOutputType[P]>
            : GetScalarType<T[P], GameClusterGroupByOutputType[P]>
        }
      >
    >


  export type GameClusterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameType?: boolean
    sharedSecret?: boolean
    storageNodeId?: boolean
    mountPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    storageNode?: boolean | NodeDefaultArgs<ExtArgs>
    servers?: boolean | GameCluster$serversArgs<ExtArgs>
    _count?: boolean | GameClusterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameCluster"]>


  export type GameClusterSelectScalar = {
    id?: boolean
    gameType?: boolean
    sharedSecret?: boolean
    storageNodeId?: boolean
    mountPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GameClusterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storageNode?: boolean | NodeDefaultArgs<ExtArgs>
    servers?: boolean | GameCluster$serversArgs<ExtArgs>
    _count?: boolean | GameClusterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $GameClusterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameCluster"
    objects: {
      storageNode: Prisma.$NodePayload<ExtArgs>
      servers: Prisma.$GameServerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      gameType: $Enums.GameType
      sharedSecret: string
      storageNodeId: string
      mountPath: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gameCluster"]>
    composites: {}
  }

  type GameClusterGetPayload<S extends boolean | null | undefined | GameClusterDefaultArgs> = $Result.GetResult<Prisma.$GameClusterPayload, S>

  type GameClusterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GameClusterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GameClusterCountAggregateInputType | true
    }

  export interface GameClusterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameCluster'], meta: { name: 'GameCluster' } }
    /**
     * Find zero or one GameCluster that matches the filter.
     * @param {GameClusterFindUniqueArgs} args - Arguments to find a GameCluster
     * @example
     * // Get one GameCluster
     * const gameCluster = await prisma.gameCluster.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameClusterFindUniqueArgs>(args: SelectSubset<T, GameClusterFindUniqueArgs<ExtArgs>>): Prisma__GameClusterClient<$Result.GetResult<Prisma.$GameClusterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GameCluster that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GameClusterFindUniqueOrThrowArgs} args - Arguments to find a GameCluster
     * @example
     * // Get one GameCluster
     * const gameCluster = await prisma.gameCluster.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameClusterFindUniqueOrThrowArgs>(args: SelectSubset<T, GameClusterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClusterClient<$Result.GetResult<Prisma.$GameClusterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GameCluster that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClusterFindFirstArgs} args - Arguments to find a GameCluster
     * @example
     * // Get one GameCluster
     * const gameCluster = await prisma.gameCluster.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameClusterFindFirstArgs>(args?: SelectSubset<T, GameClusterFindFirstArgs<ExtArgs>>): Prisma__GameClusterClient<$Result.GetResult<Prisma.$GameClusterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GameCluster that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClusterFindFirstOrThrowArgs} args - Arguments to find a GameCluster
     * @example
     * // Get one GameCluster
     * const gameCluster = await prisma.gameCluster.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameClusterFindFirstOrThrowArgs>(args?: SelectSubset<T, GameClusterFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClusterClient<$Result.GetResult<Prisma.$GameClusterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GameClusters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClusterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameClusters
     * const gameClusters = await prisma.gameCluster.findMany()
     * 
     * // Get first 10 GameClusters
     * const gameClusters = await prisma.gameCluster.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameClusterWithIdOnly = await prisma.gameCluster.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameClusterFindManyArgs>(args?: SelectSubset<T, GameClusterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameClusterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GameCluster.
     * @param {GameClusterCreateArgs} args - Arguments to create a GameCluster.
     * @example
     * // Create one GameCluster
     * const GameCluster = await prisma.gameCluster.create({
     *   data: {
     *     // ... data to create a GameCluster
     *   }
     * })
     * 
     */
    create<T extends GameClusterCreateArgs>(args: SelectSubset<T, GameClusterCreateArgs<ExtArgs>>): Prisma__GameClusterClient<$Result.GetResult<Prisma.$GameClusterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GameClusters.
     * @param {GameClusterCreateManyArgs} args - Arguments to create many GameClusters.
     * @example
     * // Create many GameClusters
     * const gameCluster = await prisma.gameCluster.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameClusterCreateManyArgs>(args?: SelectSubset<T, GameClusterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GameCluster.
     * @param {GameClusterDeleteArgs} args - Arguments to delete one GameCluster.
     * @example
     * // Delete one GameCluster
     * const GameCluster = await prisma.gameCluster.delete({
     *   where: {
     *     // ... filter to delete one GameCluster
     *   }
     * })
     * 
     */
    delete<T extends GameClusterDeleteArgs>(args: SelectSubset<T, GameClusterDeleteArgs<ExtArgs>>): Prisma__GameClusterClient<$Result.GetResult<Prisma.$GameClusterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GameCluster.
     * @param {GameClusterUpdateArgs} args - Arguments to update one GameCluster.
     * @example
     * // Update one GameCluster
     * const gameCluster = await prisma.gameCluster.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameClusterUpdateArgs>(args: SelectSubset<T, GameClusterUpdateArgs<ExtArgs>>): Prisma__GameClusterClient<$Result.GetResult<Prisma.$GameClusterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GameClusters.
     * @param {GameClusterDeleteManyArgs} args - Arguments to filter GameClusters to delete.
     * @example
     * // Delete a few GameClusters
     * const { count } = await prisma.gameCluster.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameClusterDeleteManyArgs>(args?: SelectSubset<T, GameClusterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameClusters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClusterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameClusters
     * const gameCluster = await prisma.gameCluster.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameClusterUpdateManyArgs>(args: SelectSubset<T, GameClusterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GameCluster.
     * @param {GameClusterUpsertArgs} args - Arguments to update or create a GameCluster.
     * @example
     * // Update or create a GameCluster
     * const gameCluster = await prisma.gameCluster.upsert({
     *   create: {
     *     // ... data to create a GameCluster
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameCluster we want to update
     *   }
     * })
     */
    upsert<T extends GameClusterUpsertArgs>(args: SelectSubset<T, GameClusterUpsertArgs<ExtArgs>>): Prisma__GameClusterClient<$Result.GetResult<Prisma.$GameClusterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GameClusters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClusterCountArgs} args - Arguments to filter GameClusters to count.
     * @example
     * // Count the number of GameClusters
     * const count = await prisma.gameCluster.count({
     *   where: {
     *     // ... the filter for the GameClusters we want to count
     *   }
     * })
    **/
    count<T extends GameClusterCountArgs>(
      args?: Subset<T, GameClusterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameClusterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameCluster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClusterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameClusterAggregateArgs>(args: Subset<T, GameClusterAggregateArgs>): Prisma.PrismaPromise<GetGameClusterAggregateType<T>>

    /**
     * Group by GameCluster.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameClusterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameClusterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameClusterGroupByArgs['orderBy'] }
        : { orderBy?: GameClusterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameClusterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameClusterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameCluster model
   */
  readonly fields: GameClusterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameCluster.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClusterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    storageNode<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    servers<T extends GameCluster$serversArgs<ExtArgs> = {}>(args?: Subset<T, GameCluster$serversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameCluster model
   */ 
  interface GameClusterFieldRefs {
    readonly id: FieldRef<"GameCluster", 'String'>
    readonly gameType: FieldRef<"GameCluster", 'GameType'>
    readonly sharedSecret: FieldRef<"GameCluster", 'String'>
    readonly storageNodeId: FieldRef<"GameCluster", 'String'>
    readonly mountPath: FieldRef<"GameCluster", 'String'>
    readonly createdAt: FieldRef<"GameCluster", 'DateTime'>
    readonly updatedAt: FieldRef<"GameCluster", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GameCluster findUnique
   */
  export type GameClusterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCluster
     */
    select?: GameClusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameClusterInclude<ExtArgs> | null
    /**
     * Filter, which GameCluster to fetch.
     */
    where: GameClusterWhereUniqueInput
  }

  /**
   * GameCluster findUniqueOrThrow
   */
  export type GameClusterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCluster
     */
    select?: GameClusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameClusterInclude<ExtArgs> | null
    /**
     * Filter, which GameCluster to fetch.
     */
    where: GameClusterWhereUniqueInput
  }

  /**
   * GameCluster findFirst
   */
  export type GameClusterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCluster
     */
    select?: GameClusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameClusterInclude<ExtArgs> | null
    /**
     * Filter, which GameCluster to fetch.
     */
    where?: GameClusterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameClusters to fetch.
     */
    orderBy?: GameClusterOrderByWithRelationInput | GameClusterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameClusters.
     */
    cursor?: GameClusterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameClusters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameClusters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameClusters.
     */
    distinct?: GameClusterScalarFieldEnum | GameClusterScalarFieldEnum[]
  }

  /**
   * GameCluster findFirstOrThrow
   */
  export type GameClusterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCluster
     */
    select?: GameClusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameClusterInclude<ExtArgs> | null
    /**
     * Filter, which GameCluster to fetch.
     */
    where?: GameClusterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameClusters to fetch.
     */
    orderBy?: GameClusterOrderByWithRelationInput | GameClusterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameClusters.
     */
    cursor?: GameClusterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameClusters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameClusters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameClusters.
     */
    distinct?: GameClusterScalarFieldEnum | GameClusterScalarFieldEnum[]
  }

  /**
   * GameCluster findMany
   */
  export type GameClusterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCluster
     */
    select?: GameClusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameClusterInclude<ExtArgs> | null
    /**
     * Filter, which GameClusters to fetch.
     */
    where?: GameClusterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameClusters to fetch.
     */
    orderBy?: GameClusterOrderByWithRelationInput | GameClusterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameClusters.
     */
    cursor?: GameClusterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameClusters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameClusters.
     */
    skip?: number
    distinct?: GameClusterScalarFieldEnum | GameClusterScalarFieldEnum[]
  }

  /**
   * GameCluster create
   */
  export type GameClusterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCluster
     */
    select?: GameClusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameClusterInclude<ExtArgs> | null
    /**
     * The data needed to create a GameCluster.
     */
    data: XOR<GameClusterCreateInput, GameClusterUncheckedCreateInput>
  }

  /**
   * GameCluster createMany
   */
  export type GameClusterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameClusters.
     */
    data: GameClusterCreateManyInput | GameClusterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameCluster update
   */
  export type GameClusterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCluster
     */
    select?: GameClusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameClusterInclude<ExtArgs> | null
    /**
     * The data needed to update a GameCluster.
     */
    data: XOR<GameClusterUpdateInput, GameClusterUncheckedUpdateInput>
    /**
     * Choose, which GameCluster to update.
     */
    where: GameClusterWhereUniqueInput
  }

  /**
   * GameCluster updateMany
   */
  export type GameClusterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameClusters.
     */
    data: XOR<GameClusterUpdateManyMutationInput, GameClusterUncheckedUpdateManyInput>
    /**
     * Filter which GameClusters to update
     */
    where?: GameClusterWhereInput
  }

  /**
   * GameCluster upsert
   */
  export type GameClusterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCluster
     */
    select?: GameClusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameClusterInclude<ExtArgs> | null
    /**
     * The filter to search for the GameCluster to update in case it exists.
     */
    where: GameClusterWhereUniqueInput
    /**
     * In case the GameCluster found by the `where` argument doesn't exist, create a new GameCluster with this data.
     */
    create: XOR<GameClusterCreateInput, GameClusterUncheckedCreateInput>
    /**
     * In case the GameCluster was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameClusterUpdateInput, GameClusterUncheckedUpdateInput>
  }

  /**
   * GameCluster delete
   */
  export type GameClusterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCluster
     */
    select?: GameClusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameClusterInclude<ExtArgs> | null
    /**
     * Filter which GameCluster to delete.
     */
    where: GameClusterWhereUniqueInput
  }

  /**
   * GameCluster deleteMany
   */
  export type GameClusterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameClusters to delete
     */
    where?: GameClusterWhereInput
  }

  /**
   * GameCluster.servers
   */
  export type GameCluster$serversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    where?: GameServerWhereInput
    orderBy?: GameServerOrderByWithRelationInput | GameServerOrderByWithRelationInput[]
    cursor?: GameServerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameServerScalarFieldEnum | GameServerScalarFieldEnum[]
  }

  /**
   * GameCluster without action
   */
  export type GameClusterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCluster
     */
    select?: GameClusterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameClusterInclude<ExtArgs> | null
  }


  /**
   * Model Backup
   */

  export type AggregateBackup = {
    _count: BackupCountAggregateOutputType | null
    _avg: BackupAvgAggregateOutputType | null
    _sum: BackupSumAggregateOutputType | null
    _min: BackupMinAggregateOutputType | null
    _max: BackupMaxAggregateOutputType | null
  }

  export type BackupAvgAggregateOutputType = {
    sizeBytes: number | null
  }

  export type BackupSumAggregateOutputType = {
    sizeBytes: bigint | null
  }

  export type BackupMinAggregateOutputType = {
    id: string | null
    serverUuid: string | null
    snapshotId: string | null
    sizeBytes: bigint | null
    location: $Enums.BackupLocation | null
    lastRestoredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BackupMaxAggregateOutputType = {
    id: string | null
    serverUuid: string | null
    snapshotId: string | null
    sizeBytes: bigint | null
    location: $Enums.BackupLocation | null
    lastRestoredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BackupCountAggregateOutputType = {
    id: number
    serverUuid: number
    snapshotId: number
    sizeBytes: number
    location: number
    lastRestoredAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BackupAvgAggregateInputType = {
    sizeBytes?: true
  }

  export type BackupSumAggregateInputType = {
    sizeBytes?: true
  }

  export type BackupMinAggregateInputType = {
    id?: true
    serverUuid?: true
    snapshotId?: true
    sizeBytes?: true
    location?: true
    lastRestoredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BackupMaxAggregateInputType = {
    id?: true
    serverUuid?: true
    snapshotId?: true
    sizeBytes?: true
    location?: true
    lastRestoredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BackupCountAggregateInputType = {
    id?: true
    serverUuid?: true
    snapshotId?: true
    sizeBytes?: true
    location?: true
    lastRestoredAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BackupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Backup to aggregate.
     */
    where?: BackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backups to fetch.
     */
    orderBy?: BackupOrderByWithRelationInput | BackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Backups
    **/
    _count?: true | BackupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BackupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BackupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BackupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BackupMaxAggregateInputType
  }

  export type GetBackupAggregateType<T extends BackupAggregateArgs> = {
        [P in keyof T & keyof AggregateBackup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBackup[P]>
      : GetScalarType<T[P], AggregateBackup[P]>
  }




  export type BackupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BackupWhereInput
    orderBy?: BackupOrderByWithAggregationInput | BackupOrderByWithAggregationInput[]
    by: BackupScalarFieldEnum[] | BackupScalarFieldEnum
    having?: BackupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BackupCountAggregateInputType | true
    _avg?: BackupAvgAggregateInputType
    _sum?: BackupSumAggregateInputType
    _min?: BackupMinAggregateInputType
    _max?: BackupMaxAggregateInputType
  }

  export type BackupGroupByOutputType = {
    id: string
    serverUuid: string
    snapshotId: string
    sizeBytes: bigint
    location: $Enums.BackupLocation
    lastRestoredAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: BackupCountAggregateOutputType | null
    _avg: BackupAvgAggregateOutputType | null
    _sum: BackupSumAggregateOutputType | null
    _min: BackupMinAggregateOutputType | null
    _max: BackupMaxAggregateOutputType | null
  }

  type GetBackupGroupByPayload<T extends BackupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BackupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BackupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BackupGroupByOutputType[P]>
            : GetScalarType<T[P], BackupGroupByOutputType[P]>
        }
      >
    >


  export type BackupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serverUuid?: boolean
    snapshotId?: boolean
    sizeBytes?: boolean
    location?: boolean
    lastRestoredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    server?: boolean | GameServerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["backup"]>


  export type BackupSelectScalar = {
    id?: boolean
    serverUuid?: boolean
    snapshotId?: boolean
    sizeBytes?: boolean
    location?: boolean
    lastRestoredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BackupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    server?: boolean | GameServerDefaultArgs<ExtArgs>
  }

  export type $BackupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Backup"
    objects: {
      server: Prisma.$GameServerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serverUuid: string
      snapshotId: string
      sizeBytes: bigint
      location: $Enums.BackupLocation
      lastRestoredAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["backup"]>
    composites: {}
  }

  type BackupGetPayload<S extends boolean | null | undefined | BackupDefaultArgs> = $Result.GetResult<Prisma.$BackupPayload, S>

  type BackupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BackupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BackupCountAggregateInputType | true
    }

  export interface BackupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Backup'], meta: { name: 'Backup' } }
    /**
     * Find zero or one Backup that matches the filter.
     * @param {BackupFindUniqueArgs} args - Arguments to find a Backup
     * @example
     * // Get one Backup
     * const backup = await prisma.backup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BackupFindUniqueArgs>(args: SelectSubset<T, BackupFindUniqueArgs<ExtArgs>>): Prisma__BackupClient<$Result.GetResult<Prisma.$BackupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Backup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BackupFindUniqueOrThrowArgs} args - Arguments to find a Backup
     * @example
     * // Get one Backup
     * const backup = await prisma.backup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BackupFindUniqueOrThrowArgs>(args: SelectSubset<T, BackupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BackupClient<$Result.GetResult<Prisma.$BackupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Backup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupFindFirstArgs} args - Arguments to find a Backup
     * @example
     * // Get one Backup
     * const backup = await prisma.backup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BackupFindFirstArgs>(args?: SelectSubset<T, BackupFindFirstArgs<ExtArgs>>): Prisma__BackupClient<$Result.GetResult<Prisma.$BackupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Backup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupFindFirstOrThrowArgs} args - Arguments to find a Backup
     * @example
     * // Get one Backup
     * const backup = await prisma.backup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BackupFindFirstOrThrowArgs>(args?: SelectSubset<T, BackupFindFirstOrThrowArgs<ExtArgs>>): Prisma__BackupClient<$Result.GetResult<Prisma.$BackupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Backups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Backups
     * const backups = await prisma.backup.findMany()
     * 
     * // Get first 10 Backups
     * const backups = await prisma.backup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const backupWithIdOnly = await prisma.backup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BackupFindManyArgs>(args?: SelectSubset<T, BackupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BackupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Backup.
     * @param {BackupCreateArgs} args - Arguments to create a Backup.
     * @example
     * // Create one Backup
     * const Backup = await prisma.backup.create({
     *   data: {
     *     // ... data to create a Backup
     *   }
     * })
     * 
     */
    create<T extends BackupCreateArgs>(args: SelectSubset<T, BackupCreateArgs<ExtArgs>>): Prisma__BackupClient<$Result.GetResult<Prisma.$BackupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Backups.
     * @param {BackupCreateManyArgs} args - Arguments to create many Backups.
     * @example
     * // Create many Backups
     * const backup = await prisma.backup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BackupCreateManyArgs>(args?: SelectSubset<T, BackupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Backup.
     * @param {BackupDeleteArgs} args - Arguments to delete one Backup.
     * @example
     * // Delete one Backup
     * const Backup = await prisma.backup.delete({
     *   where: {
     *     // ... filter to delete one Backup
     *   }
     * })
     * 
     */
    delete<T extends BackupDeleteArgs>(args: SelectSubset<T, BackupDeleteArgs<ExtArgs>>): Prisma__BackupClient<$Result.GetResult<Prisma.$BackupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Backup.
     * @param {BackupUpdateArgs} args - Arguments to update one Backup.
     * @example
     * // Update one Backup
     * const backup = await prisma.backup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BackupUpdateArgs>(args: SelectSubset<T, BackupUpdateArgs<ExtArgs>>): Prisma__BackupClient<$Result.GetResult<Prisma.$BackupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Backups.
     * @param {BackupDeleteManyArgs} args - Arguments to filter Backups to delete.
     * @example
     * // Delete a few Backups
     * const { count } = await prisma.backup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BackupDeleteManyArgs>(args?: SelectSubset<T, BackupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Backups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Backups
     * const backup = await prisma.backup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BackupUpdateManyArgs>(args: SelectSubset<T, BackupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Backup.
     * @param {BackupUpsertArgs} args - Arguments to update or create a Backup.
     * @example
     * // Update or create a Backup
     * const backup = await prisma.backup.upsert({
     *   create: {
     *     // ... data to create a Backup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Backup we want to update
     *   }
     * })
     */
    upsert<T extends BackupUpsertArgs>(args: SelectSubset<T, BackupUpsertArgs<ExtArgs>>): Prisma__BackupClient<$Result.GetResult<Prisma.$BackupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Backups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupCountArgs} args - Arguments to filter Backups to count.
     * @example
     * // Count the number of Backups
     * const count = await prisma.backup.count({
     *   where: {
     *     // ... the filter for the Backups we want to count
     *   }
     * })
    **/
    count<T extends BackupCountArgs>(
      args?: Subset<T, BackupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BackupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Backup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BackupAggregateArgs>(args: Subset<T, BackupAggregateArgs>): Prisma.PrismaPromise<GetBackupAggregateType<T>>

    /**
     * Group by Backup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BackupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BackupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BackupGroupByArgs['orderBy'] }
        : { orderBy?: BackupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BackupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBackupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Backup model
   */
  readonly fields: BackupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Backup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BackupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    server<T extends GameServerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameServerDefaultArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Backup model
   */ 
  interface BackupFieldRefs {
    readonly id: FieldRef<"Backup", 'String'>
    readonly serverUuid: FieldRef<"Backup", 'String'>
    readonly snapshotId: FieldRef<"Backup", 'String'>
    readonly sizeBytes: FieldRef<"Backup", 'BigInt'>
    readonly location: FieldRef<"Backup", 'BackupLocation'>
    readonly lastRestoredAt: FieldRef<"Backup", 'DateTime'>
    readonly createdAt: FieldRef<"Backup", 'DateTime'>
    readonly updatedAt: FieldRef<"Backup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Backup findUnique
   */
  export type BackupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backup
     */
    select?: BackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupInclude<ExtArgs> | null
    /**
     * Filter, which Backup to fetch.
     */
    where: BackupWhereUniqueInput
  }

  /**
   * Backup findUniqueOrThrow
   */
  export type BackupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backup
     */
    select?: BackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupInclude<ExtArgs> | null
    /**
     * Filter, which Backup to fetch.
     */
    where: BackupWhereUniqueInput
  }

  /**
   * Backup findFirst
   */
  export type BackupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backup
     */
    select?: BackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupInclude<ExtArgs> | null
    /**
     * Filter, which Backup to fetch.
     */
    where?: BackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backups to fetch.
     */
    orderBy?: BackupOrderByWithRelationInput | BackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backups.
     */
    cursor?: BackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backups.
     */
    distinct?: BackupScalarFieldEnum | BackupScalarFieldEnum[]
  }

  /**
   * Backup findFirstOrThrow
   */
  export type BackupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backup
     */
    select?: BackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupInclude<ExtArgs> | null
    /**
     * Filter, which Backup to fetch.
     */
    where?: BackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backups to fetch.
     */
    orderBy?: BackupOrderByWithRelationInput | BackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Backups.
     */
    cursor?: BackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Backups.
     */
    distinct?: BackupScalarFieldEnum | BackupScalarFieldEnum[]
  }

  /**
   * Backup findMany
   */
  export type BackupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backup
     */
    select?: BackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupInclude<ExtArgs> | null
    /**
     * Filter, which Backups to fetch.
     */
    where?: BackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Backups to fetch.
     */
    orderBy?: BackupOrderByWithRelationInput | BackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Backups.
     */
    cursor?: BackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Backups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Backups.
     */
    skip?: number
    distinct?: BackupScalarFieldEnum | BackupScalarFieldEnum[]
  }

  /**
   * Backup create
   */
  export type BackupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backup
     */
    select?: BackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupInclude<ExtArgs> | null
    /**
     * The data needed to create a Backup.
     */
    data: XOR<BackupCreateInput, BackupUncheckedCreateInput>
  }

  /**
   * Backup createMany
   */
  export type BackupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Backups.
     */
    data: BackupCreateManyInput | BackupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Backup update
   */
  export type BackupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backup
     */
    select?: BackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupInclude<ExtArgs> | null
    /**
     * The data needed to update a Backup.
     */
    data: XOR<BackupUpdateInput, BackupUncheckedUpdateInput>
    /**
     * Choose, which Backup to update.
     */
    where: BackupWhereUniqueInput
  }

  /**
   * Backup updateMany
   */
  export type BackupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Backups.
     */
    data: XOR<BackupUpdateManyMutationInput, BackupUncheckedUpdateManyInput>
    /**
     * Filter which Backups to update
     */
    where?: BackupWhereInput
  }

  /**
   * Backup upsert
   */
  export type BackupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backup
     */
    select?: BackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupInclude<ExtArgs> | null
    /**
     * The filter to search for the Backup to update in case it exists.
     */
    where: BackupWhereUniqueInput
    /**
     * In case the Backup found by the `where` argument doesn't exist, create a new Backup with this data.
     */
    create: XOR<BackupCreateInput, BackupUncheckedCreateInput>
    /**
     * In case the Backup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BackupUpdateInput, BackupUncheckedUpdateInput>
  }

  /**
   * Backup delete
   */
  export type BackupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backup
     */
    select?: BackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupInclude<ExtArgs> | null
    /**
     * Filter which Backup to delete.
     */
    where: BackupWhereUniqueInput
  }

  /**
   * Backup deleteMany
   */
  export type BackupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Backups to delete
     */
    where?: BackupWhereInput
  }

  /**
   * Backup without action
   */
  export type BackupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Backup
     */
    select?: BackupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BackupInclude<ExtArgs> | null
  }


  /**
   * Model Metric
   */

  export type AggregateMetric = {
    _count: MetricCountAggregateOutputType | null
    _avg: MetricAvgAggregateOutputType | null
    _sum: MetricSumAggregateOutputType | null
    _min: MetricMinAggregateOutputType | null
    _max: MetricMaxAggregateOutputType | null
  }

  export type MetricAvgAggregateOutputType = {
    cpuUsage: number | null
    ramUsage: number | null
    ramUsagePercent: number | null
    diskUsage: number | null
    diskUsagePercent: number | null
    networkIn: number | null
    networkOut: number | null
    uptime: number | null
  }

  export type MetricSumAggregateOutputType = {
    cpuUsage: number | null
    ramUsage: number | null
    ramUsagePercent: number | null
    diskUsage: number | null
    diskUsagePercent: number | null
    networkIn: bigint | null
    networkOut: bigint | null
    uptime: number | null
  }

  export type MetricMinAggregateOutputType = {
    id: string | null
    nodeId: string | null
    serverUuid: string | null
    timestamp: Date | null
    cpuUsage: number | null
    ramUsage: number | null
    ramUsagePercent: number | null
    diskUsage: number | null
    diskUsagePercent: number | null
    networkIn: bigint | null
    networkOut: bigint | null
    uptime: number | null
  }

  export type MetricMaxAggregateOutputType = {
    id: string | null
    nodeId: string | null
    serverUuid: string | null
    timestamp: Date | null
    cpuUsage: number | null
    ramUsage: number | null
    ramUsagePercent: number | null
    diskUsage: number | null
    diskUsagePercent: number | null
    networkIn: bigint | null
    networkOut: bigint | null
    uptime: number | null
  }

  export type MetricCountAggregateOutputType = {
    id: number
    nodeId: number
    serverUuid: number
    timestamp: number
    cpuUsage: number
    ramUsage: number
    ramUsagePercent: number
    diskUsage: number
    diskUsagePercent: number
    networkIn: number
    networkOut: number
    uptime: number
    _all: number
  }


  export type MetricAvgAggregateInputType = {
    cpuUsage?: true
    ramUsage?: true
    ramUsagePercent?: true
    diskUsage?: true
    diskUsagePercent?: true
    networkIn?: true
    networkOut?: true
    uptime?: true
  }

  export type MetricSumAggregateInputType = {
    cpuUsage?: true
    ramUsage?: true
    ramUsagePercent?: true
    diskUsage?: true
    diskUsagePercent?: true
    networkIn?: true
    networkOut?: true
    uptime?: true
  }

  export type MetricMinAggregateInputType = {
    id?: true
    nodeId?: true
    serverUuid?: true
    timestamp?: true
    cpuUsage?: true
    ramUsage?: true
    ramUsagePercent?: true
    diskUsage?: true
    diskUsagePercent?: true
    networkIn?: true
    networkOut?: true
    uptime?: true
  }

  export type MetricMaxAggregateInputType = {
    id?: true
    nodeId?: true
    serverUuid?: true
    timestamp?: true
    cpuUsage?: true
    ramUsage?: true
    ramUsagePercent?: true
    diskUsage?: true
    diskUsagePercent?: true
    networkIn?: true
    networkOut?: true
    uptime?: true
  }

  export type MetricCountAggregateInputType = {
    id?: true
    nodeId?: true
    serverUuid?: true
    timestamp?: true
    cpuUsage?: true
    ramUsage?: true
    ramUsagePercent?: true
    diskUsage?: true
    diskUsagePercent?: true
    networkIn?: true
    networkOut?: true
    uptime?: true
    _all?: true
  }

  export type MetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metric to aggregate.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Metrics
    **/
    _count?: true | MetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetricMaxAggregateInputType
  }

  export type GetMetricAggregateType<T extends MetricAggregateArgs> = {
        [P in keyof T & keyof AggregateMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetric[P]>
      : GetScalarType<T[P], AggregateMetric[P]>
  }




  export type MetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetricWhereInput
    orderBy?: MetricOrderByWithAggregationInput | MetricOrderByWithAggregationInput[]
    by: MetricScalarFieldEnum[] | MetricScalarFieldEnum
    having?: MetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetricCountAggregateInputType | true
    _avg?: MetricAvgAggregateInputType
    _sum?: MetricSumAggregateInputType
    _min?: MetricMinAggregateInputType
    _max?: MetricMaxAggregateInputType
  }

  export type MetricGroupByOutputType = {
    id: string
    nodeId: string
    serverUuid: string | null
    timestamp: Date
    cpuUsage: number
    ramUsage: number
    ramUsagePercent: number
    diskUsage: number
    diskUsagePercent: number
    networkIn: bigint
    networkOut: bigint
    uptime: number | null
    _count: MetricCountAggregateOutputType | null
    _avg: MetricAvgAggregateOutputType | null
    _sum: MetricSumAggregateOutputType | null
    _min: MetricMinAggregateOutputType | null
    _max: MetricMaxAggregateOutputType | null
  }

  type GetMetricGroupByPayload<T extends MetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetricGroupByOutputType[P]>
            : GetScalarType<T[P], MetricGroupByOutputType[P]>
        }
      >
    >


  export type MetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    serverUuid?: boolean
    timestamp?: boolean
    cpuUsage?: boolean
    ramUsage?: boolean
    ramUsagePercent?: boolean
    diskUsage?: boolean
    diskUsagePercent?: boolean
    networkIn?: boolean
    networkOut?: boolean
    uptime?: boolean
    node?: boolean | NodeDefaultArgs<ExtArgs>
    server?: boolean | Metric$serverArgs<ExtArgs>
  }, ExtArgs["result"]["metric"]>


  export type MetricSelectScalar = {
    id?: boolean
    nodeId?: boolean
    serverUuid?: boolean
    timestamp?: boolean
    cpuUsage?: boolean
    ramUsage?: boolean
    ramUsagePercent?: boolean
    diskUsage?: boolean
    diskUsagePercent?: boolean
    networkIn?: boolean
    networkOut?: boolean
    uptime?: boolean
  }

  export type MetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    node?: boolean | NodeDefaultArgs<ExtArgs>
    server?: boolean | Metric$serverArgs<ExtArgs>
  }

  export type $MetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Metric"
    objects: {
      node: Prisma.$NodePayload<ExtArgs>
      server: Prisma.$GameServerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nodeId: string
      serverUuid: string | null
      timestamp: Date
      cpuUsage: number
      ramUsage: number
      ramUsagePercent: number
      diskUsage: number
      diskUsagePercent: number
      networkIn: bigint
      networkOut: bigint
      uptime: number | null
    }, ExtArgs["result"]["metric"]>
    composites: {}
  }

  type MetricGetPayload<S extends boolean | null | undefined | MetricDefaultArgs> = $Result.GetResult<Prisma.$MetricPayload, S>

  type MetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MetricCountAggregateInputType | true
    }

  export interface MetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Metric'], meta: { name: 'Metric' } }
    /**
     * Find zero or one Metric that matches the filter.
     * @param {MetricFindUniqueArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetricFindUniqueArgs>(args: SelectSubset<T, MetricFindUniqueArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Metric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MetricFindUniqueOrThrowArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetricFindUniqueOrThrowArgs>(args: SelectSubset<T, MetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Metric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindFirstArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetricFindFirstArgs>(args?: SelectSubset<T, MetricFindFirstArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Metric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindFirstOrThrowArgs} args - Arguments to find a Metric
     * @example
     * // Get one Metric
     * const metric = await prisma.metric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetricFindFirstOrThrowArgs>(args?: SelectSubset<T, MetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Metrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Metrics
     * const metrics = await prisma.metric.findMany()
     * 
     * // Get first 10 Metrics
     * const metrics = await prisma.metric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metricWithIdOnly = await prisma.metric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MetricFindManyArgs>(args?: SelectSubset<T, MetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Metric.
     * @param {MetricCreateArgs} args - Arguments to create a Metric.
     * @example
     * // Create one Metric
     * const Metric = await prisma.metric.create({
     *   data: {
     *     // ... data to create a Metric
     *   }
     * })
     * 
     */
    create<T extends MetricCreateArgs>(args: SelectSubset<T, MetricCreateArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Metrics.
     * @param {MetricCreateManyArgs} args - Arguments to create many Metrics.
     * @example
     * // Create many Metrics
     * const metric = await prisma.metric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MetricCreateManyArgs>(args?: SelectSubset<T, MetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Metric.
     * @param {MetricDeleteArgs} args - Arguments to delete one Metric.
     * @example
     * // Delete one Metric
     * const Metric = await prisma.metric.delete({
     *   where: {
     *     // ... filter to delete one Metric
     *   }
     * })
     * 
     */
    delete<T extends MetricDeleteArgs>(args: SelectSubset<T, MetricDeleteArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Metric.
     * @param {MetricUpdateArgs} args - Arguments to update one Metric.
     * @example
     * // Update one Metric
     * const metric = await prisma.metric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MetricUpdateArgs>(args: SelectSubset<T, MetricUpdateArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Metrics.
     * @param {MetricDeleteManyArgs} args - Arguments to filter Metrics to delete.
     * @example
     * // Delete a few Metrics
     * const { count } = await prisma.metric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MetricDeleteManyArgs>(args?: SelectSubset<T, MetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Metrics
     * const metric = await prisma.metric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MetricUpdateManyArgs>(args: SelectSubset<T, MetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Metric.
     * @param {MetricUpsertArgs} args - Arguments to update or create a Metric.
     * @example
     * // Update or create a Metric
     * const metric = await prisma.metric.upsert({
     *   create: {
     *     // ... data to create a Metric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Metric we want to update
     *   }
     * })
     */
    upsert<T extends MetricUpsertArgs>(args: SelectSubset<T, MetricUpsertArgs<ExtArgs>>): Prisma__MetricClient<$Result.GetResult<Prisma.$MetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricCountArgs} args - Arguments to filter Metrics to count.
     * @example
     * // Count the number of Metrics
     * const count = await prisma.metric.count({
     *   where: {
     *     // ... the filter for the Metrics we want to count
     *   }
     * })
    **/
    count<T extends MetricCountArgs>(
      args?: Subset<T, MetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetricAggregateArgs>(args: Subset<T, MetricAggregateArgs>): Prisma.PrismaPromise<GetMetricAggregateType<T>>

    /**
     * Group by Metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetricGroupByArgs['orderBy'] }
        : { orderBy?: MetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Metric model
   */
  readonly fields: MetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Metric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    node<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    server<T extends Metric$serverArgs<ExtArgs> = {}>(args?: Subset<T, Metric$serverArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Metric model
   */ 
  interface MetricFieldRefs {
    readonly id: FieldRef<"Metric", 'String'>
    readonly nodeId: FieldRef<"Metric", 'String'>
    readonly serverUuid: FieldRef<"Metric", 'String'>
    readonly timestamp: FieldRef<"Metric", 'DateTime'>
    readonly cpuUsage: FieldRef<"Metric", 'Float'>
    readonly ramUsage: FieldRef<"Metric", 'Float'>
    readonly ramUsagePercent: FieldRef<"Metric", 'Float'>
    readonly diskUsage: FieldRef<"Metric", 'Float'>
    readonly diskUsagePercent: FieldRef<"Metric", 'Float'>
    readonly networkIn: FieldRef<"Metric", 'BigInt'>
    readonly networkOut: FieldRef<"Metric", 'BigInt'>
    readonly uptime: FieldRef<"Metric", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Metric findUnique
   */
  export type MetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric findUniqueOrThrow
   */
  export type MetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric findFirst
   */
  export type MetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metrics.
     */
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric findFirstOrThrow
   */
  export type MetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * Filter, which Metric to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Metrics.
     */
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric findMany
   */
  export type MetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * Filter, which Metrics to fetch.
     */
    where?: MetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Metrics to fetch.
     */
    orderBy?: MetricOrderByWithRelationInput | MetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Metrics.
     */
    cursor?: MetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Metrics.
     */
    skip?: number
    distinct?: MetricScalarFieldEnum | MetricScalarFieldEnum[]
  }

  /**
   * Metric create
   */
  export type MetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * The data needed to create a Metric.
     */
    data: XOR<MetricCreateInput, MetricUncheckedCreateInput>
  }

  /**
   * Metric createMany
   */
  export type MetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Metrics.
     */
    data: MetricCreateManyInput | MetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Metric update
   */
  export type MetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * The data needed to update a Metric.
     */
    data: XOR<MetricUpdateInput, MetricUncheckedUpdateInput>
    /**
     * Choose, which Metric to update.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric updateMany
   */
  export type MetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Metrics.
     */
    data: XOR<MetricUpdateManyMutationInput, MetricUncheckedUpdateManyInput>
    /**
     * Filter which Metrics to update
     */
    where?: MetricWhereInput
  }

  /**
   * Metric upsert
   */
  export type MetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * The filter to search for the Metric to update in case it exists.
     */
    where: MetricWhereUniqueInput
    /**
     * In case the Metric found by the `where` argument doesn't exist, create a new Metric with this data.
     */
    create: XOR<MetricCreateInput, MetricUncheckedCreateInput>
    /**
     * In case the Metric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetricUpdateInput, MetricUncheckedUpdateInput>
  }

  /**
   * Metric delete
   */
  export type MetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricInclude<ExtArgs> | null
    /**
     * Filter which Metric to delete.
     */
    where: MetricWhereUniqueInput
  }

  /**
   * Metric deleteMany
   */
  export type MetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Metrics to delete
     */
    where?: MetricWhereInput
  }

  /**
   * Metric.server
   */
  export type Metric$serverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    where?: GameServerWhereInput
  }

  /**
   * Metric without action
   */
  export type MetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Metric
     */
    select?: MetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetricInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    severity: $Enums.AlertSeverity | null
    type: string | null
    message: string | null
    resourceId: string | null
    resourceType: $Enums.ResourceType | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedById: string | null
    nodeId: string | null
    serverUuid: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    severity: $Enums.AlertSeverity | null
    type: string | null
    message: string | null
    resourceId: string | null
    resourceType: $Enums.ResourceType | null
    resolved: boolean | null
    resolvedAt: Date | null
    resolvedById: string | null
    nodeId: string | null
    serverUuid: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    severity: number
    type: number
    message: number
    resourceId: number
    resourceType: number
    resolved: number
    resolvedAt: number
    resolvedById: number
    metadata: number
    nodeId: number
    serverUuid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    severity?: true
    type?: true
    message?: true
    resourceId?: true
    resourceType?: true
    resolved?: true
    resolvedAt?: true
    resolvedById?: true
    nodeId?: true
    serverUuid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    severity?: true
    type?: true
    message?: true
    resourceId?: true
    resourceType?: true
    resolved?: true
    resolvedAt?: true
    resolvedById?: true
    nodeId?: true
    serverUuid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    severity?: true
    type?: true
    message?: true
    resourceId?: true
    resourceType?: true
    resolved?: true
    resolvedAt?: true
    resolvedById?: true
    metadata?: true
    nodeId?: true
    serverUuid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved: boolean
    resolvedAt: Date | null
    resolvedById: string | null
    metadata: JsonValue | null
    nodeId: string | null
    serverUuid: string | null
    createdAt: Date
    updatedAt: Date
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    severity?: boolean
    type?: boolean
    message?: boolean
    resourceId?: boolean
    resourceType?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedById?: boolean
    metadata?: boolean
    nodeId?: boolean
    serverUuid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedBy?: boolean | Alert$resolvedByArgs<ExtArgs>
    node?: boolean | Alert$nodeArgs<ExtArgs>
    server?: boolean | Alert$serverArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>


  export type AlertSelectScalar = {
    id?: boolean
    severity?: boolean
    type?: boolean
    message?: boolean
    resourceId?: boolean
    resourceType?: boolean
    resolved?: boolean
    resolvedAt?: boolean
    resolvedById?: boolean
    metadata?: boolean
    nodeId?: boolean
    serverUuid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resolvedBy?: boolean | Alert$resolvedByArgs<ExtArgs>
    node?: boolean | Alert$nodeArgs<ExtArgs>
    server?: boolean | Alert$serverArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      resolvedBy: Prisma.$UserPayload<ExtArgs> | null
      node: Prisma.$NodePayload<ExtArgs> | null
      server: Prisma.$GameServerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      severity: $Enums.AlertSeverity
      type: string
      message: string
      resourceId: string
      resourceType: $Enums.ResourceType
      resolved: boolean
      resolvedAt: Date | null
      resolvedById: string | null
      metadata: Prisma.JsonValue | null
      nodeId: string | null
      serverUuid: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resolvedBy<T extends Alert$resolvedByArgs<ExtArgs> = {}>(args?: Subset<T, Alert$resolvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    node<T extends Alert$nodeArgs<ExtArgs> = {}>(args?: Subset<T, Alert$nodeArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    server<T extends Alert$serverArgs<ExtArgs> = {}>(args?: Subset<T, Alert$serverArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */ 
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly severity: FieldRef<"Alert", 'AlertSeverity'>
    readonly type: FieldRef<"Alert", 'String'>
    readonly message: FieldRef<"Alert", 'String'>
    readonly resourceId: FieldRef<"Alert", 'String'>
    readonly resourceType: FieldRef<"Alert", 'ResourceType'>
    readonly resolved: FieldRef<"Alert", 'Boolean'>
    readonly resolvedAt: FieldRef<"Alert", 'DateTime'>
    readonly resolvedById: FieldRef<"Alert", 'String'>
    readonly metadata: FieldRef<"Alert", 'Json'>
    readonly nodeId: FieldRef<"Alert", 'String'>
    readonly serverUuid: FieldRef<"Alert", 'String'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
    readonly updatedAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
  }

  /**
   * Alert.resolvedBy
   */
  export type Alert$resolvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Alert.node
   */
  export type Alert$nodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    where?: NodeWhereInput
  }

  /**
   * Alert.server
   */
  export type Alert$serverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    where?: GameServerWhereInput
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model ResourceQuota
   */

  export type AggregateResourceQuota = {
    _count: ResourceQuotaCountAggregateOutputType | null
    _avg: ResourceQuotaAvgAggregateOutputType | null
    _sum: ResourceQuotaSumAggregateOutputType | null
    _min: ResourceQuotaMinAggregateOutputType | null
    _max: ResourceQuotaMaxAggregateOutputType | null
  }

  export type ResourceQuotaAvgAggregateOutputType = {
    maxServers: number | null
    maxRam: number | null
    maxDisk: number | null
    maxCpu: number | null
  }

  export type ResourceQuotaSumAggregateOutputType = {
    maxServers: number | null
    maxRam: number | null
    maxDisk: number | null
    maxCpu: number | null
  }

  export type ResourceQuotaMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    maxServers: number | null
    maxRam: number | null
    maxDisk: number | null
    maxCpu: number | null
    enforced: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceQuotaMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    maxServers: number | null
    maxRam: number | null
    maxDisk: number | null
    maxCpu: number | null
    enforced: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceQuotaCountAggregateOutputType = {
    id: number
    userId: number
    tenantId: number
    maxServers: number
    maxRam: number
    maxDisk: number
    maxCpu: number
    currentUsage: number
    enforced: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResourceQuotaAvgAggregateInputType = {
    maxServers?: true
    maxRam?: true
    maxDisk?: true
    maxCpu?: true
  }

  export type ResourceQuotaSumAggregateInputType = {
    maxServers?: true
    maxRam?: true
    maxDisk?: true
    maxCpu?: true
  }

  export type ResourceQuotaMinAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    maxServers?: true
    maxRam?: true
    maxDisk?: true
    maxCpu?: true
    enforced?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceQuotaMaxAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    maxServers?: true
    maxRam?: true
    maxDisk?: true
    maxCpu?: true
    enforced?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceQuotaCountAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    maxServers?: true
    maxRam?: true
    maxDisk?: true
    maxCpu?: true
    currentUsage?: true
    enforced?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResourceQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceQuota to aggregate.
     */
    where?: ResourceQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceQuotas to fetch.
     */
    orderBy?: ResourceQuotaOrderByWithRelationInput | ResourceQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResourceQuotas
    **/
    _count?: true | ResourceQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceQuotaMaxAggregateInputType
  }

  export type GetResourceQuotaAggregateType<T extends ResourceQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateResourceQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResourceQuota[P]>
      : GetScalarType<T[P], AggregateResourceQuota[P]>
  }




  export type ResourceQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceQuotaWhereInput
    orderBy?: ResourceQuotaOrderByWithAggregationInput | ResourceQuotaOrderByWithAggregationInput[]
    by: ResourceQuotaScalarFieldEnum[] | ResourceQuotaScalarFieldEnum
    having?: ResourceQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceQuotaCountAggregateInputType | true
    _avg?: ResourceQuotaAvgAggregateInputType
    _sum?: ResourceQuotaSumAggregateInputType
    _min?: ResourceQuotaMinAggregateInputType
    _max?: ResourceQuotaMaxAggregateInputType
  }

  export type ResourceQuotaGroupByOutputType = {
    id: string
    userId: string
    tenantId: string | null
    maxServers: number
    maxRam: number
    maxDisk: number
    maxCpu: number
    currentUsage: JsonValue
    enforced: boolean
    createdAt: Date
    updatedAt: Date
    _count: ResourceQuotaCountAggregateOutputType | null
    _avg: ResourceQuotaAvgAggregateOutputType | null
    _sum: ResourceQuotaSumAggregateOutputType | null
    _min: ResourceQuotaMinAggregateOutputType | null
    _max: ResourceQuotaMaxAggregateOutputType | null
  }

  type GetResourceQuotaGroupByPayload<T extends ResourceQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceQuotaGroupByOutputType[P]>
        }
      >
    >


  export type ResourceQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    maxServers?: boolean
    maxRam?: boolean
    maxDisk?: boolean
    maxCpu?: boolean
    currentUsage?: boolean
    enforced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | ResourceQuota$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["resourceQuota"]>


  export type ResourceQuotaSelectScalar = {
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    maxServers?: boolean
    maxRam?: boolean
    maxDisk?: boolean
    maxCpu?: boolean
    currentUsage?: boolean
    enforced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResourceQuotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | ResourceQuota$tenantArgs<ExtArgs>
  }

  export type $ResourceQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResourceQuota"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tenantId: string | null
      maxServers: number
      maxRam: number
      maxDisk: number
      maxCpu: number
      currentUsage: Prisma.JsonValue
      enforced: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resourceQuota"]>
    composites: {}
  }

  type ResourceQuotaGetPayload<S extends boolean | null | undefined | ResourceQuotaDefaultArgs> = $Result.GetResult<Prisma.$ResourceQuotaPayload, S>

  type ResourceQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResourceQuotaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResourceQuotaCountAggregateInputType | true
    }

  export interface ResourceQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResourceQuota'], meta: { name: 'ResourceQuota' } }
    /**
     * Find zero or one ResourceQuota that matches the filter.
     * @param {ResourceQuotaFindUniqueArgs} args - Arguments to find a ResourceQuota
     * @example
     * // Get one ResourceQuota
     * const resourceQuota = await prisma.resourceQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceQuotaFindUniqueArgs>(args: SelectSubset<T, ResourceQuotaFindUniqueArgs<ExtArgs>>): Prisma__ResourceQuotaClient<$Result.GetResult<Prisma.$ResourceQuotaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResourceQuota that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResourceQuotaFindUniqueOrThrowArgs} args - Arguments to find a ResourceQuota
     * @example
     * // Get one ResourceQuota
     * const resourceQuota = await prisma.resourceQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceQuotaClient<$Result.GetResult<Prisma.$ResourceQuotaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResourceQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceQuotaFindFirstArgs} args - Arguments to find a ResourceQuota
     * @example
     * // Get one ResourceQuota
     * const resourceQuota = await prisma.resourceQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceQuotaFindFirstArgs>(args?: SelectSubset<T, ResourceQuotaFindFirstArgs<ExtArgs>>): Prisma__ResourceQuotaClient<$Result.GetResult<Prisma.$ResourceQuotaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResourceQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceQuotaFindFirstOrThrowArgs} args - Arguments to find a ResourceQuota
     * @example
     * // Get one ResourceQuota
     * const resourceQuota = await prisma.resourceQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceQuotaClient<$Result.GetResult<Prisma.$ResourceQuotaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResourceQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResourceQuotas
     * const resourceQuotas = await prisma.resourceQuota.findMany()
     * 
     * // Get first 10 ResourceQuotas
     * const resourceQuotas = await prisma.resourceQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceQuotaWithIdOnly = await prisma.resourceQuota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceQuotaFindManyArgs>(args?: SelectSubset<T, ResourceQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceQuotaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResourceQuota.
     * @param {ResourceQuotaCreateArgs} args - Arguments to create a ResourceQuota.
     * @example
     * // Create one ResourceQuota
     * const ResourceQuota = await prisma.resourceQuota.create({
     *   data: {
     *     // ... data to create a ResourceQuota
     *   }
     * })
     * 
     */
    create<T extends ResourceQuotaCreateArgs>(args: SelectSubset<T, ResourceQuotaCreateArgs<ExtArgs>>): Prisma__ResourceQuotaClient<$Result.GetResult<Prisma.$ResourceQuotaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResourceQuotas.
     * @param {ResourceQuotaCreateManyArgs} args - Arguments to create many ResourceQuotas.
     * @example
     * // Create many ResourceQuotas
     * const resourceQuota = await prisma.resourceQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceQuotaCreateManyArgs>(args?: SelectSubset<T, ResourceQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ResourceQuota.
     * @param {ResourceQuotaDeleteArgs} args - Arguments to delete one ResourceQuota.
     * @example
     * // Delete one ResourceQuota
     * const ResourceQuota = await prisma.resourceQuota.delete({
     *   where: {
     *     // ... filter to delete one ResourceQuota
     *   }
     * })
     * 
     */
    delete<T extends ResourceQuotaDeleteArgs>(args: SelectSubset<T, ResourceQuotaDeleteArgs<ExtArgs>>): Prisma__ResourceQuotaClient<$Result.GetResult<Prisma.$ResourceQuotaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResourceQuota.
     * @param {ResourceQuotaUpdateArgs} args - Arguments to update one ResourceQuota.
     * @example
     * // Update one ResourceQuota
     * const resourceQuota = await prisma.resourceQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceQuotaUpdateArgs>(args: SelectSubset<T, ResourceQuotaUpdateArgs<ExtArgs>>): Prisma__ResourceQuotaClient<$Result.GetResult<Prisma.$ResourceQuotaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResourceQuotas.
     * @param {ResourceQuotaDeleteManyArgs} args - Arguments to filter ResourceQuotas to delete.
     * @example
     * // Delete a few ResourceQuotas
     * const { count } = await prisma.resourceQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceQuotaDeleteManyArgs>(args?: SelectSubset<T, ResourceQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResourceQuotas
     * const resourceQuota = await prisma.resourceQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceQuotaUpdateManyArgs>(args: SelectSubset<T, ResourceQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResourceQuota.
     * @param {ResourceQuotaUpsertArgs} args - Arguments to update or create a ResourceQuota.
     * @example
     * // Update or create a ResourceQuota
     * const resourceQuota = await prisma.resourceQuota.upsert({
     *   create: {
     *     // ... data to create a ResourceQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResourceQuota we want to update
     *   }
     * })
     */
    upsert<T extends ResourceQuotaUpsertArgs>(args: SelectSubset<T, ResourceQuotaUpsertArgs<ExtArgs>>): Prisma__ResourceQuotaClient<$Result.GetResult<Prisma.$ResourceQuotaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResourceQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceQuotaCountArgs} args - Arguments to filter ResourceQuotas to count.
     * @example
     * // Count the number of ResourceQuotas
     * const count = await prisma.resourceQuota.count({
     *   where: {
     *     // ... the filter for the ResourceQuotas we want to count
     *   }
     * })
    **/
    count<T extends ResourceQuotaCountArgs>(
      args?: Subset<T, ResourceQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResourceQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceQuotaAggregateArgs>(args: Subset<T, ResourceQuotaAggregateArgs>): Prisma.PrismaPromise<GetResourceQuotaAggregateType<T>>

    /**
     * Group by ResourceQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceQuotaGroupByArgs['orderBy'] }
        : { orderBy?: ResourceQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResourceQuota model
   */
  readonly fields: ResourceQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResourceQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tenant<T extends ResourceQuota$tenantArgs<ExtArgs> = {}>(args?: Subset<T, ResourceQuota$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResourceQuota model
   */ 
  interface ResourceQuotaFieldRefs {
    readonly id: FieldRef<"ResourceQuota", 'String'>
    readonly userId: FieldRef<"ResourceQuota", 'String'>
    readonly tenantId: FieldRef<"ResourceQuota", 'String'>
    readonly maxServers: FieldRef<"ResourceQuota", 'Int'>
    readonly maxRam: FieldRef<"ResourceQuota", 'Int'>
    readonly maxDisk: FieldRef<"ResourceQuota", 'Int'>
    readonly maxCpu: FieldRef<"ResourceQuota", 'Int'>
    readonly currentUsage: FieldRef<"ResourceQuota", 'Json'>
    readonly enforced: FieldRef<"ResourceQuota", 'Boolean'>
    readonly createdAt: FieldRef<"ResourceQuota", 'DateTime'>
    readonly updatedAt: FieldRef<"ResourceQuota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResourceQuota findUnique
   */
  export type ResourceQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceQuota
     */
    select?: ResourceQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceQuotaInclude<ExtArgs> | null
    /**
     * Filter, which ResourceQuota to fetch.
     */
    where: ResourceQuotaWhereUniqueInput
  }

  /**
   * ResourceQuota findUniqueOrThrow
   */
  export type ResourceQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceQuota
     */
    select?: ResourceQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceQuotaInclude<ExtArgs> | null
    /**
     * Filter, which ResourceQuota to fetch.
     */
    where: ResourceQuotaWhereUniqueInput
  }

  /**
   * ResourceQuota findFirst
   */
  export type ResourceQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceQuota
     */
    select?: ResourceQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceQuotaInclude<ExtArgs> | null
    /**
     * Filter, which ResourceQuota to fetch.
     */
    where?: ResourceQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceQuotas to fetch.
     */
    orderBy?: ResourceQuotaOrderByWithRelationInput | ResourceQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceQuotas.
     */
    cursor?: ResourceQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceQuotas.
     */
    distinct?: ResourceQuotaScalarFieldEnum | ResourceQuotaScalarFieldEnum[]
  }

  /**
   * ResourceQuota findFirstOrThrow
   */
  export type ResourceQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceQuota
     */
    select?: ResourceQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceQuotaInclude<ExtArgs> | null
    /**
     * Filter, which ResourceQuota to fetch.
     */
    where?: ResourceQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceQuotas to fetch.
     */
    orderBy?: ResourceQuotaOrderByWithRelationInput | ResourceQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceQuotas.
     */
    cursor?: ResourceQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceQuotas.
     */
    distinct?: ResourceQuotaScalarFieldEnum | ResourceQuotaScalarFieldEnum[]
  }

  /**
   * ResourceQuota findMany
   */
  export type ResourceQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceQuota
     */
    select?: ResourceQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceQuotaInclude<ExtArgs> | null
    /**
     * Filter, which ResourceQuotas to fetch.
     */
    where?: ResourceQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceQuotas to fetch.
     */
    orderBy?: ResourceQuotaOrderByWithRelationInput | ResourceQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResourceQuotas.
     */
    cursor?: ResourceQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceQuotas.
     */
    skip?: number
    distinct?: ResourceQuotaScalarFieldEnum | ResourceQuotaScalarFieldEnum[]
  }

  /**
   * ResourceQuota create
   */
  export type ResourceQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceQuota
     */
    select?: ResourceQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a ResourceQuota.
     */
    data: XOR<ResourceQuotaCreateInput, ResourceQuotaUncheckedCreateInput>
  }

  /**
   * ResourceQuota createMany
   */
  export type ResourceQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResourceQuotas.
     */
    data: ResourceQuotaCreateManyInput | ResourceQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResourceQuota update
   */
  export type ResourceQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceQuota
     */
    select?: ResourceQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a ResourceQuota.
     */
    data: XOR<ResourceQuotaUpdateInput, ResourceQuotaUncheckedUpdateInput>
    /**
     * Choose, which ResourceQuota to update.
     */
    where: ResourceQuotaWhereUniqueInput
  }

  /**
   * ResourceQuota updateMany
   */
  export type ResourceQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResourceQuotas.
     */
    data: XOR<ResourceQuotaUpdateManyMutationInput, ResourceQuotaUncheckedUpdateManyInput>
    /**
     * Filter which ResourceQuotas to update
     */
    where?: ResourceQuotaWhereInput
  }

  /**
   * ResourceQuota upsert
   */
  export type ResourceQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceQuota
     */
    select?: ResourceQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the ResourceQuota to update in case it exists.
     */
    where: ResourceQuotaWhereUniqueInput
    /**
     * In case the ResourceQuota found by the `where` argument doesn't exist, create a new ResourceQuota with this data.
     */
    create: XOR<ResourceQuotaCreateInput, ResourceQuotaUncheckedCreateInput>
    /**
     * In case the ResourceQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceQuotaUpdateInput, ResourceQuotaUncheckedUpdateInput>
  }

  /**
   * ResourceQuota delete
   */
  export type ResourceQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceQuota
     */
    select?: ResourceQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceQuotaInclude<ExtArgs> | null
    /**
     * Filter which ResourceQuota to delete.
     */
    where: ResourceQuotaWhereUniqueInput
  }

  /**
   * ResourceQuota deleteMany
   */
  export type ResourceQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceQuotas to delete
     */
    where?: ResourceQuotaWhereInput
  }

  /**
   * ResourceQuota.tenant
   */
  export type ResourceQuota$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * ResourceQuota without action
   */
  export type ResourceQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceQuota
     */
    select?: ResourceQuotaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceQuotaInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyAvgAggregateOutputType = {
    rateLimit: number | null
  }

  export type ApiKeySumAggregateOutputType = {
    rateLimit: number | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    keyHash: string | null
    name: string | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    rateLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    keyHash: string | null
    name: string | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    rateLimit: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    userId: number
    keyHash: number
    name: number
    lastUsedAt: number
    expiresAt: number
    permissions: number
    rateLimit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiKeyAvgAggregateInputType = {
    rateLimit?: true
  }

  export type ApiKeySumAggregateInputType = {
    rateLimit?: true
  }

  export type ApiKeyMinAggregateInputType = {
    id?: true
    userId?: true
    keyHash?: true
    name?: true
    lastUsedAt?: true
    expiresAt?: true
    rateLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    userId?: true
    keyHash?: true
    name?: true
    lastUsedAt?: true
    expiresAt?: true
    rateLimit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    userId?: true
    keyHash?: true
    name?: true
    lastUsedAt?: true
    expiresAt?: true
    permissions?: true
    rateLimit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _avg?: ApiKeyAvgAggregateInputType
    _sum?: ApiKeySumAggregateInputType
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    userId: string
    keyHash: string
    name: string
    lastUsedAt: Date | null
    expiresAt: Date | null
    permissions: JsonValue | null
    rateLimit: number
    createdAt: Date
    updatedAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    keyHash?: boolean
    name?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    permissions?: boolean
    rateLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>


  export type ApiKeySelectScalar = {
    id?: boolean
    userId?: boolean
    keyHash?: boolean
    name?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    permissions?: boolean
    rateLimit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      keyHash: string
      name: string
      lastUsedAt: Date | null
      expiresAt: Date | null
      permissions: Prisma.JsonValue | null
      rateLimit: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly userId: FieldRef<"ApiKey", 'String'>
    readonly keyHash: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
    readonly permissions: FieldRef<"ApiKey", 'Json'>
    readonly rateLimit: FieldRef<"ApiKey", 'Int'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model Incident
   */

  export type AggregateIncident = {
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  export type IncidentMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    severity: $Enums.IncidentSeverity | null
    status: $Enums.IncidentStatus | null
    assignedToId: string | null
    resolvedAt: Date | null
    rootCause: string | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    severity: $Enums.IncidentSeverity | null
    status: $Enums.IncidentStatus | null
    assignedToId: string | null
    resolvedAt: Date | null
    rootCause: string | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncidentCountAggregateOutputType = {
    id: number
    title: number
    description: number
    severity: number
    status: number
    assignedToId: number
    resolvedAt: number
    rootCause: number
    resolution: number
    affectedResources: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncidentMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    severity?: true
    status?: true
    assignedToId?: true
    resolvedAt?: true
    rootCause?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    severity?: true
    status?: true
    assignedToId?: true
    resolvedAt?: true
    rootCause?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncidentCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    severity?: true
    status?: true
    assignedToId?: true
    resolvedAt?: true
    rootCause?: true
    resolution?: true
    affectedResources?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncidentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incident to aggregate.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incidents
    **/
    _count?: true | IncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncidentMaxAggregateInputType
  }

  export type GetIncidentAggregateType<T extends IncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncident[P]>
      : GetScalarType<T[P], AggregateIncident[P]>
  }




  export type IncidentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncidentWhereInput
    orderBy?: IncidentOrderByWithAggregationInput | IncidentOrderByWithAggregationInput[]
    by: IncidentScalarFieldEnum[] | IncidentScalarFieldEnum
    having?: IncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncidentCountAggregateInputType | true
    _min?: IncidentMinAggregateInputType
    _max?: IncidentMaxAggregateInputType
  }

  export type IncidentGroupByOutputType = {
    id: string
    title: string
    description: string
    severity: $Enums.IncidentSeverity
    status: $Enums.IncidentStatus
    assignedToId: string | null
    resolvedAt: Date | null
    rootCause: string | null
    resolution: string | null
    affectedResources: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: IncidentCountAggregateOutputType | null
    _min: IncidentMinAggregateOutputType | null
    _max: IncidentMaxAggregateOutputType | null
  }

  type GetIncidentGroupByPayload<T extends IncidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncidentGroupByOutputType[P]>
            : GetScalarType<T[P], IncidentGroupByOutputType[P]>
        }
      >
    >


  export type IncidentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    status?: boolean
    assignedToId?: boolean
    resolvedAt?: boolean
    rootCause?: boolean
    resolution?: boolean
    affectedResources?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedTo?: boolean | Incident$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["incident"]>


  export type IncidentSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    severity?: boolean
    status?: boolean
    assignedToId?: boolean
    resolvedAt?: boolean
    rootCause?: boolean
    resolution?: boolean
    affectedResources?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncidentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | Incident$assignedToArgs<ExtArgs>
  }

  export type $IncidentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incident"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      severity: $Enums.IncidentSeverity
      status: $Enums.IncidentStatus
      assignedToId: string | null
      resolvedAt: Date | null
      rootCause: string | null
      resolution: string | null
      affectedResources: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["incident"]>
    composites: {}
  }

  type IncidentGetPayload<S extends boolean | null | undefined | IncidentDefaultArgs> = $Result.GetResult<Prisma.$IncidentPayload, S>

  type IncidentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncidentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncidentCountAggregateInputType | true
    }

  export interface IncidentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incident'], meta: { name: 'Incident' } }
    /**
     * Find zero or one Incident that matches the filter.
     * @param {IncidentFindUniqueArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncidentFindUniqueArgs>(args: SelectSubset<T, IncidentFindUniqueArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Incident that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncidentFindUniqueOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncidentFindUniqueOrThrowArgs>(args: SelectSubset<T, IncidentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Incident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncidentFindFirstArgs>(args?: SelectSubset<T, IncidentFindFirstArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Incident that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindFirstOrThrowArgs} args - Arguments to find a Incident
     * @example
     * // Get one Incident
     * const incident = await prisma.incident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncidentFindFirstOrThrowArgs>(args?: SelectSubset<T, IncidentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Incidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incidents
     * const incidents = await prisma.incident.findMany()
     * 
     * // Get first 10 Incidents
     * const incidents = await prisma.incident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incidentWithIdOnly = await prisma.incident.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncidentFindManyArgs>(args?: SelectSubset<T, IncidentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Incident.
     * @param {IncidentCreateArgs} args - Arguments to create a Incident.
     * @example
     * // Create one Incident
     * const Incident = await prisma.incident.create({
     *   data: {
     *     // ... data to create a Incident
     *   }
     * })
     * 
     */
    create<T extends IncidentCreateArgs>(args: SelectSubset<T, IncidentCreateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Incidents.
     * @param {IncidentCreateManyArgs} args - Arguments to create many Incidents.
     * @example
     * // Create many Incidents
     * const incident = await prisma.incident.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncidentCreateManyArgs>(args?: SelectSubset<T, IncidentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Incident.
     * @param {IncidentDeleteArgs} args - Arguments to delete one Incident.
     * @example
     * // Delete one Incident
     * const Incident = await prisma.incident.delete({
     *   where: {
     *     // ... filter to delete one Incident
     *   }
     * })
     * 
     */
    delete<T extends IncidentDeleteArgs>(args: SelectSubset<T, IncidentDeleteArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Incident.
     * @param {IncidentUpdateArgs} args - Arguments to update one Incident.
     * @example
     * // Update one Incident
     * const incident = await prisma.incident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncidentUpdateArgs>(args: SelectSubset<T, IncidentUpdateArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Incidents.
     * @param {IncidentDeleteManyArgs} args - Arguments to filter Incidents to delete.
     * @example
     * // Delete a few Incidents
     * const { count } = await prisma.incident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncidentDeleteManyArgs>(args?: SelectSubset<T, IncidentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incidents
     * const incident = await prisma.incident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncidentUpdateManyArgs>(args: SelectSubset<T, IncidentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incident.
     * @param {IncidentUpsertArgs} args - Arguments to update or create a Incident.
     * @example
     * // Update or create a Incident
     * const incident = await prisma.incident.upsert({
     *   create: {
     *     // ... data to create a Incident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incident we want to update
     *   }
     * })
     */
    upsert<T extends IncidentUpsertArgs>(args: SelectSubset<T, IncidentUpsertArgs<ExtArgs>>): Prisma__IncidentClient<$Result.GetResult<Prisma.$IncidentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Incidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentCountArgs} args - Arguments to filter Incidents to count.
     * @example
     * // Count the number of Incidents
     * const count = await prisma.incident.count({
     *   where: {
     *     // ... the filter for the Incidents we want to count
     *   }
     * })
    **/
    count<T extends IncidentCountArgs>(
      args?: Subset<T, IncidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncidentAggregateArgs>(args: Subset<T, IncidentAggregateArgs>): Prisma.PrismaPromise<GetIncidentAggregateType<T>>

    /**
     * Group by Incident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncidentGroupByArgs['orderBy'] }
        : { orderBy?: IncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incident model
   */
  readonly fields: IncidentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncidentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends Incident$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, Incident$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incident model
   */ 
  interface IncidentFieldRefs {
    readonly id: FieldRef<"Incident", 'String'>
    readonly title: FieldRef<"Incident", 'String'>
    readonly description: FieldRef<"Incident", 'String'>
    readonly severity: FieldRef<"Incident", 'IncidentSeverity'>
    readonly status: FieldRef<"Incident", 'IncidentStatus'>
    readonly assignedToId: FieldRef<"Incident", 'String'>
    readonly resolvedAt: FieldRef<"Incident", 'DateTime'>
    readonly rootCause: FieldRef<"Incident", 'String'>
    readonly resolution: FieldRef<"Incident", 'String'>
    readonly affectedResources: FieldRef<"Incident", 'Json'>
    readonly createdAt: FieldRef<"Incident", 'DateTime'>
    readonly updatedAt: FieldRef<"Incident", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Incident findUnique
   */
  export type IncidentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findUniqueOrThrow
   */
  export type IncidentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident findFirst
   */
  export type IncidentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findFirstOrThrow
   */
  export type IncidentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incident to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incidents.
     */
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident findMany
   */
  export type IncidentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter, which Incidents to fetch.
     */
    where?: IncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incidents to fetch.
     */
    orderBy?: IncidentOrderByWithRelationInput | IncidentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incidents.
     */
    cursor?: IncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incidents.
     */
    skip?: number
    distinct?: IncidentScalarFieldEnum | IncidentScalarFieldEnum[]
  }

  /**
   * Incident create
   */
  export type IncidentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to create a Incident.
     */
    data: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
  }

  /**
   * Incident createMany
   */
  export type IncidentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incidents.
     */
    data: IncidentCreateManyInput | IncidentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Incident update
   */
  export type IncidentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The data needed to update a Incident.
     */
    data: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
    /**
     * Choose, which Incident to update.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident updateMany
   */
  export type IncidentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incidents.
     */
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyInput>
    /**
     * Filter which Incidents to update
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident upsert
   */
  export type IncidentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * The filter to search for the Incident to update in case it exists.
     */
    where: IncidentWhereUniqueInput
    /**
     * In case the Incident found by the `where` argument doesn't exist, create a new Incident with this data.
     */
    create: XOR<IncidentCreateInput, IncidentUncheckedCreateInput>
    /**
     * In case the Incident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncidentUpdateInput, IncidentUncheckedUpdateInput>
  }

  /**
   * Incident delete
   */
  export type IncidentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
    /**
     * Filter which Incident to delete.
     */
    where: IncidentWhereUniqueInput
  }

  /**
   * Incident deleteMany
   */
  export type IncidentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incidents to delete
     */
    where?: IncidentWhereInput
  }

  /**
   * Incident.assignedTo
   */
  export type Incident$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Incident without action
   */
  export type IncidentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incident
     */
    select?: IncidentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncidentInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    ramMb: number | null
    cpuCores: number | null
    diskGb: number | null
    maxSlots: number | null
    monthlyPrice: number | null
    hourlyPrice: number | null
    setupFee: number | null
    sortOrder: number | null
  }

  export type PlanSumAggregateOutputType = {
    ramMb: number | null
    cpuCores: number | null
    diskGb: number | null
    maxSlots: number | null
    monthlyPrice: number | null
    hourlyPrice: number | null
    setupFee: number | null
    sortOrder: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    gameType: $Enums.GameType | null
    status: $Enums.PlanStatus | null
    ramMb: number | null
    cpuCores: number | null
    diskGb: number | null
    maxSlots: number | null
    monthlyPrice: number | null
    hourlyPrice: number | null
    setupFee: number | null
    description: string | null
    isPopular: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    gameType: $Enums.GameType | null
    status: $Enums.PlanStatus | null
    ramMb: number | null
    cpuCores: number | null
    diskGb: number | null
    maxSlots: number | null
    monthlyPrice: number | null
    hourlyPrice: number | null
    setupFee: number | null
    description: string | null
    isPopular: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    gameType: number
    status: number
    ramMb: number
    cpuCores: number
    diskGb: number
    maxSlots: number
    monthlyPrice: number
    hourlyPrice: number
    setupFee: number
    features: number
    description: number
    isPopular: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    ramMb?: true
    cpuCores?: true
    diskGb?: true
    maxSlots?: true
    monthlyPrice?: true
    hourlyPrice?: true
    setupFee?: true
    sortOrder?: true
  }

  export type PlanSumAggregateInputType = {
    ramMb?: true
    cpuCores?: true
    diskGb?: true
    maxSlots?: true
    monthlyPrice?: true
    hourlyPrice?: true
    setupFee?: true
    sortOrder?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    gameType?: true
    status?: true
    ramMb?: true
    cpuCores?: true
    diskGb?: true
    maxSlots?: true
    monthlyPrice?: true
    hourlyPrice?: true
    setupFee?: true
    description?: true
    isPopular?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    gameType?: true
    status?: true
    ramMb?: true
    cpuCores?: true
    diskGb?: true
    maxSlots?: true
    monthlyPrice?: true
    hourlyPrice?: true
    setupFee?: true
    description?: true
    isPopular?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    gameType?: true
    status?: true
    ramMb?: true
    cpuCores?: true
    diskGb?: true
    maxSlots?: true
    monthlyPrice?: true
    hourlyPrice?: true
    setupFee?: true
    features?: true
    description?: true
    isPopular?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    slug: string
    gameType: $Enums.GameType
    status: $Enums.PlanStatus
    ramMb: number
    cpuCores: number
    diskGb: number
    maxSlots: number | null
    monthlyPrice: number
    hourlyPrice: number | null
    setupFee: number
    features: JsonValue | null
    description: string | null
    isPopular: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    gameType?: boolean
    status?: boolean
    ramMb?: boolean
    cpuCores?: boolean
    diskGb?: boolean
    maxSlots?: boolean
    monthlyPrice?: boolean
    hourlyPrice?: boolean
    setupFee?: boolean
    features?: boolean
    description?: boolean
    isPopular?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    servers?: boolean | Plan$serversArgs<ExtArgs>
    orders?: boolean | Plan$ordersArgs<ExtArgs>
    promotions?: boolean | Plan$promotionsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>


  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    gameType?: boolean
    status?: boolean
    ramMb?: boolean
    cpuCores?: boolean
    diskGb?: boolean
    maxSlots?: boolean
    monthlyPrice?: boolean
    hourlyPrice?: boolean
    setupFee?: boolean
    features?: boolean
    description?: boolean
    isPopular?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servers?: boolean | Plan$serversArgs<ExtArgs>
    orders?: boolean | Plan$ordersArgs<ExtArgs>
    promotions?: boolean | Plan$promotionsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      servers: Prisma.$GameServerPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      promotions: Prisma.$PromotionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      gameType: $Enums.GameType
      status: $Enums.PlanStatus
      ramMb: number
      cpuCores: number
      diskGb: number
      maxSlots: number | null
      monthlyPrice: number
      hourlyPrice: number | null
      setupFee: number
      features: Prisma.JsonValue | null
      description: string | null
      isPopular: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servers<T extends Plan$serversArgs<ExtArgs> = {}>(args?: Subset<T, Plan$serversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Plan$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Plan$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    promotions<T extends Plan$promotionsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$promotionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */ 
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly slug: FieldRef<"Plan", 'String'>
    readonly gameType: FieldRef<"Plan", 'GameType'>
    readonly status: FieldRef<"Plan", 'PlanStatus'>
    readonly ramMb: FieldRef<"Plan", 'Int'>
    readonly cpuCores: FieldRef<"Plan", 'Int'>
    readonly diskGb: FieldRef<"Plan", 'Int'>
    readonly maxSlots: FieldRef<"Plan", 'Int'>
    readonly monthlyPrice: FieldRef<"Plan", 'Int'>
    readonly hourlyPrice: FieldRef<"Plan", 'Int'>
    readonly setupFee: FieldRef<"Plan", 'Int'>
    readonly features: FieldRef<"Plan", 'Json'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly isPopular: FieldRef<"Plan", 'Boolean'>
    readonly sortOrder: FieldRef<"Plan", 'Int'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
  }

  /**
   * Plan.servers
   */
  export type Plan$serversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    where?: GameServerWhereInput
    orderBy?: GameServerOrderByWithRelationInput | GameServerOrderByWithRelationInput[]
    cursor?: GameServerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameServerScalarFieldEnum | GameServerScalarFieldEnum[]
  }

  /**
   * Plan.orders
   */
  export type Plan$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Plan.promotions
   */
  export type Plan$promotionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    cursor?: PromotionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    discountPercent: number | null
  }

  export type PromotionSumAggregateOutputType = {
    discountPercent: number | null
  }

  export type PromotionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    scope: $Enums.PromotionScope | null
    discountPercent: number | null
    gameType: $Enums.GameType | null
    planId: string | null
    startDate: Date | null
    endDate: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    scope: $Enums.PromotionScope | null
    discountPercent: number | null
    gameType: $Enums.GameType | null
    planId: string | null
    startDate: Date | null
    endDate: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    scope: number
    discountPercent: number
    gameType: number
    planId: number
    startDate: number
    endDate: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    discountPercent?: true
  }

  export type PromotionSumAggregateInputType = {
    discountPercent?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    scope?: true
    discountPercent?: true
    gameType?: true
    planId?: true
    startDate?: true
    endDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    scope?: true
    discountPercent?: true
    gameType?: true
    planId?: true
    startDate?: true
    endDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    scope?: true
    discountPercent?: true
    gameType?: true
    planId?: true
    startDate?: true
    endDate?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    scope: $Enums.PromotionScope
    discountPercent: number
    gameType: $Enums.GameType | null
    planId: string | null
    startDate: Date
    endDate: Date | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    scope?: boolean
    discountPercent?: boolean
    gameType?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | Promotion$planArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>


  export type PromotionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    scope?: boolean
    discountPercent?: boolean
    gameType?: boolean
    planId?: boolean
    startDate?: boolean
    endDate?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | Promotion$planArgs<ExtArgs>
  }

  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      scope: $Enums.PromotionScope
      discountPercent: number
      gameType: $Enums.GameType | null
      planId: string | null
      startDate: Date
      endDate: Date | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends Promotion$planArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$planArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */ 
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'String'>
    readonly name: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly scope: FieldRef<"Promotion", 'PromotionScope'>
    readonly discountPercent: FieldRef<"Promotion", 'Int'>
    readonly gameType: FieldRef<"Promotion", 'GameType'>
    readonly planId: FieldRef<"Promotion", 'String'>
    readonly startDate: FieldRef<"Promotion", 'DateTime'>
    readonly endDate: FieldRef<"Promotion", 'DateTime'>
    readonly active: FieldRef<"Promotion", 'Boolean'>
    readonly createdAt: FieldRef<"Promotion", 'DateTime'>
    readonly updatedAt: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
  }

  /**
   * Promotion.plan
   */
  export type Promotion$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    where?: PlanWhereInput
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type OrderSumAggregateOutputType = {
    totalAmount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    status: $Enums.OrderStatus | null
    totalAmount: number | null
    currency: string | null
    paymentMethod: string | null
    paymentId: string | null
    paidAt: Date | null
    serverId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    planId: string | null
    status: $Enums.OrderStatus | null
    totalAmount: number | null
    currency: string | null
    paymentMethod: string | null
    paymentId: string | null
    paidAt: Date | null
    serverId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    userId: number
    planId: number
    status: number
    priceSnapshot: number
    totalAmount: number
    currency: number
    paymentMethod: number
    paymentId: number
    paidAt: number
    serverId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    totalAmount?: true
  }

  export type OrderSumAggregateInputType = {
    totalAmount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    totalAmount?: true
    currency?: true
    paymentMethod?: true
    paymentId?: true
    paidAt?: true
    serverId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    totalAmount?: true
    currency?: true
    paymentMethod?: true
    paymentId?: true
    paidAt?: true
    serverId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    userId?: true
    planId?: true
    status?: true
    priceSnapshot?: true
    totalAmount?: true
    currency?: true
    paymentMethod?: true
    paymentId?: true
    paidAt?: true
    serverId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    userId: string
    planId: string
    status: $Enums.OrderStatus
    priceSnapshot: JsonValue
    totalAmount: number
    currency: string
    paymentMethod: string | null
    paymentId: string | null
    paidAt: Date | null
    serverId: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    priceSnapshot?: boolean
    totalAmount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentId?: boolean
    paidAt?: boolean
    serverId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    server?: boolean | Order$serverArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>


  export type OrderSelectScalar = {
    id?: boolean
    userId?: boolean
    planId?: boolean
    status?: boolean
    priceSnapshot?: boolean
    totalAmount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentId?: boolean
    paidAt?: boolean
    serverId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    server?: boolean | Order$serverArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      plan: Prisma.$PlanPayload<ExtArgs>
      server: Prisma.$GameServerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      planId: string
      status: $Enums.OrderStatus
      priceSnapshot: Prisma.JsonValue
      totalAmount: number
      currency: string
      paymentMethod: string | null
      paymentId: string | null
      paidAt: Date | null
      serverId: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    server<T extends Order$serverArgs<ExtArgs> = {}>(args?: Subset<T, Order$serverArgs<ExtArgs>>): Prisma__GameServerClient<$Result.GetResult<Prisma.$GameServerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly userId: FieldRef<"Order", 'String'>
    readonly planId: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly priceSnapshot: FieldRef<"Order", 'Json'>
    readonly totalAmount: FieldRef<"Order", 'Int'>
    readonly currency: FieldRef<"Order", 'String'>
    readonly paymentMethod: FieldRef<"Order", 'String'>
    readonly paymentId: FieldRef<"Order", 'String'>
    readonly paidAt: FieldRef<"Order", 'DateTime'>
    readonly serverId: FieldRef<"Order", 'String'>
    readonly notes: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.server
   */
  export type Order$serverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameServer
     */
    select?: GameServerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameServerInclude<ExtArgs> | null
    where?: GameServerWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model PaymentEvent
   */

  export type AggregatePaymentEvent = {
    _count: PaymentEventCountAggregateOutputType | null
    _min: PaymentEventMinAggregateOutputType | null
    _max: PaymentEventMaxAggregateOutputType | null
  }

  export type PaymentEventMinAggregateOutputType = {
    id: string | null
    provider: $Enums.PaymentProvider | null
    eventType: string | null
    eventId: string | null
    paymentId: string | null
    orderId: string | null
    status: $Enums.PaymentEventStatus | null
    error: string | null
    createdAt: Date | null
    processedAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentEventMaxAggregateOutputType = {
    id: string | null
    provider: $Enums.PaymentProvider | null
    eventType: string | null
    eventId: string | null
    paymentId: string | null
    orderId: string | null
    status: $Enums.PaymentEventStatus | null
    error: string | null
    createdAt: Date | null
    processedAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentEventCountAggregateOutputType = {
    id: number
    provider: number
    eventType: number
    eventId: number
    paymentId: number
    orderId: number
    status: number
    payload: number
    error: number
    createdAt: number
    processedAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentEventMinAggregateInputType = {
    id?: true
    provider?: true
    eventType?: true
    eventId?: true
    paymentId?: true
    orderId?: true
    status?: true
    error?: true
    createdAt?: true
    processedAt?: true
    updatedAt?: true
  }

  export type PaymentEventMaxAggregateInputType = {
    id?: true
    provider?: true
    eventType?: true
    eventId?: true
    paymentId?: true
    orderId?: true
    status?: true
    error?: true
    createdAt?: true
    processedAt?: true
    updatedAt?: true
  }

  export type PaymentEventCountAggregateInputType = {
    id?: true
    provider?: true
    eventType?: true
    eventId?: true
    paymentId?: true
    orderId?: true
    status?: true
    payload?: true
    error?: true
    createdAt?: true
    processedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentEvent to aggregate.
     */
    where?: PaymentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentEvents to fetch.
     */
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentEvents
    **/
    _count?: true | PaymentEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentEventMaxAggregateInputType
  }

  export type GetPaymentEventAggregateType<T extends PaymentEventAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentEvent[P]>
      : GetScalarType<T[P], AggregatePaymentEvent[P]>
  }




  export type PaymentEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentEventWhereInput
    orderBy?: PaymentEventOrderByWithAggregationInput | PaymentEventOrderByWithAggregationInput[]
    by: PaymentEventScalarFieldEnum[] | PaymentEventScalarFieldEnum
    having?: PaymentEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentEventCountAggregateInputType | true
    _min?: PaymentEventMinAggregateInputType
    _max?: PaymentEventMaxAggregateInputType
  }

  export type PaymentEventGroupByOutputType = {
    id: string
    provider: $Enums.PaymentProvider
    eventType: string
    eventId: string
    paymentId: string | null
    orderId: string | null
    status: $Enums.PaymentEventStatus
    payload: JsonValue | null
    error: string | null
    createdAt: Date
    processedAt: Date | null
    updatedAt: Date
    _count: PaymentEventCountAggregateOutputType | null
    _min: PaymentEventMinAggregateOutputType | null
    _max: PaymentEventMaxAggregateOutputType | null
  }

  type GetPaymentEventGroupByPayload<T extends PaymentEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentEventGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentEventGroupByOutputType[P]>
        }
      >
    >


  export type PaymentEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    eventType?: boolean
    eventId?: boolean
    paymentId?: boolean
    orderId?: boolean
    status?: boolean
    payload?: boolean
    error?: boolean
    createdAt?: boolean
    processedAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentEvent"]>


  export type PaymentEventSelectScalar = {
    id?: boolean
    provider?: boolean
    eventType?: boolean
    eventId?: boolean
    paymentId?: boolean
    orderId?: boolean
    status?: boolean
    payload?: boolean
    error?: boolean
    createdAt?: boolean
    processedAt?: boolean
    updatedAt?: boolean
  }


  export type $PaymentEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: $Enums.PaymentProvider
      eventType: string
      eventId: string
      paymentId: string | null
      orderId: string | null
      status: $Enums.PaymentEventStatus
      payload: Prisma.JsonValue | null
      error: string | null
      createdAt: Date
      processedAt: Date | null
      updatedAt: Date
    }, ExtArgs["result"]["paymentEvent"]>
    composites: {}
  }

  type PaymentEventGetPayload<S extends boolean | null | undefined | PaymentEventDefaultArgs> = $Result.GetResult<Prisma.$PaymentEventPayload, S>

  type PaymentEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentEventCountAggregateInputType | true
    }

  export interface PaymentEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentEvent'], meta: { name: 'PaymentEvent' } }
    /**
     * Find zero or one PaymentEvent that matches the filter.
     * @param {PaymentEventFindUniqueArgs} args - Arguments to find a PaymentEvent
     * @example
     * // Get one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentEventFindUniqueArgs>(args: SelectSubset<T, PaymentEventFindUniqueArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentEventFindUniqueOrThrowArgs} args - Arguments to find a PaymentEvent
     * @example
     * // Get one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentEventFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventFindFirstArgs} args - Arguments to find a PaymentEvent
     * @example
     * // Get one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentEventFindFirstArgs>(args?: SelectSubset<T, PaymentEventFindFirstArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventFindFirstOrThrowArgs} args - Arguments to find a PaymentEvent
     * @example
     * // Get one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentEventFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentEvents
     * const paymentEvents = await prisma.paymentEvent.findMany()
     * 
     * // Get first 10 PaymentEvents
     * const paymentEvents = await prisma.paymentEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentEventWithIdOnly = await prisma.paymentEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentEventFindManyArgs>(args?: SelectSubset<T, PaymentEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentEvent.
     * @param {PaymentEventCreateArgs} args - Arguments to create a PaymentEvent.
     * @example
     * // Create one PaymentEvent
     * const PaymentEvent = await prisma.paymentEvent.create({
     *   data: {
     *     // ... data to create a PaymentEvent
     *   }
     * })
     * 
     */
    create<T extends PaymentEventCreateArgs>(args: SelectSubset<T, PaymentEventCreateArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentEvents.
     * @param {PaymentEventCreateManyArgs} args - Arguments to create many PaymentEvents.
     * @example
     * // Create many PaymentEvents
     * const paymentEvent = await prisma.paymentEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentEventCreateManyArgs>(args?: SelectSubset<T, PaymentEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentEvent.
     * @param {PaymentEventDeleteArgs} args - Arguments to delete one PaymentEvent.
     * @example
     * // Delete one PaymentEvent
     * const PaymentEvent = await prisma.paymentEvent.delete({
     *   where: {
     *     // ... filter to delete one PaymentEvent
     *   }
     * })
     * 
     */
    delete<T extends PaymentEventDeleteArgs>(args: SelectSubset<T, PaymentEventDeleteArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentEvent.
     * @param {PaymentEventUpdateArgs} args - Arguments to update one PaymentEvent.
     * @example
     * // Update one PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentEventUpdateArgs>(args: SelectSubset<T, PaymentEventUpdateArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentEvents.
     * @param {PaymentEventDeleteManyArgs} args - Arguments to filter PaymentEvents to delete.
     * @example
     * // Delete a few PaymentEvents
     * const { count } = await prisma.paymentEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentEventDeleteManyArgs>(args?: SelectSubset<T, PaymentEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentEvents
     * const paymentEvent = await prisma.paymentEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentEventUpdateManyArgs>(args: SelectSubset<T, PaymentEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentEvent.
     * @param {PaymentEventUpsertArgs} args - Arguments to update or create a PaymentEvent.
     * @example
     * // Update or create a PaymentEvent
     * const paymentEvent = await prisma.paymentEvent.upsert({
     *   create: {
     *     // ... data to create a PaymentEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentEvent we want to update
     *   }
     * })
     */
    upsert<T extends PaymentEventUpsertArgs>(args: SelectSubset<T, PaymentEventUpsertArgs<ExtArgs>>): Prisma__PaymentEventClient<$Result.GetResult<Prisma.$PaymentEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventCountArgs} args - Arguments to filter PaymentEvents to count.
     * @example
     * // Count the number of PaymentEvents
     * const count = await prisma.paymentEvent.count({
     *   where: {
     *     // ... the filter for the PaymentEvents we want to count
     *   }
     * })
    **/
    count<T extends PaymentEventCountArgs>(
      args?: Subset<T, PaymentEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentEventAggregateArgs>(args: Subset<T, PaymentEventAggregateArgs>): Prisma.PrismaPromise<GetPaymentEventAggregateType<T>>

    /**
     * Group by PaymentEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentEventGroupByArgs['orderBy'] }
        : { orderBy?: PaymentEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentEvent model
   */
  readonly fields: PaymentEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentEvent model
   */ 
  interface PaymentEventFieldRefs {
    readonly id: FieldRef<"PaymentEvent", 'String'>
    readonly provider: FieldRef<"PaymentEvent", 'PaymentProvider'>
    readonly eventType: FieldRef<"PaymentEvent", 'String'>
    readonly eventId: FieldRef<"PaymentEvent", 'String'>
    readonly paymentId: FieldRef<"PaymentEvent", 'String'>
    readonly orderId: FieldRef<"PaymentEvent", 'String'>
    readonly status: FieldRef<"PaymentEvent", 'PaymentEventStatus'>
    readonly payload: FieldRef<"PaymentEvent", 'Json'>
    readonly error: FieldRef<"PaymentEvent", 'String'>
    readonly createdAt: FieldRef<"PaymentEvent", 'DateTime'>
    readonly processedAt: FieldRef<"PaymentEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentEvent findUnique
   */
  export type PaymentEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Filter, which PaymentEvent to fetch.
     */
    where: PaymentEventWhereUniqueInput
  }

  /**
   * PaymentEvent findUniqueOrThrow
   */
  export type PaymentEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Filter, which PaymentEvent to fetch.
     */
    where: PaymentEventWhereUniqueInput
  }

  /**
   * PaymentEvent findFirst
   */
  export type PaymentEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Filter, which PaymentEvent to fetch.
     */
    where?: PaymentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentEvents to fetch.
     */
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentEvents.
     */
    cursor?: PaymentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentEvents.
     */
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * PaymentEvent findFirstOrThrow
   */
  export type PaymentEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Filter, which PaymentEvent to fetch.
     */
    where?: PaymentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentEvents to fetch.
     */
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentEvents.
     */
    cursor?: PaymentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentEvents.
     */
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * PaymentEvent findMany
   */
  export type PaymentEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Filter, which PaymentEvents to fetch.
     */
    where?: PaymentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentEvents to fetch.
     */
    orderBy?: PaymentEventOrderByWithRelationInput | PaymentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentEvents.
     */
    cursor?: PaymentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentEvents.
     */
    skip?: number
    distinct?: PaymentEventScalarFieldEnum | PaymentEventScalarFieldEnum[]
  }

  /**
   * PaymentEvent create
   */
  export type PaymentEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * The data needed to create a PaymentEvent.
     */
    data: XOR<PaymentEventCreateInput, PaymentEventUncheckedCreateInput>
  }

  /**
   * PaymentEvent createMany
   */
  export type PaymentEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentEvents.
     */
    data: PaymentEventCreateManyInput | PaymentEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentEvent update
   */
  export type PaymentEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * The data needed to update a PaymentEvent.
     */
    data: XOR<PaymentEventUpdateInput, PaymentEventUncheckedUpdateInput>
    /**
     * Choose, which PaymentEvent to update.
     */
    where: PaymentEventWhereUniqueInput
  }

  /**
   * PaymentEvent updateMany
   */
  export type PaymentEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentEvents.
     */
    data: XOR<PaymentEventUpdateManyMutationInput, PaymentEventUncheckedUpdateManyInput>
    /**
     * Filter which PaymentEvents to update
     */
    where?: PaymentEventWhereInput
  }

  /**
   * PaymentEvent upsert
   */
  export type PaymentEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * The filter to search for the PaymentEvent to update in case it exists.
     */
    where: PaymentEventWhereUniqueInput
    /**
     * In case the PaymentEvent found by the `where` argument doesn't exist, create a new PaymentEvent with this data.
     */
    create: XOR<PaymentEventCreateInput, PaymentEventUncheckedCreateInput>
    /**
     * In case the PaymentEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentEventUpdateInput, PaymentEventUncheckedUpdateInput>
  }

  /**
   * PaymentEvent delete
   */
  export type PaymentEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
    /**
     * Filter which PaymentEvent to delete.
     */
    where: PaymentEventWhereUniqueInput
  }

  /**
   * PaymentEvent deleteMany
   */
  export type PaymentEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentEvents to delete
     */
    where?: PaymentEventWhereInput
  }

  /**
   * PaymentEvent without action
   */
  export type PaymentEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentEvent
     */
    select?: PaymentEventSelect<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: string | null
    ticketNumber: string | null
    subject: string | null
    description: string | null
    priority: $Enums.TicketPriority | null
    category: string | null
    status: $Enums.TicketStatus | null
    assignedToId: string | null
    assignedAt: Date | null
    slaResponseDeadline: Date | null
    slaResolveDeadline: Date | null
    firstResponseAt: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    closedAt: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: string | null
    ticketNumber: string | null
    subject: string | null
    description: string | null
    priority: $Enums.TicketPriority | null
    category: string | null
    status: $Enums.TicketStatus | null
    assignedToId: string | null
    assignedAt: Date | null
    slaResponseDeadline: Date | null
    slaResolveDeadline: Date | null
    firstResponseAt: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    closedAt: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    ticketNumber: number
    subject: number
    description: number
    priority: number
    category: number
    status: number
    assignedToId: number
    assignedAt: number
    slaResponseDeadline: number
    slaResolveDeadline: number
    firstResponseAt: number
    userId: number
    createdAt: number
    updatedAt: number
    closedAt: number
    _all: number
  }


  export type SupportTicketMinAggregateInputType = {
    id?: true
    ticketNumber?: true
    subject?: true
    description?: true
    priority?: true
    category?: true
    status?: true
    assignedToId?: true
    assignedAt?: true
    slaResponseDeadline?: true
    slaResolveDeadline?: true
    firstResponseAt?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    ticketNumber?: true
    subject?: true
    description?: true
    priority?: true
    category?: true
    status?: true
    assignedToId?: true
    assignedAt?: true
    slaResponseDeadline?: true
    slaResolveDeadline?: true
    firstResponseAt?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    ticketNumber?: true
    subject?: true
    description?: true
    priority?: true
    category?: true
    status?: true
    assignedToId?: true
    assignedAt?: true
    slaResponseDeadline?: true
    slaResolveDeadline?: true
    firstResponseAt?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    closedAt?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: string
    ticketNumber: string
    subject: string
    description: string
    priority: $Enums.TicketPriority
    category: string | null
    status: $Enums.TicketStatus
    assignedToId: string | null
    assignedAt: Date | null
    slaResponseDeadline: Date | null
    slaResolveDeadline: Date | null
    firstResponseAt: Date | null
    userId: string
    createdAt: Date
    updatedAt: Date
    closedAt: Date | null
    _count: SupportTicketCountAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    subject?: boolean
    description?: boolean
    priority?: boolean
    category?: boolean
    status?: boolean
    assignedToId?: boolean
    assignedAt?: boolean
    slaResponseDeadline?: boolean
    slaResolveDeadline?: boolean
    firstResponseAt?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | SupportTicket$commentsArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>


  export type SupportTicketSelectScalar = {
    id?: boolean
    ticketNumber?: boolean
    subject?: boolean
    description?: boolean
    priority?: boolean
    category?: boolean
    status?: boolean
    assignedToId?: boolean
    assignedAt?: boolean
    slaResponseDeadline?: boolean
    slaResolveDeadline?: boolean
    firstResponseAt?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    closedAt?: boolean
  }

  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedTo?: boolean | SupportTicket$assignedToArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | SupportTicket$commentsArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$TicketCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketNumber: string
      subject: string
      description: string
      priority: $Enums.TicketPriority
      category: string | null
      status: $Enums.TicketStatus
      assignedToId: string | null
      assignedAt: Date | null
      slaResponseDeadline: Date | null
      slaResolveDeadline: Date | null
      firstResponseAt: Date | null
      userId: string
      createdAt: Date
      updatedAt: Date
      closedAt: Date | null
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedTo<T extends SupportTicket$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comments<T extends SupportTicket$commentsArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */ 
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'String'>
    readonly ticketNumber: FieldRef<"SupportTicket", 'String'>
    readonly subject: FieldRef<"SupportTicket", 'String'>
    readonly description: FieldRef<"SupportTicket", 'String'>
    readonly priority: FieldRef<"SupportTicket", 'TicketPriority'>
    readonly category: FieldRef<"SupportTicket", 'String'>
    readonly status: FieldRef<"SupportTicket", 'TicketStatus'>
    readonly assignedToId: FieldRef<"SupportTicket", 'String'>
    readonly assignedAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly slaResponseDeadline: FieldRef<"SupportTicket", 'DateTime'>
    readonly slaResolveDeadline: FieldRef<"SupportTicket", 'DateTime'>
    readonly firstResponseAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly userId: FieldRef<"SupportTicket", 'String'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly closedAt: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
  }

  /**
   * SupportTicket.assignedTo
   */
  export type SupportTicket$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SupportTicket.comments
   */
  export type SupportTicket$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model SlaPolicy
   */

  export type AggregateSlaPolicy = {
    _count: SlaPolicyCountAggregateOutputType | null
    _avg: SlaPolicyAvgAggregateOutputType | null
    _sum: SlaPolicySumAggregateOutputType | null
    _min: SlaPolicyMinAggregateOutputType | null
    _max: SlaPolicyMaxAggregateOutputType | null
  }

  export type SlaPolicyAvgAggregateOutputType = {
    responseTimeHours: number | null
    resolveTimeHours: number | null
  }

  export type SlaPolicySumAggregateOutputType = {
    responseTimeHours: number | null
    resolveTimeHours: number | null
  }

  export type SlaPolicyMinAggregateOutputType = {
    id: string | null
    priority: $Enums.TicketPriority | null
    responseTimeHours: number | null
    resolveTimeHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlaPolicyMaxAggregateOutputType = {
    id: string | null
    priority: $Enums.TicketPriority | null
    responseTimeHours: number | null
    resolveTimeHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SlaPolicyCountAggregateOutputType = {
    id: number
    priority: number
    responseTimeHours: number
    resolveTimeHours: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SlaPolicyAvgAggregateInputType = {
    responseTimeHours?: true
    resolveTimeHours?: true
  }

  export type SlaPolicySumAggregateInputType = {
    responseTimeHours?: true
    resolveTimeHours?: true
  }

  export type SlaPolicyMinAggregateInputType = {
    id?: true
    priority?: true
    responseTimeHours?: true
    resolveTimeHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlaPolicyMaxAggregateInputType = {
    id?: true
    priority?: true
    responseTimeHours?: true
    resolveTimeHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SlaPolicyCountAggregateInputType = {
    id?: true
    priority?: true
    responseTimeHours?: true
    resolveTimeHours?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SlaPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SlaPolicy to aggregate.
     */
    where?: SlaPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlaPolicies to fetch.
     */
    orderBy?: SlaPolicyOrderByWithRelationInput | SlaPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SlaPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlaPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlaPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SlaPolicies
    **/
    _count?: true | SlaPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SlaPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SlaPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SlaPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SlaPolicyMaxAggregateInputType
  }

  export type GetSlaPolicyAggregateType<T extends SlaPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateSlaPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSlaPolicy[P]>
      : GetScalarType<T[P], AggregateSlaPolicy[P]>
  }




  export type SlaPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SlaPolicyWhereInput
    orderBy?: SlaPolicyOrderByWithAggregationInput | SlaPolicyOrderByWithAggregationInput[]
    by: SlaPolicyScalarFieldEnum[] | SlaPolicyScalarFieldEnum
    having?: SlaPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SlaPolicyCountAggregateInputType | true
    _avg?: SlaPolicyAvgAggregateInputType
    _sum?: SlaPolicySumAggregateInputType
    _min?: SlaPolicyMinAggregateInputType
    _max?: SlaPolicyMaxAggregateInputType
  }

  export type SlaPolicyGroupByOutputType = {
    id: string
    priority: $Enums.TicketPriority
    responseTimeHours: number
    resolveTimeHours: number
    createdAt: Date
    updatedAt: Date
    _count: SlaPolicyCountAggregateOutputType | null
    _avg: SlaPolicyAvgAggregateOutputType | null
    _sum: SlaPolicySumAggregateOutputType | null
    _min: SlaPolicyMinAggregateOutputType | null
    _max: SlaPolicyMaxAggregateOutputType | null
  }

  type GetSlaPolicyGroupByPayload<T extends SlaPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SlaPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SlaPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SlaPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], SlaPolicyGroupByOutputType[P]>
        }
      >
    >


  export type SlaPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    priority?: boolean
    responseTimeHours?: boolean
    resolveTimeHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["slaPolicy"]>


  export type SlaPolicySelectScalar = {
    id?: boolean
    priority?: boolean
    responseTimeHours?: boolean
    resolveTimeHours?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SlaPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SlaPolicy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      priority: $Enums.TicketPriority
      responseTimeHours: number
      resolveTimeHours: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["slaPolicy"]>
    composites: {}
  }

  type SlaPolicyGetPayload<S extends boolean | null | undefined | SlaPolicyDefaultArgs> = $Result.GetResult<Prisma.$SlaPolicyPayload, S>

  type SlaPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SlaPolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SlaPolicyCountAggregateInputType | true
    }

  export interface SlaPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SlaPolicy'], meta: { name: 'SlaPolicy' } }
    /**
     * Find zero or one SlaPolicy that matches the filter.
     * @param {SlaPolicyFindUniqueArgs} args - Arguments to find a SlaPolicy
     * @example
     * // Get one SlaPolicy
     * const slaPolicy = await prisma.slaPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SlaPolicyFindUniqueArgs>(args: SelectSubset<T, SlaPolicyFindUniqueArgs<ExtArgs>>): Prisma__SlaPolicyClient<$Result.GetResult<Prisma.$SlaPolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SlaPolicy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SlaPolicyFindUniqueOrThrowArgs} args - Arguments to find a SlaPolicy
     * @example
     * // Get one SlaPolicy
     * const slaPolicy = await prisma.slaPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SlaPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, SlaPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SlaPolicyClient<$Result.GetResult<Prisma.$SlaPolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SlaPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlaPolicyFindFirstArgs} args - Arguments to find a SlaPolicy
     * @example
     * // Get one SlaPolicy
     * const slaPolicy = await prisma.slaPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SlaPolicyFindFirstArgs>(args?: SelectSubset<T, SlaPolicyFindFirstArgs<ExtArgs>>): Prisma__SlaPolicyClient<$Result.GetResult<Prisma.$SlaPolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SlaPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlaPolicyFindFirstOrThrowArgs} args - Arguments to find a SlaPolicy
     * @example
     * // Get one SlaPolicy
     * const slaPolicy = await prisma.slaPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SlaPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, SlaPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SlaPolicyClient<$Result.GetResult<Prisma.$SlaPolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SlaPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlaPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SlaPolicies
     * const slaPolicies = await prisma.slaPolicy.findMany()
     * 
     * // Get first 10 SlaPolicies
     * const slaPolicies = await prisma.slaPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const slaPolicyWithIdOnly = await prisma.slaPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SlaPolicyFindManyArgs>(args?: SelectSubset<T, SlaPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SlaPolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SlaPolicy.
     * @param {SlaPolicyCreateArgs} args - Arguments to create a SlaPolicy.
     * @example
     * // Create one SlaPolicy
     * const SlaPolicy = await prisma.slaPolicy.create({
     *   data: {
     *     // ... data to create a SlaPolicy
     *   }
     * })
     * 
     */
    create<T extends SlaPolicyCreateArgs>(args: SelectSubset<T, SlaPolicyCreateArgs<ExtArgs>>): Prisma__SlaPolicyClient<$Result.GetResult<Prisma.$SlaPolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SlaPolicies.
     * @param {SlaPolicyCreateManyArgs} args - Arguments to create many SlaPolicies.
     * @example
     * // Create many SlaPolicies
     * const slaPolicy = await prisma.slaPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SlaPolicyCreateManyArgs>(args?: SelectSubset<T, SlaPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SlaPolicy.
     * @param {SlaPolicyDeleteArgs} args - Arguments to delete one SlaPolicy.
     * @example
     * // Delete one SlaPolicy
     * const SlaPolicy = await prisma.slaPolicy.delete({
     *   where: {
     *     // ... filter to delete one SlaPolicy
     *   }
     * })
     * 
     */
    delete<T extends SlaPolicyDeleteArgs>(args: SelectSubset<T, SlaPolicyDeleteArgs<ExtArgs>>): Prisma__SlaPolicyClient<$Result.GetResult<Prisma.$SlaPolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SlaPolicy.
     * @param {SlaPolicyUpdateArgs} args - Arguments to update one SlaPolicy.
     * @example
     * // Update one SlaPolicy
     * const slaPolicy = await prisma.slaPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SlaPolicyUpdateArgs>(args: SelectSubset<T, SlaPolicyUpdateArgs<ExtArgs>>): Prisma__SlaPolicyClient<$Result.GetResult<Prisma.$SlaPolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SlaPolicies.
     * @param {SlaPolicyDeleteManyArgs} args - Arguments to filter SlaPolicies to delete.
     * @example
     * // Delete a few SlaPolicies
     * const { count } = await prisma.slaPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SlaPolicyDeleteManyArgs>(args?: SelectSubset<T, SlaPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SlaPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlaPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SlaPolicies
     * const slaPolicy = await prisma.slaPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SlaPolicyUpdateManyArgs>(args: SelectSubset<T, SlaPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SlaPolicy.
     * @param {SlaPolicyUpsertArgs} args - Arguments to update or create a SlaPolicy.
     * @example
     * // Update or create a SlaPolicy
     * const slaPolicy = await prisma.slaPolicy.upsert({
     *   create: {
     *     // ... data to create a SlaPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SlaPolicy we want to update
     *   }
     * })
     */
    upsert<T extends SlaPolicyUpsertArgs>(args: SelectSubset<T, SlaPolicyUpsertArgs<ExtArgs>>): Prisma__SlaPolicyClient<$Result.GetResult<Prisma.$SlaPolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SlaPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlaPolicyCountArgs} args - Arguments to filter SlaPolicies to count.
     * @example
     * // Count the number of SlaPolicies
     * const count = await prisma.slaPolicy.count({
     *   where: {
     *     // ... the filter for the SlaPolicies we want to count
     *   }
     * })
    **/
    count<T extends SlaPolicyCountArgs>(
      args?: Subset<T, SlaPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SlaPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SlaPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlaPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SlaPolicyAggregateArgs>(args: Subset<T, SlaPolicyAggregateArgs>): Prisma.PrismaPromise<GetSlaPolicyAggregateType<T>>

    /**
     * Group by SlaPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SlaPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SlaPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SlaPolicyGroupByArgs['orderBy'] }
        : { orderBy?: SlaPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SlaPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSlaPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SlaPolicy model
   */
  readonly fields: SlaPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SlaPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SlaPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SlaPolicy model
   */ 
  interface SlaPolicyFieldRefs {
    readonly id: FieldRef<"SlaPolicy", 'String'>
    readonly priority: FieldRef<"SlaPolicy", 'TicketPriority'>
    readonly responseTimeHours: FieldRef<"SlaPolicy", 'Int'>
    readonly resolveTimeHours: FieldRef<"SlaPolicy", 'Int'>
    readonly createdAt: FieldRef<"SlaPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"SlaPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SlaPolicy findUnique
   */
  export type SlaPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlaPolicy
     */
    select?: SlaPolicySelect<ExtArgs> | null
    /**
     * Filter, which SlaPolicy to fetch.
     */
    where: SlaPolicyWhereUniqueInput
  }

  /**
   * SlaPolicy findUniqueOrThrow
   */
  export type SlaPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlaPolicy
     */
    select?: SlaPolicySelect<ExtArgs> | null
    /**
     * Filter, which SlaPolicy to fetch.
     */
    where: SlaPolicyWhereUniqueInput
  }

  /**
   * SlaPolicy findFirst
   */
  export type SlaPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlaPolicy
     */
    select?: SlaPolicySelect<ExtArgs> | null
    /**
     * Filter, which SlaPolicy to fetch.
     */
    where?: SlaPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlaPolicies to fetch.
     */
    orderBy?: SlaPolicyOrderByWithRelationInput | SlaPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SlaPolicies.
     */
    cursor?: SlaPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlaPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlaPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SlaPolicies.
     */
    distinct?: SlaPolicyScalarFieldEnum | SlaPolicyScalarFieldEnum[]
  }

  /**
   * SlaPolicy findFirstOrThrow
   */
  export type SlaPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlaPolicy
     */
    select?: SlaPolicySelect<ExtArgs> | null
    /**
     * Filter, which SlaPolicy to fetch.
     */
    where?: SlaPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlaPolicies to fetch.
     */
    orderBy?: SlaPolicyOrderByWithRelationInput | SlaPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SlaPolicies.
     */
    cursor?: SlaPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlaPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlaPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SlaPolicies.
     */
    distinct?: SlaPolicyScalarFieldEnum | SlaPolicyScalarFieldEnum[]
  }

  /**
   * SlaPolicy findMany
   */
  export type SlaPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlaPolicy
     */
    select?: SlaPolicySelect<ExtArgs> | null
    /**
     * Filter, which SlaPolicies to fetch.
     */
    where?: SlaPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SlaPolicies to fetch.
     */
    orderBy?: SlaPolicyOrderByWithRelationInput | SlaPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SlaPolicies.
     */
    cursor?: SlaPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SlaPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SlaPolicies.
     */
    skip?: number
    distinct?: SlaPolicyScalarFieldEnum | SlaPolicyScalarFieldEnum[]
  }

  /**
   * SlaPolicy create
   */
  export type SlaPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlaPolicy
     */
    select?: SlaPolicySelect<ExtArgs> | null
    /**
     * The data needed to create a SlaPolicy.
     */
    data: XOR<SlaPolicyCreateInput, SlaPolicyUncheckedCreateInput>
  }

  /**
   * SlaPolicy createMany
   */
  export type SlaPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SlaPolicies.
     */
    data: SlaPolicyCreateManyInput | SlaPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SlaPolicy update
   */
  export type SlaPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlaPolicy
     */
    select?: SlaPolicySelect<ExtArgs> | null
    /**
     * The data needed to update a SlaPolicy.
     */
    data: XOR<SlaPolicyUpdateInput, SlaPolicyUncheckedUpdateInput>
    /**
     * Choose, which SlaPolicy to update.
     */
    where: SlaPolicyWhereUniqueInput
  }

  /**
   * SlaPolicy updateMany
   */
  export type SlaPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SlaPolicies.
     */
    data: XOR<SlaPolicyUpdateManyMutationInput, SlaPolicyUncheckedUpdateManyInput>
    /**
     * Filter which SlaPolicies to update
     */
    where?: SlaPolicyWhereInput
  }

  /**
   * SlaPolicy upsert
   */
  export type SlaPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlaPolicy
     */
    select?: SlaPolicySelect<ExtArgs> | null
    /**
     * The filter to search for the SlaPolicy to update in case it exists.
     */
    where: SlaPolicyWhereUniqueInput
    /**
     * In case the SlaPolicy found by the `where` argument doesn't exist, create a new SlaPolicy with this data.
     */
    create: XOR<SlaPolicyCreateInput, SlaPolicyUncheckedCreateInput>
    /**
     * In case the SlaPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SlaPolicyUpdateInput, SlaPolicyUncheckedUpdateInput>
  }

  /**
   * SlaPolicy delete
   */
  export type SlaPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlaPolicy
     */
    select?: SlaPolicySelect<ExtArgs> | null
    /**
     * Filter which SlaPolicy to delete.
     */
    where: SlaPolicyWhereUniqueInput
  }

  /**
   * SlaPolicy deleteMany
   */
  export type SlaPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SlaPolicies to delete
     */
    where?: SlaPolicyWhereInput
  }

  /**
   * SlaPolicy without action
   */
  export type SlaPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SlaPolicy
     */
    select?: SlaPolicySelect<ExtArgs> | null
  }


  /**
   * Model TicketComment
   */

  export type AggregateTicketComment = {
    _count: TicketCommentCountAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  export type TicketCommentMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    authorId: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketCommentMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    authorId: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketCommentCountAggregateOutputType = {
    id: number
    ticketId: number
    authorId: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketCommentMinAggregateInputType = {
    id?: true
    ticketId?: true
    authorId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketCommentMaxAggregateInputType = {
    id?: true
    ticketId?: true
    authorId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketCommentCountAggregateInputType = {
    id?: true
    ticketId?: true
    authorId?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComment to aggregate.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketComments
    **/
    _count?: true | TicketCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketCommentMaxAggregateInputType
  }

  export type GetTicketCommentAggregateType<T extends TicketCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketComment[P]>
      : GetScalarType<T[P], AggregateTicketComment[P]>
  }




  export type TicketCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithAggregationInput | TicketCommentOrderByWithAggregationInput[]
    by: TicketCommentScalarFieldEnum[] | TicketCommentScalarFieldEnum
    having?: TicketCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCommentCountAggregateInputType | true
    _min?: TicketCommentMinAggregateInputType
    _max?: TicketCommentMaxAggregateInputType
  }

  export type TicketCommentGroupByOutputType = {
    id: string
    ticketId: string
    authorId: string
    message: string
    createdAt: Date
    updatedAt: Date
    _count: TicketCommentCountAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  type GetTicketCommentGroupByPayload<T extends TicketCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
        }
      >
    >


  export type TicketCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    authorId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>


  export type TicketCommentSelectScalar = {
    id?: boolean
    ticketId?: boolean
    authorId?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TicketCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketComment"
    objects: {
      ticket: Prisma.$SupportTicketPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      authorId: string
      message: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ticketComment"]>
    composites: {}
  }

  type TicketCommentGetPayload<S extends boolean | null | undefined | TicketCommentDefaultArgs> = $Result.GetResult<Prisma.$TicketCommentPayload, S>

  type TicketCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketCommentCountAggregateInputType | true
    }

  export interface TicketCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketComment'], meta: { name: 'TicketComment' } }
    /**
     * Find zero or one TicketComment that matches the filter.
     * @param {TicketCommentFindUniqueArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketCommentFindUniqueArgs>(args: SelectSubset<T, TicketCommentFindUniqueArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketCommentFindUniqueOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketCommentFindFirstArgs>(args?: SelectSubset<T, TicketCommentFindFirstArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketComments
     * const ticketComments = await prisma.ticketComment.findMany()
     * 
     * // Get first 10 TicketComments
     * const ticketComments = await prisma.ticketComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketCommentFindManyArgs>(args?: SelectSubset<T, TicketCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketComment.
     * @param {TicketCommentCreateArgs} args - Arguments to create a TicketComment.
     * @example
     * // Create one TicketComment
     * const TicketComment = await prisma.ticketComment.create({
     *   data: {
     *     // ... data to create a TicketComment
     *   }
     * })
     * 
     */
    create<T extends TicketCommentCreateArgs>(args: SelectSubset<T, TicketCommentCreateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketComments.
     * @param {TicketCommentCreateManyArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCommentCreateManyArgs>(args?: SelectSubset<T, TicketCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TicketComment.
     * @param {TicketCommentDeleteArgs} args - Arguments to delete one TicketComment.
     * @example
     * // Delete one TicketComment
     * const TicketComment = await prisma.ticketComment.delete({
     *   where: {
     *     // ... filter to delete one TicketComment
     *   }
     * })
     * 
     */
    delete<T extends TicketCommentDeleteArgs>(args: SelectSubset<T, TicketCommentDeleteArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketComment.
     * @param {TicketCommentUpdateArgs} args - Arguments to update one TicketComment.
     * @example
     * // Update one TicketComment
     * const ticketComment = await prisma.ticketComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketCommentUpdateArgs>(args: SelectSubset<T, TicketCommentUpdateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketComments.
     * @param {TicketCommentDeleteManyArgs} args - Arguments to filter TicketComments to delete.
     * @example
     * // Delete a few TicketComments
     * const { count } = await prisma.ticketComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketCommentDeleteManyArgs>(args?: SelectSubset<T, TicketCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketCommentUpdateManyArgs>(args: SelectSubset<T, TicketCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketComment.
     * @param {TicketCommentUpsertArgs} args - Arguments to update or create a TicketComment.
     * @example
     * // Update or create a TicketComment
     * const ticketComment = await prisma.ticketComment.upsert({
     *   create: {
     *     // ... data to create a TicketComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketComment we want to update
     *   }
     * })
     */
    upsert<T extends TicketCommentUpsertArgs>(args: SelectSubset<T, TicketCommentUpsertArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentCountArgs} args - Arguments to filter TicketComments to count.
     * @example
     * // Count the number of TicketComments
     * const count = await prisma.ticketComment.count({
     *   where: {
     *     // ... the filter for the TicketComments we want to count
     *   }
     * })
    **/
    count<T extends TicketCommentCountArgs>(
      args?: Subset<T, TicketCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketCommentAggregateArgs>(args: Subset<T, TicketCommentAggregateArgs>): Prisma.PrismaPromise<GetTicketCommentAggregateType<T>>

    /**
     * Group by TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketCommentGroupByArgs['orderBy'] }
        : { orderBy?: TicketCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketComment model
   */
  readonly fields: TicketCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends SupportTicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicketDefaultArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketComment model
   */ 
  interface TicketCommentFieldRefs {
    readonly id: FieldRef<"TicketComment", 'String'>
    readonly ticketId: FieldRef<"TicketComment", 'String'>
    readonly authorId: FieldRef<"TicketComment", 'String'>
    readonly message: FieldRef<"TicketComment", 'String'>
    readonly createdAt: FieldRef<"TicketComment", 'DateTime'>
    readonly updatedAt: FieldRef<"TicketComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketComment findUnique
   */
  export type TicketCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findUniqueOrThrow
   */
  export type TicketCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findFirst
   */
  export type TicketCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findFirstOrThrow
   */
  export type TicketCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findMany
   */
  export type TicketCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComments to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment create
   */
  export type TicketCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketComment.
     */
    data: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
  }

  /**
   * TicketComment createMany
   */
  export type TicketCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketComment update
   */
  export type TicketCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketComment.
     */
    data: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
    /**
     * Choose, which TicketComment to update.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment updateMany
   */
  export type TicketCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
  }

  /**
   * TicketComment upsert
   */
  export type TicketCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketComment to update in case it exists.
     */
    where: TicketCommentWhereUniqueInput
    /**
     * In case the TicketComment found by the `where` argument doesn't exist, create a new TicketComment with this data.
     */
    create: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
    /**
     * In case the TicketComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
  }

  /**
   * TicketComment delete
   */
  export type TicketCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter which TicketComment to delete.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment deleteMany
   */
  export type TicketCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComments to delete
     */
    where?: TicketCommentWhereInput
  }

  /**
   * TicketComment without action
   */
  export type TicketCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeBaseArticle
   */

  export type AggregateKnowledgeBaseArticle = {
    _count: KnowledgeBaseArticleCountAggregateOutputType | null
    _avg: KnowledgeBaseArticleAvgAggregateOutputType | null
    _sum: KnowledgeBaseArticleSumAggregateOutputType | null
    _min: KnowledgeBaseArticleMinAggregateOutputType | null
    _max: KnowledgeBaseArticleMaxAggregateOutputType | null
  }

  export type KnowledgeBaseArticleAvgAggregateOutputType = {
    views: number | null
    helpful: number | null
    notHelpful: number | null
  }

  export type KnowledgeBaseArticleSumAggregateOutputType = {
    views: number | null
    helpful: number | null
    notHelpful: number | null
  }

  export type KnowledgeBaseArticleMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    categoryId: string | null
    authorId: string | null
    published: boolean | null
    views: number | null
    helpful: number | null
    notHelpful: number | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type KnowledgeBaseArticleMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    categoryId: string | null
    authorId: string | null
    published: boolean | null
    views: number | null
    helpful: number | null
    notHelpful: number | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type KnowledgeBaseArticleCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    content: number
    excerpt: number
    categoryId: number
    authorId: number
    tags: number
    published: number
    views: number
    helpful: number
    notHelpful: number
    createdAt: number
    updatedAt: number
    publishedAt: number
    _all: number
  }


  export type KnowledgeBaseArticleAvgAggregateInputType = {
    views?: true
    helpful?: true
    notHelpful?: true
  }

  export type KnowledgeBaseArticleSumAggregateInputType = {
    views?: true
    helpful?: true
    notHelpful?: true
  }

  export type KnowledgeBaseArticleMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    categoryId?: true
    authorId?: true
    published?: true
    views?: true
    helpful?: true
    notHelpful?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type KnowledgeBaseArticleMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    categoryId?: true
    authorId?: true
    published?: true
    views?: true
    helpful?: true
    notHelpful?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type KnowledgeBaseArticleCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    categoryId?: true
    authorId?: true
    tags?: true
    published?: true
    views?: true
    helpful?: true
    notHelpful?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    _all?: true
  }

  export type KnowledgeBaseArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBaseArticle to aggregate.
     */
    where?: KnowledgeBaseArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseArticles to fetch.
     */
    orderBy?: KnowledgeBaseArticleOrderByWithRelationInput | KnowledgeBaseArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeBaseArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeBaseArticles
    **/
    _count?: true | KnowledgeBaseArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeBaseArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeBaseArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeBaseArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeBaseArticleMaxAggregateInputType
  }

  export type GetKnowledgeBaseArticleAggregateType<T extends KnowledgeBaseArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeBaseArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeBaseArticle[P]>
      : GetScalarType<T[P], AggregateKnowledgeBaseArticle[P]>
  }




  export type KnowledgeBaseArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseArticleWhereInput
    orderBy?: KnowledgeBaseArticleOrderByWithAggregationInput | KnowledgeBaseArticleOrderByWithAggregationInput[]
    by: KnowledgeBaseArticleScalarFieldEnum[] | KnowledgeBaseArticleScalarFieldEnum
    having?: KnowledgeBaseArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeBaseArticleCountAggregateInputType | true
    _avg?: KnowledgeBaseArticleAvgAggregateInputType
    _sum?: KnowledgeBaseArticleSumAggregateInputType
    _min?: KnowledgeBaseArticleMinAggregateInputType
    _max?: KnowledgeBaseArticleMaxAggregateInputType
  }

  export type KnowledgeBaseArticleGroupByOutputType = {
    id: string
    title: string
    slug: string
    content: string
    excerpt: string | null
    categoryId: string
    authorId: string
    tags: JsonValue
    published: boolean
    views: number
    helpful: number
    notHelpful: number
    createdAt: Date
    updatedAt: Date
    publishedAt: Date | null
    _count: KnowledgeBaseArticleCountAggregateOutputType | null
    _avg: KnowledgeBaseArticleAvgAggregateOutputType | null
    _sum: KnowledgeBaseArticleSumAggregateOutputType | null
    _min: KnowledgeBaseArticleMinAggregateOutputType | null
    _max: KnowledgeBaseArticleMaxAggregateOutputType | null
  }

  type GetKnowledgeBaseArticleGroupByPayload<T extends KnowledgeBaseArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeBaseArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeBaseArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeBaseArticleGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeBaseArticleGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeBaseArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    categoryId?: boolean
    authorId?: boolean
    tags?: boolean
    published?: boolean
    views?: boolean
    helpful?: boolean
    notHelpful?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    category?: boolean | KnowledgeBaseCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    versions?: boolean | KnowledgeBaseArticle$versionsArgs<ExtArgs>
    _count?: boolean | KnowledgeBaseArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBaseArticle"]>


  export type KnowledgeBaseArticleSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    categoryId?: boolean
    authorId?: boolean
    tags?: boolean
    published?: boolean
    views?: boolean
    helpful?: boolean
    notHelpful?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
  }

  export type KnowledgeBaseArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | KnowledgeBaseCategoryDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    versions?: boolean | KnowledgeBaseArticle$versionsArgs<ExtArgs>
    _count?: boolean | KnowledgeBaseArticleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $KnowledgeBaseArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeBaseArticle"
    objects: {
      category: Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      versions: Prisma.$ArticleVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      content: string
      excerpt: string | null
      categoryId: string
      authorId: string
      tags: Prisma.JsonValue
      published: boolean
      views: number
      helpful: number
      notHelpful: number
      createdAt: Date
      updatedAt: Date
      publishedAt: Date | null
    }, ExtArgs["result"]["knowledgeBaseArticle"]>
    composites: {}
  }

  type KnowledgeBaseArticleGetPayload<S extends boolean | null | undefined | KnowledgeBaseArticleDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeBaseArticlePayload, S>

  type KnowledgeBaseArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KnowledgeBaseArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KnowledgeBaseArticleCountAggregateInputType | true
    }

  export interface KnowledgeBaseArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeBaseArticle'], meta: { name: 'KnowledgeBaseArticle' } }
    /**
     * Find zero or one KnowledgeBaseArticle that matches the filter.
     * @param {KnowledgeBaseArticleFindUniqueArgs} args - Arguments to find a KnowledgeBaseArticle
     * @example
     * // Get one KnowledgeBaseArticle
     * const knowledgeBaseArticle = await prisma.knowledgeBaseArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeBaseArticleFindUniqueArgs>(args: SelectSubset<T, KnowledgeBaseArticleFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeBaseArticleClient<$Result.GetResult<Prisma.$KnowledgeBaseArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KnowledgeBaseArticle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KnowledgeBaseArticleFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeBaseArticle
     * @example
     * // Get one KnowledgeBaseArticle
     * const knowledgeBaseArticle = await prisma.knowledgeBaseArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeBaseArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeBaseArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseArticleClient<$Result.GetResult<Prisma.$KnowledgeBaseArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KnowledgeBaseArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseArticleFindFirstArgs} args - Arguments to find a KnowledgeBaseArticle
     * @example
     * // Get one KnowledgeBaseArticle
     * const knowledgeBaseArticle = await prisma.knowledgeBaseArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeBaseArticleFindFirstArgs>(args?: SelectSubset<T, KnowledgeBaseArticleFindFirstArgs<ExtArgs>>): Prisma__KnowledgeBaseArticleClient<$Result.GetResult<Prisma.$KnowledgeBaseArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KnowledgeBaseArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseArticleFindFirstOrThrowArgs} args - Arguments to find a KnowledgeBaseArticle
     * @example
     * // Get one KnowledgeBaseArticle
     * const knowledgeBaseArticle = await prisma.knowledgeBaseArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeBaseArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeBaseArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseArticleClient<$Result.GetResult<Prisma.$KnowledgeBaseArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KnowledgeBaseArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeBaseArticles
     * const knowledgeBaseArticles = await prisma.knowledgeBaseArticle.findMany()
     * 
     * // Get first 10 KnowledgeBaseArticles
     * const knowledgeBaseArticles = await prisma.knowledgeBaseArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeBaseArticleWithIdOnly = await prisma.knowledgeBaseArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeBaseArticleFindManyArgs>(args?: SelectSubset<T, KnowledgeBaseArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KnowledgeBaseArticle.
     * @param {KnowledgeBaseArticleCreateArgs} args - Arguments to create a KnowledgeBaseArticle.
     * @example
     * // Create one KnowledgeBaseArticle
     * const KnowledgeBaseArticle = await prisma.knowledgeBaseArticle.create({
     *   data: {
     *     // ... data to create a KnowledgeBaseArticle
     *   }
     * })
     * 
     */
    create<T extends KnowledgeBaseArticleCreateArgs>(args: SelectSubset<T, KnowledgeBaseArticleCreateArgs<ExtArgs>>): Prisma__KnowledgeBaseArticleClient<$Result.GetResult<Prisma.$KnowledgeBaseArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KnowledgeBaseArticles.
     * @param {KnowledgeBaseArticleCreateManyArgs} args - Arguments to create many KnowledgeBaseArticles.
     * @example
     * // Create many KnowledgeBaseArticles
     * const knowledgeBaseArticle = await prisma.knowledgeBaseArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeBaseArticleCreateManyArgs>(args?: SelectSubset<T, KnowledgeBaseArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KnowledgeBaseArticle.
     * @param {KnowledgeBaseArticleDeleteArgs} args - Arguments to delete one KnowledgeBaseArticle.
     * @example
     * // Delete one KnowledgeBaseArticle
     * const KnowledgeBaseArticle = await prisma.knowledgeBaseArticle.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeBaseArticle
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeBaseArticleDeleteArgs>(args: SelectSubset<T, KnowledgeBaseArticleDeleteArgs<ExtArgs>>): Prisma__KnowledgeBaseArticleClient<$Result.GetResult<Prisma.$KnowledgeBaseArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KnowledgeBaseArticle.
     * @param {KnowledgeBaseArticleUpdateArgs} args - Arguments to update one KnowledgeBaseArticle.
     * @example
     * // Update one KnowledgeBaseArticle
     * const knowledgeBaseArticle = await prisma.knowledgeBaseArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeBaseArticleUpdateArgs>(args: SelectSubset<T, KnowledgeBaseArticleUpdateArgs<ExtArgs>>): Prisma__KnowledgeBaseArticleClient<$Result.GetResult<Prisma.$KnowledgeBaseArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KnowledgeBaseArticles.
     * @param {KnowledgeBaseArticleDeleteManyArgs} args - Arguments to filter KnowledgeBaseArticles to delete.
     * @example
     * // Delete a few KnowledgeBaseArticles
     * const { count } = await prisma.knowledgeBaseArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeBaseArticleDeleteManyArgs>(args?: SelectSubset<T, KnowledgeBaseArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBaseArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeBaseArticles
     * const knowledgeBaseArticle = await prisma.knowledgeBaseArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeBaseArticleUpdateManyArgs>(args: SelectSubset<T, KnowledgeBaseArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KnowledgeBaseArticle.
     * @param {KnowledgeBaseArticleUpsertArgs} args - Arguments to update or create a KnowledgeBaseArticle.
     * @example
     * // Update or create a KnowledgeBaseArticle
     * const knowledgeBaseArticle = await prisma.knowledgeBaseArticle.upsert({
     *   create: {
     *     // ... data to create a KnowledgeBaseArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeBaseArticle we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeBaseArticleUpsertArgs>(args: SelectSubset<T, KnowledgeBaseArticleUpsertArgs<ExtArgs>>): Prisma__KnowledgeBaseArticleClient<$Result.GetResult<Prisma.$KnowledgeBaseArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KnowledgeBaseArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseArticleCountArgs} args - Arguments to filter KnowledgeBaseArticles to count.
     * @example
     * // Count the number of KnowledgeBaseArticles
     * const count = await prisma.knowledgeBaseArticle.count({
     *   where: {
     *     // ... the filter for the KnowledgeBaseArticles we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeBaseArticleCountArgs>(
      args?: Subset<T, KnowledgeBaseArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeBaseArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeBaseArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeBaseArticleAggregateArgs>(args: Subset<T, KnowledgeBaseArticleAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeBaseArticleAggregateType<T>>

    /**
     * Group by KnowledgeBaseArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeBaseArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeBaseArticleGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeBaseArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeBaseArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeBaseArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeBaseArticle model
   */
  readonly fields: KnowledgeBaseArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeBaseArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeBaseArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends KnowledgeBaseCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBaseCategoryDefaultArgs<ExtArgs>>): Prisma__KnowledgeBaseCategoryClient<$Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    versions<T extends KnowledgeBaseArticle$versionsArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBaseArticle$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeBaseArticle model
   */ 
  interface KnowledgeBaseArticleFieldRefs {
    readonly id: FieldRef<"KnowledgeBaseArticle", 'String'>
    readonly title: FieldRef<"KnowledgeBaseArticle", 'String'>
    readonly slug: FieldRef<"KnowledgeBaseArticle", 'String'>
    readonly content: FieldRef<"KnowledgeBaseArticle", 'String'>
    readonly excerpt: FieldRef<"KnowledgeBaseArticle", 'String'>
    readonly categoryId: FieldRef<"KnowledgeBaseArticle", 'String'>
    readonly authorId: FieldRef<"KnowledgeBaseArticle", 'String'>
    readonly tags: FieldRef<"KnowledgeBaseArticle", 'Json'>
    readonly published: FieldRef<"KnowledgeBaseArticle", 'Boolean'>
    readonly views: FieldRef<"KnowledgeBaseArticle", 'Int'>
    readonly helpful: FieldRef<"KnowledgeBaseArticle", 'Int'>
    readonly notHelpful: FieldRef<"KnowledgeBaseArticle", 'Int'>
    readonly createdAt: FieldRef<"KnowledgeBaseArticle", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeBaseArticle", 'DateTime'>
    readonly publishedAt: FieldRef<"KnowledgeBaseArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeBaseArticle findUnique
   */
  export type KnowledgeBaseArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticle
     */
    select?: KnowledgeBaseArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseArticle to fetch.
     */
    where: KnowledgeBaseArticleWhereUniqueInput
  }

  /**
   * KnowledgeBaseArticle findUniqueOrThrow
   */
  export type KnowledgeBaseArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticle
     */
    select?: KnowledgeBaseArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseArticle to fetch.
     */
    where: KnowledgeBaseArticleWhereUniqueInput
  }

  /**
   * KnowledgeBaseArticle findFirst
   */
  export type KnowledgeBaseArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticle
     */
    select?: KnowledgeBaseArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseArticle to fetch.
     */
    where?: KnowledgeBaseArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseArticles to fetch.
     */
    orderBy?: KnowledgeBaseArticleOrderByWithRelationInput | KnowledgeBaseArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBaseArticles.
     */
    cursor?: KnowledgeBaseArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBaseArticles.
     */
    distinct?: KnowledgeBaseArticleScalarFieldEnum | KnowledgeBaseArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseArticle findFirstOrThrow
   */
  export type KnowledgeBaseArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticle
     */
    select?: KnowledgeBaseArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseArticle to fetch.
     */
    where?: KnowledgeBaseArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseArticles to fetch.
     */
    orderBy?: KnowledgeBaseArticleOrderByWithRelationInput | KnowledgeBaseArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBaseArticles.
     */
    cursor?: KnowledgeBaseArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBaseArticles.
     */
    distinct?: KnowledgeBaseArticleScalarFieldEnum | KnowledgeBaseArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseArticle findMany
   */
  export type KnowledgeBaseArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticle
     */
    select?: KnowledgeBaseArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseArticleInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseArticles to fetch.
     */
    where?: KnowledgeBaseArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseArticles to fetch.
     */
    orderBy?: KnowledgeBaseArticleOrderByWithRelationInput | KnowledgeBaseArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeBaseArticles.
     */
    cursor?: KnowledgeBaseArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseArticles.
     */
    skip?: number
    distinct?: KnowledgeBaseArticleScalarFieldEnum | KnowledgeBaseArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseArticle create
   */
  export type KnowledgeBaseArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticle
     */
    select?: KnowledgeBaseArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeBaseArticle.
     */
    data: XOR<KnowledgeBaseArticleCreateInput, KnowledgeBaseArticleUncheckedCreateInput>
  }

  /**
   * KnowledgeBaseArticle createMany
   */
  export type KnowledgeBaseArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeBaseArticles.
     */
    data: KnowledgeBaseArticleCreateManyInput | KnowledgeBaseArticleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeBaseArticle update
   */
  export type KnowledgeBaseArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticle
     */
    select?: KnowledgeBaseArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeBaseArticle.
     */
    data: XOR<KnowledgeBaseArticleUpdateInput, KnowledgeBaseArticleUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeBaseArticle to update.
     */
    where: KnowledgeBaseArticleWhereUniqueInput
  }

  /**
   * KnowledgeBaseArticle updateMany
   */
  export type KnowledgeBaseArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeBaseArticles.
     */
    data: XOR<KnowledgeBaseArticleUpdateManyMutationInput, KnowledgeBaseArticleUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBaseArticles to update
     */
    where?: KnowledgeBaseArticleWhereInput
  }

  /**
   * KnowledgeBaseArticle upsert
   */
  export type KnowledgeBaseArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticle
     */
    select?: KnowledgeBaseArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeBaseArticle to update in case it exists.
     */
    where: KnowledgeBaseArticleWhereUniqueInput
    /**
     * In case the KnowledgeBaseArticle found by the `where` argument doesn't exist, create a new KnowledgeBaseArticle with this data.
     */
    create: XOR<KnowledgeBaseArticleCreateInput, KnowledgeBaseArticleUncheckedCreateInput>
    /**
     * In case the KnowledgeBaseArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeBaseArticleUpdateInput, KnowledgeBaseArticleUncheckedUpdateInput>
  }

  /**
   * KnowledgeBaseArticle delete
   */
  export type KnowledgeBaseArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticle
     */
    select?: KnowledgeBaseArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseArticleInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeBaseArticle to delete.
     */
    where: KnowledgeBaseArticleWhereUniqueInput
  }

  /**
   * KnowledgeBaseArticle deleteMany
   */
  export type KnowledgeBaseArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBaseArticles to delete
     */
    where?: KnowledgeBaseArticleWhereInput
  }

  /**
   * KnowledgeBaseArticle.versions
   */
  export type KnowledgeBaseArticle$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    where?: ArticleVersionWhereInput
    orderBy?: ArticleVersionOrderByWithRelationInput | ArticleVersionOrderByWithRelationInput[]
    cursor?: ArticleVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleVersionScalarFieldEnum | ArticleVersionScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseArticle without action
   */
  export type KnowledgeBaseArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticle
     */
    select?: KnowledgeBaseArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseArticleInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeBaseCategory
   */

  export type AggregateKnowledgeBaseCategory = {
    _count: KnowledgeBaseCategoryCountAggregateOutputType | null
    _avg: KnowledgeBaseCategoryAvgAggregateOutputType | null
    _sum: KnowledgeBaseCategorySumAggregateOutputType | null
    _min: KnowledgeBaseCategoryMinAggregateOutputType | null
    _max: KnowledgeBaseCategoryMaxAggregateOutputType | null
  }

  export type KnowledgeBaseCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type KnowledgeBaseCategorySumAggregateOutputType = {
    order: number | null
  }

  export type KnowledgeBaseCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    order: number | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeBaseCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    order: number | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeBaseCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    icon: number
    order: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeBaseCategoryAvgAggregateInputType = {
    order?: true
  }

  export type KnowledgeBaseCategorySumAggregateInputType = {
    order?: true
  }

  export type KnowledgeBaseCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    order?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeBaseCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    order?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeBaseCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    order?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeBaseCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBaseCategory to aggregate.
     */
    where?: KnowledgeBaseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseCategories to fetch.
     */
    orderBy?: KnowledgeBaseCategoryOrderByWithRelationInput | KnowledgeBaseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeBaseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeBaseCategories
    **/
    _count?: true | KnowledgeBaseCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeBaseCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeBaseCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeBaseCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeBaseCategoryMaxAggregateInputType
  }

  export type GetKnowledgeBaseCategoryAggregateType<T extends KnowledgeBaseCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeBaseCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeBaseCategory[P]>
      : GetScalarType<T[P], AggregateKnowledgeBaseCategory[P]>
  }




  export type KnowledgeBaseCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeBaseCategoryWhereInput
    orderBy?: KnowledgeBaseCategoryOrderByWithAggregationInput | KnowledgeBaseCategoryOrderByWithAggregationInput[]
    by: KnowledgeBaseCategoryScalarFieldEnum[] | KnowledgeBaseCategoryScalarFieldEnum
    having?: KnowledgeBaseCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeBaseCategoryCountAggregateInputType | true
    _avg?: KnowledgeBaseCategoryAvgAggregateInputType
    _sum?: KnowledgeBaseCategorySumAggregateInputType
    _min?: KnowledgeBaseCategoryMinAggregateInputType
    _max?: KnowledgeBaseCategoryMaxAggregateInputType
  }

  export type KnowledgeBaseCategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    icon: string | null
    order: number
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeBaseCategoryCountAggregateOutputType | null
    _avg: KnowledgeBaseCategoryAvgAggregateOutputType | null
    _sum: KnowledgeBaseCategorySumAggregateOutputType | null
    _min: KnowledgeBaseCategoryMinAggregateOutputType | null
    _max: KnowledgeBaseCategoryMaxAggregateOutputType | null
  }

  type GetKnowledgeBaseCategoryGroupByPayload<T extends KnowledgeBaseCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeBaseCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeBaseCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeBaseCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeBaseCategoryGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeBaseCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | KnowledgeBaseCategory$parentArgs<ExtArgs>
    children?: boolean | KnowledgeBaseCategory$childrenArgs<ExtArgs>
    articles?: boolean | KnowledgeBaseCategory$articlesArgs<ExtArgs>
    _count?: boolean | KnowledgeBaseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeBaseCategory"]>


  export type KnowledgeBaseCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeBaseCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | KnowledgeBaseCategory$parentArgs<ExtArgs>
    children?: boolean | KnowledgeBaseCategory$childrenArgs<ExtArgs>
    articles?: boolean | KnowledgeBaseCategory$articlesArgs<ExtArgs>
    _count?: boolean | KnowledgeBaseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $KnowledgeBaseCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeBaseCategory"
    objects: {
      parent: Prisma.$KnowledgeBaseCategoryPayload<ExtArgs> | null
      children: Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>[]
      articles: Prisma.$KnowledgeBaseArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      icon: string | null
      order: number
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledgeBaseCategory"]>
    composites: {}
  }

  type KnowledgeBaseCategoryGetPayload<S extends boolean | null | undefined | KnowledgeBaseCategoryDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload, S>

  type KnowledgeBaseCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KnowledgeBaseCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KnowledgeBaseCategoryCountAggregateInputType | true
    }

  export interface KnowledgeBaseCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeBaseCategory'], meta: { name: 'KnowledgeBaseCategory' } }
    /**
     * Find zero or one KnowledgeBaseCategory that matches the filter.
     * @param {KnowledgeBaseCategoryFindUniqueArgs} args - Arguments to find a KnowledgeBaseCategory
     * @example
     * // Get one KnowledgeBaseCategory
     * const knowledgeBaseCategory = await prisma.knowledgeBaseCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeBaseCategoryFindUniqueArgs>(args: SelectSubset<T, KnowledgeBaseCategoryFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeBaseCategoryClient<$Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KnowledgeBaseCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KnowledgeBaseCategoryFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeBaseCategory
     * @example
     * // Get one KnowledgeBaseCategory
     * const knowledgeBaseCategory = await prisma.knowledgeBaseCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeBaseCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeBaseCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseCategoryClient<$Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KnowledgeBaseCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseCategoryFindFirstArgs} args - Arguments to find a KnowledgeBaseCategory
     * @example
     * // Get one KnowledgeBaseCategory
     * const knowledgeBaseCategory = await prisma.knowledgeBaseCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeBaseCategoryFindFirstArgs>(args?: SelectSubset<T, KnowledgeBaseCategoryFindFirstArgs<ExtArgs>>): Prisma__KnowledgeBaseCategoryClient<$Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KnowledgeBaseCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseCategoryFindFirstOrThrowArgs} args - Arguments to find a KnowledgeBaseCategory
     * @example
     * // Get one KnowledgeBaseCategory
     * const knowledgeBaseCategory = await prisma.knowledgeBaseCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeBaseCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeBaseCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeBaseCategoryClient<$Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KnowledgeBaseCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeBaseCategories
     * const knowledgeBaseCategories = await prisma.knowledgeBaseCategory.findMany()
     * 
     * // Get first 10 KnowledgeBaseCategories
     * const knowledgeBaseCategories = await prisma.knowledgeBaseCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeBaseCategoryWithIdOnly = await prisma.knowledgeBaseCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeBaseCategoryFindManyArgs>(args?: SelectSubset<T, KnowledgeBaseCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KnowledgeBaseCategory.
     * @param {KnowledgeBaseCategoryCreateArgs} args - Arguments to create a KnowledgeBaseCategory.
     * @example
     * // Create one KnowledgeBaseCategory
     * const KnowledgeBaseCategory = await prisma.knowledgeBaseCategory.create({
     *   data: {
     *     // ... data to create a KnowledgeBaseCategory
     *   }
     * })
     * 
     */
    create<T extends KnowledgeBaseCategoryCreateArgs>(args: SelectSubset<T, KnowledgeBaseCategoryCreateArgs<ExtArgs>>): Prisma__KnowledgeBaseCategoryClient<$Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KnowledgeBaseCategories.
     * @param {KnowledgeBaseCategoryCreateManyArgs} args - Arguments to create many KnowledgeBaseCategories.
     * @example
     * // Create many KnowledgeBaseCategories
     * const knowledgeBaseCategory = await prisma.knowledgeBaseCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeBaseCategoryCreateManyArgs>(args?: SelectSubset<T, KnowledgeBaseCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KnowledgeBaseCategory.
     * @param {KnowledgeBaseCategoryDeleteArgs} args - Arguments to delete one KnowledgeBaseCategory.
     * @example
     * // Delete one KnowledgeBaseCategory
     * const KnowledgeBaseCategory = await prisma.knowledgeBaseCategory.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeBaseCategory
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeBaseCategoryDeleteArgs>(args: SelectSubset<T, KnowledgeBaseCategoryDeleteArgs<ExtArgs>>): Prisma__KnowledgeBaseCategoryClient<$Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KnowledgeBaseCategory.
     * @param {KnowledgeBaseCategoryUpdateArgs} args - Arguments to update one KnowledgeBaseCategory.
     * @example
     * // Update one KnowledgeBaseCategory
     * const knowledgeBaseCategory = await prisma.knowledgeBaseCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeBaseCategoryUpdateArgs>(args: SelectSubset<T, KnowledgeBaseCategoryUpdateArgs<ExtArgs>>): Prisma__KnowledgeBaseCategoryClient<$Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KnowledgeBaseCategories.
     * @param {KnowledgeBaseCategoryDeleteManyArgs} args - Arguments to filter KnowledgeBaseCategories to delete.
     * @example
     * // Delete a few KnowledgeBaseCategories
     * const { count } = await prisma.knowledgeBaseCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeBaseCategoryDeleteManyArgs>(args?: SelectSubset<T, KnowledgeBaseCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeBaseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeBaseCategories
     * const knowledgeBaseCategory = await prisma.knowledgeBaseCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeBaseCategoryUpdateManyArgs>(args: SelectSubset<T, KnowledgeBaseCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KnowledgeBaseCategory.
     * @param {KnowledgeBaseCategoryUpsertArgs} args - Arguments to update or create a KnowledgeBaseCategory.
     * @example
     * // Update or create a KnowledgeBaseCategory
     * const knowledgeBaseCategory = await prisma.knowledgeBaseCategory.upsert({
     *   create: {
     *     // ... data to create a KnowledgeBaseCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeBaseCategory we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeBaseCategoryUpsertArgs>(args: SelectSubset<T, KnowledgeBaseCategoryUpsertArgs<ExtArgs>>): Prisma__KnowledgeBaseCategoryClient<$Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KnowledgeBaseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseCategoryCountArgs} args - Arguments to filter KnowledgeBaseCategories to count.
     * @example
     * // Count the number of KnowledgeBaseCategories
     * const count = await prisma.knowledgeBaseCategory.count({
     *   where: {
     *     // ... the filter for the KnowledgeBaseCategories we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeBaseCategoryCountArgs>(
      args?: Subset<T, KnowledgeBaseCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeBaseCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeBaseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeBaseCategoryAggregateArgs>(args: Subset<T, KnowledgeBaseCategoryAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeBaseCategoryAggregateType<T>>

    /**
     * Group by KnowledgeBaseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeBaseCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeBaseCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeBaseCategoryGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeBaseCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeBaseCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeBaseCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeBaseCategory model
   */
  readonly fields: KnowledgeBaseCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeBaseCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeBaseCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends KnowledgeBaseCategory$parentArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBaseCategory$parentArgs<ExtArgs>>): Prisma__KnowledgeBaseCategoryClient<$Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends KnowledgeBaseCategory$childrenArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBaseCategory$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    articles<T extends KnowledgeBaseCategory$articlesArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBaseCategory$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeBaseArticlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeBaseCategory model
   */ 
  interface KnowledgeBaseCategoryFieldRefs {
    readonly id: FieldRef<"KnowledgeBaseCategory", 'String'>
    readonly name: FieldRef<"KnowledgeBaseCategory", 'String'>
    readonly slug: FieldRef<"KnowledgeBaseCategory", 'String'>
    readonly description: FieldRef<"KnowledgeBaseCategory", 'String'>
    readonly icon: FieldRef<"KnowledgeBaseCategory", 'String'>
    readonly order: FieldRef<"KnowledgeBaseCategory", 'Int'>
    readonly parentId: FieldRef<"KnowledgeBaseCategory", 'String'>
    readonly createdAt: FieldRef<"KnowledgeBaseCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeBaseCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeBaseCategory findUnique
   */
  export type KnowledgeBaseCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategory
     */
    select?: KnowledgeBaseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseCategory to fetch.
     */
    where: KnowledgeBaseCategoryWhereUniqueInput
  }

  /**
   * KnowledgeBaseCategory findUniqueOrThrow
   */
  export type KnowledgeBaseCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategory
     */
    select?: KnowledgeBaseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseCategory to fetch.
     */
    where: KnowledgeBaseCategoryWhereUniqueInput
  }

  /**
   * KnowledgeBaseCategory findFirst
   */
  export type KnowledgeBaseCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategory
     */
    select?: KnowledgeBaseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseCategory to fetch.
     */
    where?: KnowledgeBaseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseCategories to fetch.
     */
    orderBy?: KnowledgeBaseCategoryOrderByWithRelationInput | KnowledgeBaseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBaseCategories.
     */
    cursor?: KnowledgeBaseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBaseCategories.
     */
    distinct?: KnowledgeBaseCategoryScalarFieldEnum | KnowledgeBaseCategoryScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseCategory findFirstOrThrow
   */
  export type KnowledgeBaseCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategory
     */
    select?: KnowledgeBaseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseCategory to fetch.
     */
    where?: KnowledgeBaseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseCategories to fetch.
     */
    orderBy?: KnowledgeBaseCategoryOrderByWithRelationInput | KnowledgeBaseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeBaseCategories.
     */
    cursor?: KnowledgeBaseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeBaseCategories.
     */
    distinct?: KnowledgeBaseCategoryScalarFieldEnum | KnowledgeBaseCategoryScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseCategory findMany
   */
  export type KnowledgeBaseCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategory
     */
    select?: KnowledgeBaseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeBaseCategories to fetch.
     */
    where?: KnowledgeBaseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeBaseCategories to fetch.
     */
    orderBy?: KnowledgeBaseCategoryOrderByWithRelationInput | KnowledgeBaseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeBaseCategories.
     */
    cursor?: KnowledgeBaseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeBaseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeBaseCategories.
     */
    skip?: number
    distinct?: KnowledgeBaseCategoryScalarFieldEnum | KnowledgeBaseCategoryScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseCategory create
   */
  export type KnowledgeBaseCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategory
     */
    select?: KnowledgeBaseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeBaseCategory.
     */
    data: XOR<KnowledgeBaseCategoryCreateInput, KnowledgeBaseCategoryUncheckedCreateInput>
  }

  /**
   * KnowledgeBaseCategory createMany
   */
  export type KnowledgeBaseCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeBaseCategories.
     */
    data: KnowledgeBaseCategoryCreateManyInput | KnowledgeBaseCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeBaseCategory update
   */
  export type KnowledgeBaseCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategory
     */
    select?: KnowledgeBaseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeBaseCategory.
     */
    data: XOR<KnowledgeBaseCategoryUpdateInput, KnowledgeBaseCategoryUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeBaseCategory to update.
     */
    where: KnowledgeBaseCategoryWhereUniqueInput
  }

  /**
   * KnowledgeBaseCategory updateMany
   */
  export type KnowledgeBaseCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeBaseCategories.
     */
    data: XOR<KnowledgeBaseCategoryUpdateManyMutationInput, KnowledgeBaseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeBaseCategories to update
     */
    where?: KnowledgeBaseCategoryWhereInput
  }

  /**
   * KnowledgeBaseCategory upsert
   */
  export type KnowledgeBaseCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategory
     */
    select?: KnowledgeBaseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeBaseCategory to update in case it exists.
     */
    where: KnowledgeBaseCategoryWhereUniqueInput
    /**
     * In case the KnowledgeBaseCategory found by the `where` argument doesn't exist, create a new KnowledgeBaseCategory with this data.
     */
    create: XOR<KnowledgeBaseCategoryCreateInput, KnowledgeBaseCategoryUncheckedCreateInput>
    /**
     * In case the KnowledgeBaseCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeBaseCategoryUpdateInput, KnowledgeBaseCategoryUncheckedUpdateInput>
  }

  /**
   * KnowledgeBaseCategory delete
   */
  export type KnowledgeBaseCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategory
     */
    select?: KnowledgeBaseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseCategoryInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeBaseCategory to delete.
     */
    where: KnowledgeBaseCategoryWhereUniqueInput
  }

  /**
   * KnowledgeBaseCategory deleteMany
   */
  export type KnowledgeBaseCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeBaseCategories to delete
     */
    where?: KnowledgeBaseCategoryWhereInput
  }

  /**
   * KnowledgeBaseCategory.parent
   */
  export type KnowledgeBaseCategory$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategory
     */
    select?: KnowledgeBaseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseCategoryInclude<ExtArgs> | null
    where?: KnowledgeBaseCategoryWhereInput
  }

  /**
   * KnowledgeBaseCategory.children
   */
  export type KnowledgeBaseCategory$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategory
     */
    select?: KnowledgeBaseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseCategoryInclude<ExtArgs> | null
    where?: KnowledgeBaseCategoryWhereInput
    orderBy?: KnowledgeBaseCategoryOrderByWithRelationInput | KnowledgeBaseCategoryOrderByWithRelationInput[]
    cursor?: KnowledgeBaseCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeBaseCategoryScalarFieldEnum | KnowledgeBaseCategoryScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseCategory.articles
   */
  export type KnowledgeBaseCategory$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseArticle
     */
    select?: KnowledgeBaseArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseArticleInclude<ExtArgs> | null
    where?: KnowledgeBaseArticleWhereInput
    orderBy?: KnowledgeBaseArticleOrderByWithRelationInput | KnowledgeBaseArticleOrderByWithRelationInput[]
    cursor?: KnowledgeBaseArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeBaseArticleScalarFieldEnum | KnowledgeBaseArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeBaseCategory without action
   */
  export type KnowledgeBaseCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeBaseCategory
     */
    select?: KnowledgeBaseCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeBaseCategoryInclude<ExtArgs> | null
  }


  /**
   * Model ArticleVersion
   */

  export type AggregateArticleVersion = {
    _count: ArticleVersionCountAggregateOutputType | null
    _avg: ArticleVersionAvgAggregateOutputType | null
    _sum: ArticleVersionSumAggregateOutputType | null
    _min: ArticleVersionMinAggregateOutputType | null
    _max: ArticleVersionMaxAggregateOutputType | null
  }

  export type ArticleVersionAvgAggregateOutputType = {
    version: number | null
  }

  export type ArticleVersionSumAggregateOutputType = {
    version: number | null
  }

  export type ArticleVersionMinAggregateOutputType = {
    id: string | null
    articleId: string | null
    version: number | null
    title: string | null
    content: string | null
    excerpt: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type ArticleVersionMaxAggregateOutputType = {
    id: string | null
    articleId: string | null
    version: number | null
    title: string | null
    content: string | null
    excerpt: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type ArticleVersionCountAggregateOutputType = {
    id: number
    articleId: number
    version: number
    title: number
    content: number
    excerpt: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type ArticleVersionAvgAggregateInputType = {
    version?: true
  }

  export type ArticleVersionSumAggregateInputType = {
    version?: true
  }

  export type ArticleVersionMinAggregateInputType = {
    id?: true
    articleId?: true
    version?: true
    title?: true
    content?: true
    excerpt?: true
    createdBy?: true
    createdAt?: true
  }

  export type ArticleVersionMaxAggregateInputType = {
    id?: true
    articleId?: true
    version?: true
    title?: true
    content?: true
    excerpt?: true
    createdBy?: true
    createdAt?: true
  }

  export type ArticleVersionCountAggregateInputType = {
    id?: true
    articleId?: true
    version?: true
    title?: true
    content?: true
    excerpt?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type ArticleVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleVersion to aggregate.
     */
    where?: ArticleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleVersions to fetch.
     */
    orderBy?: ArticleVersionOrderByWithRelationInput | ArticleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticleVersions
    **/
    _count?: true | ArticleVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleVersionMaxAggregateInputType
  }

  export type GetArticleVersionAggregateType<T extends ArticleVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleVersion[P]>
      : GetScalarType<T[P], AggregateArticleVersion[P]>
  }




  export type ArticleVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleVersionWhereInput
    orderBy?: ArticleVersionOrderByWithAggregationInput | ArticleVersionOrderByWithAggregationInput[]
    by: ArticleVersionScalarFieldEnum[] | ArticleVersionScalarFieldEnum
    having?: ArticleVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleVersionCountAggregateInputType | true
    _avg?: ArticleVersionAvgAggregateInputType
    _sum?: ArticleVersionSumAggregateInputType
    _min?: ArticleVersionMinAggregateInputType
    _max?: ArticleVersionMaxAggregateInputType
  }

  export type ArticleVersionGroupByOutputType = {
    id: string
    articleId: string
    version: number
    title: string
    content: string
    excerpt: string | null
    createdBy: string
    createdAt: Date
    _count: ArticleVersionCountAggregateOutputType | null
    _avg: ArticleVersionAvgAggregateOutputType | null
    _sum: ArticleVersionSumAggregateOutputType | null
    _min: ArticleVersionMinAggregateOutputType | null
    _max: ArticleVersionMaxAggregateOutputType | null
  }

  type GetArticleVersionGroupByPayload<T extends ArticleVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleVersionGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleVersionGroupByOutputType[P]>
        }
      >
    >


  export type ArticleVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    article?: boolean | KnowledgeBaseArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleVersion"]>


  export type ArticleVersionSelectScalar = {
    id?: boolean
    articleId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type ArticleVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | KnowledgeBaseArticleDefaultArgs<ExtArgs>
  }

  export type $ArticleVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArticleVersion"
    objects: {
      article: Prisma.$KnowledgeBaseArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      articleId: string
      version: number
      title: string
      content: string
      excerpt: string | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["articleVersion"]>
    composites: {}
  }

  type ArticleVersionGetPayload<S extends boolean | null | undefined | ArticleVersionDefaultArgs> = $Result.GetResult<Prisma.$ArticleVersionPayload, S>

  type ArticleVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArticleVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArticleVersionCountAggregateInputType | true
    }

  export interface ArticleVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArticleVersion'], meta: { name: 'ArticleVersion' } }
    /**
     * Find zero or one ArticleVersion that matches the filter.
     * @param {ArticleVersionFindUniqueArgs} args - Arguments to find a ArticleVersion
     * @example
     * // Get one ArticleVersion
     * const articleVersion = await prisma.articleVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleVersionFindUniqueArgs>(args: SelectSubset<T, ArticleVersionFindUniqueArgs<ExtArgs>>): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ArticleVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ArticleVersionFindUniqueOrThrowArgs} args - Arguments to find a ArticleVersion
     * @example
     * // Get one ArticleVersion
     * const articleVersion = await prisma.articleVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, ArticleVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ArticleVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionFindFirstArgs} args - Arguments to find a ArticleVersion
     * @example
     * // Get one ArticleVersion
     * const articleVersion = await prisma.articleVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleVersionFindFirstArgs>(args?: SelectSubset<T, ArticleVersionFindFirstArgs<ExtArgs>>): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ArticleVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionFindFirstOrThrowArgs} args - Arguments to find a ArticleVersion
     * @example
     * // Get one ArticleVersion
     * const articleVersion = await prisma.articleVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, ArticleVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ArticleVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleVersions
     * const articleVersions = await prisma.articleVersion.findMany()
     * 
     * // Get first 10 ArticleVersions
     * const articleVersions = await prisma.articleVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleVersionWithIdOnly = await prisma.articleVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArticleVersionFindManyArgs>(args?: SelectSubset<T, ArticleVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ArticleVersion.
     * @param {ArticleVersionCreateArgs} args - Arguments to create a ArticleVersion.
     * @example
     * // Create one ArticleVersion
     * const ArticleVersion = await prisma.articleVersion.create({
     *   data: {
     *     // ... data to create a ArticleVersion
     *   }
     * })
     * 
     */
    create<T extends ArticleVersionCreateArgs>(args: SelectSubset<T, ArticleVersionCreateArgs<ExtArgs>>): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ArticleVersions.
     * @param {ArticleVersionCreateManyArgs} args - Arguments to create many ArticleVersions.
     * @example
     * // Create many ArticleVersions
     * const articleVersion = await prisma.articleVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArticleVersionCreateManyArgs>(args?: SelectSubset<T, ArticleVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ArticleVersion.
     * @param {ArticleVersionDeleteArgs} args - Arguments to delete one ArticleVersion.
     * @example
     * // Delete one ArticleVersion
     * const ArticleVersion = await prisma.articleVersion.delete({
     *   where: {
     *     // ... filter to delete one ArticleVersion
     *   }
     * })
     * 
     */
    delete<T extends ArticleVersionDeleteArgs>(args: SelectSubset<T, ArticleVersionDeleteArgs<ExtArgs>>): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ArticleVersion.
     * @param {ArticleVersionUpdateArgs} args - Arguments to update one ArticleVersion.
     * @example
     * // Update one ArticleVersion
     * const articleVersion = await prisma.articleVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArticleVersionUpdateArgs>(args: SelectSubset<T, ArticleVersionUpdateArgs<ExtArgs>>): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ArticleVersions.
     * @param {ArticleVersionDeleteManyArgs} args - Arguments to filter ArticleVersions to delete.
     * @example
     * // Delete a few ArticleVersions
     * const { count } = await prisma.articleVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArticleVersionDeleteManyArgs>(args?: SelectSubset<T, ArticleVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleVersions
     * const articleVersion = await prisma.articleVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArticleVersionUpdateManyArgs>(args: SelectSubset<T, ArticleVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArticleVersion.
     * @param {ArticleVersionUpsertArgs} args - Arguments to update or create a ArticleVersion.
     * @example
     * // Update or create a ArticleVersion
     * const articleVersion = await prisma.articleVersion.upsert({
     *   create: {
     *     // ... data to create a ArticleVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleVersion we want to update
     *   }
     * })
     */
    upsert<T extends ArticleVersionUpsertArgs>(args: SelectSubset<T, ArticleVersionUpsertArgs<ExtArgs>>): Prisma__ArticleVersionClient<$Result.GetResult<Prisma.$ArticleVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ArticleVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionCountArgs} args - Arguments to filter ArticleVersions to count.
     * @example
     * // Count the number of ArticleVersions
     * const count = await prisma.articleVersion.count({
     *   where: {
     *     // ... the filter for the ArticleVersions we want to count
     *   }
     * })
    **/
    count<T extends ArticleVersionCountArgs>(
      args?: Subset<T, ArticleVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleVersionAggregateArgs>(args: Subset<T, ArticleVersionAggregateArgs>): Prisma.PrismaPromise<GetArticleVersionAggregateType<T>>

    /**
     * Group by ArticleVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleVersionGroupByArgs['orderBy'] }
        : { orderBy?: ArticleVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArticleVersion model
   */
  readonly fields: ArticleVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends KnowledgeBaseArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeBaseArticleDefaultArgs<ExtArgs>>): Prisma__KnowledgeBaseArticleClient<$Result.GetResult<Prisma.$KnowledgeBaseArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArticleVersion model
   */ 
  interface ArticleVersionFieldRefs {
    readonly id: FieldRef<"ArticleVersion", 'String'>
    readonly articleId: FieldRef<"ArticleVersion", 'String'>
    readonly version: FieldRef<"ArticleVersion", 'Int'>
    readonly title: FieldRef<"ArticleVersion", 'String'>
    readonly content: FieldRef<"ArticleVersion", 'String'>
    readonly excerpt: FieldRef<"ArticleVersion", 'String'>
    readonly createdBy: FieldRef<"ArticleVersion", 'String'>
    readonly createdAt: FieldRef<"ArticleVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ArticleVersion findUnique
   */
  export type ArticleVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArticleVersion to fetch.
     */
    where: ArticleVersionWhereUniqueInput
  }

  /**
   * ArticleVersion findUniqueOrThrow
   */
  export type ArticleVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArticleVersion to fetch.
     */
    where: ArticleVersionWhereUniqueInput
  }

  /**
   * ArticleVersion findFirst
   */
  export type ArticleVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArticleVersion to fetch.
     */
    where?: ArticleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleVersions to fetch.
     */
    orderBy?: ArticleVersionOrderByWithRelationInput | ArticleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleVersions.
     */
    cursor?: ArticleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleVersions.
     */
    distinct?: ArticleVersionScalarFieldEnum | ArticleVersionScalarFieldEnum[]
  }

  /**
   * ArticleVersion findFirstOrThrow
   */
  export type ArticleVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArticleVersion to fetch.
     */
    where?: ArticleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleVersions to fetch.
     */
    orderBy?: ArticleVersionOrderByWithRelationInput | ArticleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleVersions.
     */
    cursor?: ArticleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleVersions.
     */
    distinct?: ArticleVersionScalarFieldEnum | ArticleVersionScalarFieldEnum[]
  }

  /**
   * ArticleVersion findMany
   */
  export type ArticleVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ArticleVersions to fetch.
     */
    where?: ArticleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleVersions to fetch.
     */
    orderBy?: ArticleVersionOrderByWithRelationInput | ArticleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticleVersions.
     */
    cursor?: ArticleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleVersions.
     */
    skip?: number
    distinct?: ArticleVersionScalarFieldEnum | ArticleVersionScalarFieldEnum[]
  }

  /**
   * ArticleVersion create
   */
  export type ArticleVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a ArticleVersion.
     */
    data: XOR<ArticleVersionCreateInput, ArticleVersionUncheckedCreateInput>
  }

  /**
   * ArticleVersion createMany
   */
  export type ArticleVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArticleVersions.
     */
    data: ArticleVersionCreateManyInput | ArticleVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArticleVersion update
   */
  export type ArticleVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a ArticleVersion.
     */
    data: XOR<ArticleVersionUpdateInput, ArticleVersionUncheckedUpdateInput>
    /**
     * Choose, which ArticleVersion to update.
     */
    where: ArticleVersionWhereUniqueInput
  }

  /**
   * ArticleVersion updateMany
   */
  export type ArticleVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArticleVersions.
     */
    data: XOR<ArticleVersionUpdateManyMutationInput, ArticleVersionUncheckedUpdateManyInput>
    /**
     * Filter which ArticleVersions to update
     */
    where?: ArticleVersionWhereInput
  }

  /**
   * ArticleVersion upsert
   */
  export type ArticleVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the ArticleVersion to update in case it exists.
     */
    where: ArticleVersionWhereUniqueInput
    /**
     * In case the ArticleVersion found by the `where` argument doesn't exist, create a new ArticleVersion with this data.
     */
    create: XOR<ArticleVersionCreateInput, ArticleVersionUncheckedCreateInput>
    /**
     * In case the ArticleVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleVersionUpdateInput, ArticleVersionUncheckedUpdateInput>
  }

  /**
   * ArticleVersion delete
   */
  export type ArticleVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleVersionInclude<ExtArgs> | null
    /**
     * Filter which ArticleVersion to delete.
     */
    where: ArticleVersionWhereUniqueInput
  }

  /**
   * ArticleVersion deleteMany
   */
  export type ArticleVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleVersions to delete
     */
    where?: ArticleVersionWhereInput
  }

  /**
   * ArticleVersion without action
   */
  export type ArticleVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleVersion
     */
    select?: ArticleVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleVersionInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceMetadata
   */

  export type AggregateInvoiceMetadata = {
    _count: InvoiceMetadataCountAggregateOutputType | null
    _avg: InvoiceMetadataAvgAggregateOutputType | null
    _sum: InvoiceMetadataSumAggregateOutputType | null
    _min: InvoiceMetadataMinAggregateOutputType | null
    _max: InvoiceMetadataMaxAggregateOutputType | null
  }

  export type InvoiceMetadataAvgAggregateOutputType = {
    sequenceNumber: number | null
    year: number | null
  }

  export type InvoiceMetadataSumAggregateOutputType = {
    sequenceNumber: number | null
    year: number | null
  }

  export type InvoiceMetadataMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    prefix: string | null
    sequenceNumber: number | null
    lastUsedDate: Date | null
    year: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMetadataMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    prefix: string | null
    sequenceNumber: number | null
    lastUsedDate: Date | null
    year: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMetadataCountAggregateOutputType = {
    id: number
    tenantId: number
    prefix: number
    sequenceNumber: number
    lastUsedDate: number
    year: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceMetadataAvgAggregateInputType = {
    sequenceNumber?: true
    year?: true
  }

  export type InvoiceMetadataSumAggregateInputType = {
    sequenceNumber?: true
    year?: true
  }

  export type InvoiceMetadataMinAggregateInputType = {
    id?: true
    tenantId?: true
    prefix?: true
    sequenceNumber?: true
    lastUsedDate?: true
    year?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMetadataMaxAggregateInputType = {
    id?: true
    tenantId?: true
    prefix?: true
    sequenceNumber?: true
    lastUsedDate?: true
    year?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMetadataCountAggregateInputType = {
    id?: true
    tenantId?: true
    prefix?: true
    sequenceNumber?: true
    lastUsedDate?: true
    year?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceMetadata to aggregate.
     */
    where?: InvoiceMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceMetadata to fetch.
     */
    orderBy?: InvoiceMetadataOrderByWithRelationInput | InvoiceMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceMetadata
    **/
    _count?: true | InvoiceMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceMetadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceMetadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMetadataMaxAggregateInputType
  }

  export type GetInvoiceMetadataAggregateType<T extends InvoiceMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceMetadata[P]>
      : GetScalarType<T[P], AggregateInvoiceMetadata[P]>
  }




  export type InvoiceMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceMetadataWhereInput
    orderBy?: InvoiceMetadataOrderByWithAggregationInput | InvoiceMetadataOrderByWithAggregationInput[]
    by: InvoiceMetadataScalarFieldEnum[] | InvoiceMetadataScalarFieldEnum
    having?: InvoiceMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceMetadataCountAggregateInputType | true
    _avg?: InvoiceMetadataAvgAggregateInputType
    _sum?: InvoiceMetadataSumAggregateInputType
    _min?: InvoiceMetadataMinAggregateInputType
    _max?: InvoiceMetadataMaxAggregateInputType
  }

  export type InvoiceMetadataGroupByOutputType = {
    id: string
    tenantId: string | null
    prefix: string
    sequenceNumber: number
    lastUsedDate: Date
    year: number | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceMetadataCountAggregateOutputType | null
    _avg: InvoiceMetadataAvgAggregateOutputType | null
    _sum: InvoiceMetadataSumAggregateOutputType | null
    _min: InvoiceMetadataMinAggregateOutputType | null
    _max: InvoiceMetadataMaxAggregateOutputType | null
  }

  type GetInvoiceMetadataGroupByPayload<T extends InvoiceMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceMetadataGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    prefix?: boolean
    sequenceNumber?: boolean
    lastUsedDate?: boolean
    year?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["invoiceMetadata"]>


  export type InvoiceMetadataSelectScalar = {
    id?: boolean
    tenantId?: boolean
    prefix?: boolean
    sequenceNumber?: boolean
    lastUsedDate?: boolean
    year?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $InvoiceMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceMetadata"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      prefix: string
      sequenceNumber: number
      lastUsedDate: Date
      year: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoiceMetadata"]>
    composites: {}
  }

  type InvoiceMetadataGetPayload<S extends boolean | null | undefined | InvoiceMetadataDefaultArgs> = $Result.GetResult<Prisma.$InvoiceMetadataPayload, S>

  type InvoiceMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceMetadataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceMetadataCountAggregateInputType | true
    }

  export interface InvoiceMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceMetadata'], meta: { name: 'InvoiceMetadata' } }
    /**
     * Find zero or one InvoiceMetadata that matches the filter.
     * @param {InvoiceMetadataFindUniqueArgs} args - Arguments to find a InvoiceMetadata
     * @example
     * // Get one InvoiceMetadata
     * const invoiceMetadata = await prisma.invoiceMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceMetadataFindUniqueArgs>(args: SelectSubset<T, InvoiceMetadataFindUniqueArgs<ExtArgs>>): Prisma__InvoiceMetadataClient<$Result.GetResult<Prisma.$InvoiceMetadataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceMetadata that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceMetadataFindUniqueOrThrowArgs} args - Arguments to find a InvoiceMetadata
     * @example
     * // Get one InvoiceMetadata
     * const invoiceMetadata = await prisma.invoiceMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceMetadataClient<$Result.GetResult<Prisma.$InvoiceMetadataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMetadataFindFirstArgs} args - Arguments to find a InvoiceMetadata
     * @example
     * // Get one InvoiceMetadata
     * const invoiceMetadata = await prisma.invoiceMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceMetadataFindFirstArgs>(args?: SelectSubset<T, InvoiceMetadataFindFirstArgs<ExtArgs>>): Prisma__InvoiceMetadataClient<$Result.GetResult<Prisma.$InvoiceMetadataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMetadataFindFirstOrThrowArgs} args - Arguments to find a InvoiceMetadata
     * @example
     * // Get one InvoiceMetadata
     * const invoiceMetadata = await prisma.invoiceMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceMetadataClient<$Result.GetResult<Prisma.$InvoiceMetadataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceMetadata
     * const invoiceMetadata = await prisma.invoiceMetadata.findMany()
     * 
     * // Get first 10 InvoiceMetadata
     * const invoiceMetadata = await prisma.invoiceMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceMetadataWithIdOnly = await prisma.invoiceMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceMetadataFindManyArgs>(args?: SelectSubset<T, InvoiceMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceMetadataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceMetadata.
     * @param {InvoiceMetadataCreateArgs} args - Arguments to create a InvoiceMetadata.
     * @example
     * // Create one InvoiceMetadata
     * const InvoiceMetadata = await prisma.invoiceMetadata.create({
     *   data: {
     *     // ... data to create a InvoiceMetadata
     *   }
     * })
     * 
     */
    create<T extends InvoiceMetadataCreateArgs>(args: SelectSubset<T, InvoiceMetadataCreateArgs<ExtArgs>>): Prisma__InvoiceMetadataClient<$Result.GetResult<Prisma.$InvoiceMetadataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceMetadata.
     * @param {InvoiceMetadataCreateManyArgs} args - Arguments to create many InvoiceMetadata.
     * @example
     * // Create many InvoiceMetadata
     * const invoiceMetadata = await prisma.invoiceMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceMetadataCreateManyArgs>(args?: SelectSubset<T, InvoiceMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvoiceMetadata.
     * @param {InvoiceMetadataDeleteArgs} args - Arguments to delete one InvoiceMetadata.
     * @example
     * // Delete one InvoiceMetadata
     * const InvoiceMetadata = await prisma.invoiceMetadata.delete({
     *   where: {
     *     // ... filter to delete one InvoiceMetadata
     *   }
     * })
     * 
     */
    delete<T extends InvoiceMetadataDeleteArgs>(args: SelectSubset<T, InvoiceMetadataDeleteArgs<ExtArgs>>): Prisma__InvoiceMetadataClient<$Result.GetResult<Prisma.$InvoiceMetadataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceMetadata.
     * @param {InvoiceMetadataUpdateArgs} args - Arguments to update one InvoiceMetadata.
     * @example
     * // Update one InvoiceMetadata
     * const invoiceMetadata = await prisma.invoiceMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceMetadataUpdateArgs>(args: SelectSubset<T, InvoiceMetadataUpdateArgs<ExtArgs>>): Prisma__InvoiceMetadataClient<$Result.GetResult<Prisma.$InvoiceMetadataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceMetadata.
     * @param {InvoiceMetadataDeleteManyArgs} args - Arguments to filter InvoiceMetadata to delete.
     * @example
     * // Delete a few InvoiceMetadata
     * const { count } = await prisma.invoiceMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceMetadataDeleteManyArgs>(args?: SelectSubset<T, InvoiceMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceMetadata
     * const invoiceMetadata = await prisma.invoiceMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceMetadataUpdateManyArgs>(args: SelectSubset<T, InvoiceMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceMetadata.
     * @param {InvoiceMetadataUpsertArgs} args - Arguments to update or create a InvoiceMetadata.
     * @example
     * // Update or create a InvoiceMetadata
     * const invoiceMetadata = await prisma.invoiceMetadata.upsert({
     *   create: {
     *     // ... data to create a InvoiceMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceMetadata we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceMetadataUpsertArgs>(args: SelectSubset<T, InvoiceMetadataUpsertArgs<ExtArgs>>): Prisma__InvoiceMetadataClient<$Result.GetResult<Prisma.$InvoiceMetadataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMetadataCountArgs} args - Arguments to filter InvoiceMetadata to count.
     * @example
     * // Count the number of InvoiceMetadata
     * const count = await prisma.invoiceMetadata.count({
     *   where: {
     *     // ... the filter for the InvoiceMetadata we want to count
     *   }
     * })
    **/
    count<T extends InvoiceMetadataCountArgs>(
      args?: Subset<T, InvoiceMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceMetadataAggregateArgs>(args: Subset<T, InvoiceMetadataAggregateArgs>): Prisma.PrismaPromise<GetInvoiceMetadataAggregateType<T>>

    /**
     * Group by InvoiceMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceMetadataGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceMetadata model
   */
  readonly fields: InvoiceMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceMetadata model
   */ 
  interface InvoiceMetadataFieldRefs {
    readonly id: FieldRef<"InvoiceMetadata", 'String'>
    readonly tenantId: FieldRef<"InvoiceMetadata", 'String'>
    readonly prefix: FieldRef<"InvoiceMetadata", 'String'>
    readonly sequenceNumber: FieldRef<"InvoiceMetadata", 'Int'>
    readonly lastUsedDate: FieldRef<"InvoiceMetadata", 'DateTime'>
    readonly year: FieldRef<"InvoiceMetadata", 'Int'>
    readonly createdAt: FieldRef<"InvoiceMetadata", 'DateTime'>
    readonly updatedAt: FieldRef<"InvoiceMetadata", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceMetadata findUnique
   */
  export type InvoiceMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMetadata
     */
    select?: InvoiceMetadataSelect<ExtArgs> | null
    /**
     * Filter, which InvoiceMetadata to fetch.
     */
    where: InvoiceMetadataWhereUniqueInput
  }

  /**
   * InvoiceMetadata findUniqueOrThrow
   */
  export type InvoiceMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMetadata
     */
    select?: InvoiceMetadataSelect<ExtArgs> | null
    /**
     * Filter, which InvoiceMetadata to fetch.
     */
    where: InvoiceMetadataWhereUniqueInput
  }

  /**
   * InvoiceMetadata findFirst
   */
  export type InvoiceMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMetadata
     */
    select?: InvoiceMetadataSelect<ExtArgs> | null
    /**
     * Filter, which InvoiceMetadata to fetch.
     */
    where?: InvoiceMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceMetadata to fetch.
     */
    orderBy?: InvoiceMetadataOrderByWithRelationInput | InvoiceMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceMetadata.
     */
    cursor?: InvoiceMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceMetadata.
     */
    distinct?: InvoiceMetadataScalarFieldEnum | InvoiceMetadataScalarFieldEnum[]
  }

  /**
   * InvoiceMetadata findFirstOrThrow
   */
  export type InvoiceMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMetadata
     */
    select?: InvoiceMetadataSelect<ExtArgs> | null
    /**
     * Filter, which InvoiceMetadata to fetch.
     */
    where?: InvoiceMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceMetadata to fetch.
     */
    orderBy?: InvoiceMetadataOrderByWithRelationInput | InvoiceMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceMetadata.
     */
    cursor?: InvoiceMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceMetadata.
     */
    distinct?: InvoiceMetadataScalarFieldEnum | InvoiceMetadataScalarFieldEnum[]
  }

  /**
   * InvoiceMetadata findMany
   */
  export type InvoiceMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMetadata
     */
    select?: InvoiceMetadataSelect<ExtArgs> | null
    /**
     * Filter, which InvoiceMetadata to fetch.
     */
    where?: InvoiceMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceMetadata to fetch.
     */
    orderBy?: InvoiceMetadataOrderByWithRelationInput | InvoiceMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceMetadata.
     */
    cursor?: InvoiceMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceMetadata.
     */
    skip?: number
    distinct?: InvoiceMetadataScalarFieldEnum | InvoiceMetadataScalarFieldEnum[]
  }

  /**
   * InvoiceMetadata create
   */
  export type InvoiceMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMetadata
     */
    select?: InvoiceMetadataSelect<ExtArgs> | null
    /**
     * The data needed to create a InvoiceMetadata.
     */
    data: XOR<InvoiceMetadataCreateInput, InvoiceMetadataUncheckedCreateInput>
  }

  /**
   * InvoiceMetadata createMany
   */
  export type InvoiceMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceMetadata.
     */
    data: InvoiceMetadataCreateManyInput | InvoiceMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceMetadata update
   */
  export type InvoiceMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMetadata
     */
    select?: InvoiceMetadataSelect<ExtArgs> | null
    /**
     * The data needed to update a InvoiceMetadata.
     */
    data: XOR<InvoiceMetadataUpdateInput, InvoiceMetadataUncheckedUpdateInput>
    /**
     * Choose, which InvoiceMetadata to update.
     */
    where: InvoiceMetadataWhereUniqueInput
  }

  /**
   * InvoiceMetadata updateMany
   */
  export type InvoiceMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceMetadata.
     */
    data: XOR<InvoiceMetadataUpdateManyMutationInput, InvoiceMetadataUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceMetadata to update
     */
    where?: InvoiceMetadataWhereInput
  }

  /**
   * InvoiceMetadata upsert
   */
  export type InvoiceMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMetadata
     */
    select?: InvoiceMetadataSelect<ExtArgs> | null
    /**
     * The filter to search for the InvoiceMetadata to update in case it exists.
     */
    where: InvoiceMetadataWhereUniqueInput
    /**
     * In case the InvoiceMetadata found by the `where` argument doesn't exist, create a new InvoiceMetadata with this data.
     */
    create: XOR<InvoiceMetadataCreateInput, InvoiceMetadataUncheckedCreateInput>
    /**
     * In case the InvoiceMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceMetadataUpdateInput, InvoiceMetadataUncheckedUpdateInput>
  }

  /**
   * InvoiceMetadata delete
   */
  export type InvoiceMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMetadata
     */
    select?: InvoiceMetadataSelect<ExtArgs> | null
    /**
     * Filter which InvoiceMetadata to delete.
     */
    where: InvoiceMetadataWhereUniqueInput
  }

  /**
   * InvoiceMetadata deleteMany
   */
  export type InvoiceMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceMetadata to delete
     */
    where?: InvoiceMetadataWhereInput
  }

  /**
   * InvoiceMetadata without action
   */
  export type InvoiceMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMetadata
     */
    select?: InvoiceMetadataSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SystemLicenseScalarFieldEnum: {
    id: 'id',
    licenseKey: 'licenseKey',
    status: 'status',
    validUntil: 'validUntil',
    maxNodesAllowed: 'maxNodesAllowed',
    whitelabelEnabled: 'whitelabelEnabled',
    signature: 'signature',
    gracePeriodEnds: 'gracePeriodEnds',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemLicenseScalarFieldEnum = (typeof SystemLicenseScalarFieldEnum)[keyof typeof SystemLicenseScalarFieldEnum]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    themeConfig: 'themeConfig',
    smtpConfig: 'smtpConfig',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorMethod: 'twoFactorMethod',
    twoFactorBackupCodes: 'twoFactorBackupCodes',
    resetToken: 'resetToken',
    resetTokenExpires: 'resetTokenExpires',
    balance: 'balance',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resourceId: 'resourceId',
    ipAddress: 'ipAddress',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NodeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    apiKey: 'apiKey',
    ipAddress: 'ipAddress',
    publicFqdn: 'publicFqdn',
    totalRam: 'totalRam',
    totalCpu: 'totalCpu',
    diskType: 'diskType',
    isClusterStorage: 'isClusterStorage',
    maintenanceMode: 'maintenanceMode',
    maxConcurrentUpdates: 'maxConcurrentUpdates',
    status: 'status',
    lastHeartbeat: 'lastHeartbeat',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NodeScalarFieldEnum = (typeof NodeScalarFieldEnum)[keyof typeof NodeScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    nodeId: 'nodeId',
    type: 'type',
    status: 'status',
    data: 'data',
    error: 'error',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const NetworkAllocationScalarFieldEnum: {
    id: 'id',
    nodeId: 'nodeId',
    port: 'port',
    protocol: 'protocol',
    type: 'type',
    serverUuid: 'serverUuid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NetworkAllocationScalarFieldEnum = (typeof NetworkAllocationScalarFieldEnum)[keyof typeof NetworkAllocationScalarFieldEnum]


  export const SubdomainScalarFieldEnum: {
    id: 'id',
    subdomain: 'subdomain',
    domain: 'domain',
    serverUuid: 'serverUuid',
    cloudflareId: 'cloudflareId',
    targetIP: 'targetIP',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubdomainScalarFieldEnum = (typeof SubdomainScalarFieldEnum)[keyof typeof SubdomainScalarFieldEnum]


  export const GameServerScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    gameType: 'gameType',
    status: 'status',
    nodeId: 'nodeId',
    ownerId: 'ownerId',
    planId: 'planId',
    startupPriority: 'startupPriority',
    resources: 'resources',
    envVars: 'envVars',
    clusterId: 'clusterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameServerScalarFieldEnum = (typeof GameServerScalarFieldEnum)[keyof typeof GameServerScalarFieldEnum]


  export const GameClusterScalarFieldEnum: {
    id: 'id',
    gameType: 'gameType',
    sharedSecret: 'sharedSecret',
    storageNodeId: 'storageNodeId',
    mountPath: 'mountPath',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GameClusterScalarFieldEnum = (typeof GameClusterScalarFieldEnum)[keyof typeof GameClusterScalarFieldEnum]


  export const BackupScalarFieldEnum: {
    id: 'id',
    serverUuid: 'serverUuid',
    snapshotId: 'snapshotId',
    sizeBytes: 'sizeBytes',
    location: 'location',
    lastRestoredAt: 'lastRestoredAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BackupScalarFieldEnum = (typeof BackupScalarFieldEnum)[keyof typeof BackupScalarFieldEnum]


  export const MetricScalarFieldEnum: {
    id: 'id',
    nodeId: 'nodeId',
    serverUuid: 'serverUuid',
    timestamp: 'timestamp',
    cpuUsage: 'cpuUsage',
    ramUsage: 'ramUsage',
    ramUsagePercent: 'ramUsagePercent',
    diskUsage: 'diskUsage',
    diskUsagePercent: 'diskUsagePercent',
    networkIn: 'networkIn',
    networkOut: 'networkOut',
    uptime: 'uptime'
  };

  export type MetricScalarFieldEnum = (typeof MetricScalarFieldEnum)[keyof typeof MetricScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    severity: 'severity',
    type: 'type',
    message: 'message',
    resourceId: 'resourceId',
    resourceType: 'resourceType',
    resolved: 'resolved',
    resolvedAt: 'resolvedAt',
    resolvedById: 'resolvedById',
    metadata: 'metadata',
    nodeId: 'nodeId',
    serverUuid: 'serverUuid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const ResourceQuotaScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenantId: 'tenantId',
    maxServers: 'maxServers',
    maxRam: 'maxRam',
    maxDisk: 'maxDisk',
    maxCpu: 'maxCpu',
    currentUsage: 'currentUsage',
    enforced: 'enforced',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResourceQuotaScalarFieldEnum = (typeof ResourceQuotaScalarFieldEnum)[keyof typeof ResourceQuotaScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    keyHash: 'keyHash',
    name: 'name',
    lastUsedAt: 'lastUsedAt',
    expiresAt: 'expiresAt',
    permissions: 'permissions',
    rateLimit: 'rateLimit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const IncidentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    severity: 'severity',
    status: 'status',
    assignedToId: 'assignedToId',
    resolvedAt: 'resolvedAt',
    rootCause: 'rootCause',
    resolution: 'resolution',
    affectedResources: 'affectedResources',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncidentScalarFieldEnum = (typeof IncidentScalarFieldEnum)[keyof typeof IncidentScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    gameType: 'gameType',
    status: 'status',
    ramMb: 'ramMb',
    cpuCores: 'cpuCores',
    diskGb: 'diskGb',
    maxSlots: 'maxSlots',
    monthlyPrice: 'monthlyPrice',
    hourlyPrice: 'hourlyPrice',
    setupFee: 'setupFee',
    features: 'features',
    description: 'description',
    isPopular: 'isPopular',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    scope: 'scope',
    discountPercent: 'discountPercent',
    gameType: 'gameType',
    planId: 'planId',
    startDate: 'startDate',
    endDate: 'endDate',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    planId: 'planId',
    status: 'status',
    priceSnapshot: 'priceSnapshot',
    totalAmount: 'totalAmount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    paymentId: 'paymentId',
    paidAt: 'paidAt',
    serverId: 'serverId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const PaymentEventScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    eventType: 'eventType',
    eventId: 'eventId',
    paymentId: 'paymentId',
    orderId: 'orderId',
    status: 'status',
    payload: 'payload',
    error: 'error',
    createdAt: 'createdAt',
    processedAt: 'processedAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentEventScalarFieldEnum = (typeof PaymentEventScalarFieldEnum)[keyof typeof PaymentEventScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    ticketNumber: 'ticketNumber',
    subject: 'subject',
    description: 'description',
    priority: 'priority',
    category: 'category',
    status: 'status',
    assignedToId: 'assignedToId',
    assignedAt: 'assignedAt',
    slaResponseDeadline: 'slaResponseDeadline',
    slaResolveDeadline: 'slaResolveDeadline',
    firstResponseAt: 'firstResponseAt',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    closedAt: 'closedAt'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const SlaPolicyScalarFieldEnum: {
    id: 'id',
    priority: 'priority',
    responseTimeHours: 'responseTimeHours',
    resolveTimeHours: 'resolveTimeHours',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SlaPolicyScalarFieldEnum = (typeof SlaPolicyScalarFieldEnum)[keyof typeof SlaPolicyScalarFieldEnum]


  export const TicketCommentScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    authorId: 'authorId',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketCommentScalarFieldEnum = (typeof TicketCommentScalarFieldEnum)[keyof typeof TicketCommentScalarFieldEnum]


  export const KnowledgeBaseArticleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    excerpt: 'excerpt',
    categoryId: 'categoryId',
    authorId: 'authorId',
    tags: 'tags',
    published: 'published',
    views: 'views',
    helpful: 'helpful',
    notHelpful: 'notHelpful',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishedAt: 'publishedAt'
  };

  export type KnowledgeBaseArticleScalarFieldEnum = (typeof KnowledgeBaseArticleScalarFieldEnum)[keyof typeof KnowledgeBaseArticleScalarFieldEnum]


  export const KnowledgeBaseCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    icon: 'icon',
    order: 'order',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeBaseCategoryScalarFieldEnum = (typeof KnowledgeBaseCategoryScalarFieldEnum)[keyof typeof KnowledgeBaseCategoryScalarFieldEnum]


  export const ArticleVersionScalarFieldEnum: {
    id: 'id',
    articleId: 'articleId',
    version: 'version',
    title: 'title',
    content: 'content',
    excerpt: 'excerpt',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type ArticleVersionScalarFieldEnum = (typeof ArticleVersionScalarFieldEnum)[keyof typeof ArticleVersionScalarFieldEnum]


  export const InvoiceMetadataScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    prefix: 'prefix',
    sequenceNumber: 'sequenceNumber',
    lastUsedDate: 'lastUsedDate',
    year: 'year',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceMetadataScalarFieldEnum = (typeof InvoiceMetadataScalarFieldEnum)[keyof typeof InvoiceMetadataScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'LicenseStatus'
   */
  export type EnumLicenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LicenseStatus'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'DiskType'
   */
  export type EnumDiskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiskType'>
    


  /**
   * Reference to a field of type 'NodeStatus'
   */
  export type EnumNodeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NodeStatus'>
    


  /**
   * Reference to a field of type 'TaskType'
   */
  export type EnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'Protocol'
   */
  export type EnumProtocolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Protocol'>
    


  /**
   * Reference to a field of type 'PortType'
   */
  export type EnumPortTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PortType'>
    


  /**
   * Reference to a field of type 'GameType'
   */
  export type EnumGameTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameType'>
    


  /**
   * Reference to a field of type 'ServerStatus'
   */
  export type EnumServerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServerStatus'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BackupLocation'
   */
  export type EnumBackupLocationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BackupLocation'>
    


  /**
   * Reference to a field of type 'AlertSeverity'
   */
  export type EnumAlertSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertSeverity'>
    


  /**
   * Reference to a field of type 'ResourceType'
   */
  export type EnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType'>
    


  /**
   * Reference to a field of type 'IncidentSeverity'
   */
  export type EnumIncidentSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentSeverity'>
    


  /**
   * Reference to a field of type 'IncidentStatus'
   */
  export type EnumIncidentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncidentStatus'>
    


  /**
   * Reference to a field of type 'PlanStatus'
   */
  export type EnumPlanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanStatus'>
    


  /**
   * Reference to a field of type 'PromotionScope'
   */
  export type EnumPromotionScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromotionScope'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'PaymentProvider'
   */
  export type EnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider'>
    


  /**
   * Reference to a field of type 'PaymentEventStatus'
   */
  export type EnumPaymentEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentEventStatus'>
    


  /**
   * Reference to a field of type 'TicketPriority'
   */
  export type EnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    
  /**
   * Deep Input Types
   */


  export type SystemLicenseWhereInput = {
    AND?: SystemLicenseWhereInput | SystemLicenseWhereInput[]
    OR?: SystemLicenseWhereInput[]
    NOT?: SystemLicenseWhereInput | SystemLicenseWhereInput[]
    id?: StringFilter<"SystemLicense"> | string
    licenseKey?: StringFilter<"SystemLicense"> | string
    status?: EnumLicenseStatusFilter<"SystemLicense"> | $Enums.LicenseStatus
    validUntil?: DateTimeFilter<"SystemLicense"> | Date | string
    maxNodesAllowed?: IntFilter<"SystemLicense"> | number
    whitelabelEnabled?: BoolFilter<"SystemLicense"> | boolean
    signature?: StringFilter<"SystemLicense"> | string
    gracePeriodEnds?: DateTimeNullableFilter<"SystemLicense"> | Date | string | null
    createdAt?: DateTimeFilter<"SystemLicense"> | Date | string
    updatedAt?: DateTimeFilter<"SystemLicense"> | Date | string
  }

  export type SystemLicenseOrderByWithRelationInput = {
    id?: SortOrder
    licenseKey?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    maxNodesAllowed?: SortOrder
    whitelabelEnabled?: SortOrder
    signature?: SortOrder
    gracePeriodEnds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemLicenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    licenseKey?: string
    AND?: SystemLicenseWhereInput | SystemLicenseWhereInput[]
    OR?: SystemLicenseWhereInput[]
    NOT?: SystemLicenseWhereInput | SystemLicenseWhereInput[]
    status?: EnumLicenseStatusFilter<"SystemLicense"> | $Enums.LicenseStatus
    validUntil?: DateTimeFilter<"SystemLicense"> | Date | string
    maxNodesAllowed?: IntFilter<"SystemLicense"> | number
    whitelabelEnabled?: BoolFilter<"SystemLicense"> | boolean
    signature?: StringFilter<"SystemLicense"> | string
    gracePeriodEnds?: DateTimeNullableFilter<"SystemLicense"> | Date | string | null
    createdAt?: DateTimeFilter<"SystemLicense"> | Date | string
    updatedAt?: DateTimeFilter<"SystemLicense"> | Date | string
  }, "id" | "licenseKey">

  export type SystemLicenseOrderByWithAggregationInput = {
    id?: SortOrder
    licenseKey?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    maxNodesAllowed?: SortOrder
    whitelabelEnabled?: SortOrder
    signature?: SortOrder
    gracePeriodEnds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemLicenseCountOrderByAggregateInput
    _avg?: SystemLicenseAvgOrderByAggregateInput
    _max?: SystemLicenseMaxOrderByAggregateInput
    _min?: SystemLicenseMinOrderByAggregateInput
    _sum?: SystemLicenseSumOrderByAggregateInput
  }

  export type SystemLicenseScalarWhereWithAggregatesInput = {
    AND?: SystemLicenseScalarWhereWithAggregatesInput | SystemLicenseScalarWhereWithAggregatesInput[]
    OR?: SystemLicenseScalarWhereWithAggregatesInput[]
    NOT?: SystemLicenseScalarWhereWithAggregatesInput | SystemLicenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemLicense"> | string
    licenseKey?: StringWithAggregatesFilter<"SystemLicense"> | string
    status?: EnumLicenseStatusWithAggregatesFilter<"SystemLicense"> | $Enums.LicenseStatus
    validUntil?: DateTimeWithAggregatesFilter<"SystemLicense"> | Date | string
    maxNodesAllowed?: IntWithAggregatesFilter<"SystemLicense"> | number
    whitelabelEnabled?: BoolWithAggregatesFilter<"SystemLicense"> | boolean
    signature?: StringWithAggregatesFilter<"SystemLicense"> | string
    gracePeriodEnds?: DateTimeNullableWithAggregatesFilter<"SystemLicense"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemLicense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemLicense"> | Date | string
  }

  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    domain?: StringFilter<"Tenant"> | string
    themeConfig?: JsonNullableFilter<"Tenant">
    smtpConfig?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    resourceQuotas?: ResourceQuotaListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    themeConfig?: SortOrderInput | SortOrder
    smtpConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    resourceQuotas?: ResourceQuotaOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    themeConfig?: JsonNullableFilter<"Tenant">
    smtpConfig?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    resourceQuotas?: ResourceQuotaListRelationFilter
  }, "id" | "domain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    themeConfig?: SortOrderInput | SortOrder
    smtpConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    domain?: StringWithAggregatesFilter<"Tenant"> | string
    themeConfig?: JsonNullableWithAggregatesFilter<"Tenant">
    smtpConfig?: JsonNullableWithAggregatesFilter<"Tenant">
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorMethod?: StringNullableFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    balance?: FloatFilter<"User"> | number
    tenantId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    ownedServers?: GameServerListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    resolvedAlerts?: AlertListRelationFilter
    resourceQuotas?: ResourceQuotaListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    assignedIncidents?: IncidentListRelationFilter
    orders?: OrderListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
    assignedTickets?: SupportTicketListRelationFilter
    knowledgeBaseArticles?: KnowledgeBaseArticleListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrderInput | SortOrder
    twoFactorBackupCodes?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpires?: SortOrderInput | SortOrder
    balance?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    ownedServers?: GameServerOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    resolvedAlerts?: AlertOrderByRelationAggregateInput
    resourceQuotas?: ResourceQuotaOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    assignedIncidents?: IncidentOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    supportTickets?: SupportTicketOrderByRelationAggregateInput
    ticketComments?: TicketCommentOrderByRelationAggregateInput
    assignedTickets?: SupportTicketOrderByRelationAggregateInput
    knowledgeBaseArticles?: KnowledgeBaseArticleOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorMethod?: StringNullableFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    balance?: FloatFilter<"User"> | number
    tenantId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    ownedServers?: GameServerListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    resolvedAlerts?: AlertListRelationFilter
    resourceQuotas?: ResourceQuotaListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    assignedIncidents?: IncidentListRelationFilter
    orders?: OrderListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
    assignedTickets?: SupportTicketListRelationFilter
    knowledgeBaseArticles?: KnowledgeBaseArticleListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrderInput | SortOrder
    twoFactorBackupCodes?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpires?: SortOrderInput | SortOrder
    balance?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorMethod?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    balance?: FloatWithAggregatesFilter<"User"> | number
    tenantId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    ipAddress?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    ipAddress?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringWithAggregatesFilter<"AuditLog"> | string
    ipAddress?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NodeWhereInput = {
    AND?: NodeWhereInput | NodeWhereInput[]
    OR?: NodeWhereInput[]
    NOT?: NodeWhereInput | NodeWhereInput[]
    id?: StringFilter<"Node"> | string
    name?: StringFilter<"Node"> | string
    apiKey?: StringFilter<"Node"> | string
    ipAddress?: StringFilter<"Node"> | string
    publicFqdn?: StringNullableFilter<"Node"> | string | null
    totalRam?: IntFilter<"Node"> | number
    totalCpu?: IntFilter<"Node"> | number
    diskType?: EnumDiskTypeFilter<"Node"> | $Enums.DiskType
    isClusterStorage?: BoolFilter<"Node"> | boolean
    maintenanceMode?: BoolFilter<"Node"> | boolean
    maxConcurrentUpdates?: IntFilter<"Node"> | number
    status?: EnumNodeStatusFilter<"Node"> | $Enums.NodeStatus
    lastHeartbeat?: DateTimeNullableFilter<"Node"> | Date | string | null
    createdAt?: DateTimeFilter<"Node"> | Date | string
    updatedAt?: DateTimeFilter<"Node"> | Date | string
    servers?: GameServerListRelationFilter
    networkAllocations?: NetworkAllocationListRelationFilter
    metrics?: MetricListRelationFilter
    alerts?: AlertListRelationFilter
    storageClusters?: GameClusterListRelationFilter
    tasks?: TaskListRelationFilter
  }

  export type NodeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    ipAddress?: SortOrder
    publicFqdn?: SortOrderInput | SortOrder
    totalRam?: SortOrder
    totalCpu?: SortOrder
    diskType?: SortOrder
    isClusterStorage?: SortOrder
    maintenanceMode?: SortOrder
    maxConcurrentUpdates?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    servers?: GameServerOrderByRelationAggregateInput
    networkAllocations?: NetworkAllocationOrderByRelationAggregateInput
    metrics?: MetricOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
    storageClusters?: GameClusterOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type NodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    apiKey?: string
    AND?: NodeWhereInput | NodeWhereInput[]
    OR?: NodeWhereInput[]
    NOT?: NodeWhereInput | NodeWhereInput[]
    name?: StringFilter<"Node"> | string
    ipAddress?: StringFilter<"Node"> | string
    publicFqdn?: StringNullableFilter<"Node"> | string | null
    totalRam?: IntFilter<"Node"> | number
    totalCpu?: IntFilter<"Node"> | number
    diskType?: EnumDiskTypeFilter<"Node"> | $Enums.DiskType
    isClusterStorage?: BoolFilter<"Node"> | boolean
    maintenanceMode?: BoolFilter<"Node"> | boolean
    maxConcurrentUpdates?: IntFilter<"Node"> | number
    status?: EnumNodeStatusFilter<"Node"> | $Enums.NodeStatus
    lastHeartbeat?: DateTimeNullableFilter<"Node"> | Date | string | null
    createdAt?: DateTimeFilter<"Node"> | Date | string
    updatedAt?: DateTimeFilter<"Node"> | Date | string
    servers?: GameServerListRelationFilter
    networkAllocations?: NetworkAllocationListRelationFilter
    metrics?: MetricListRelationFilter
    alerts?: AlertListRelationFilter
    storageClusters?: GameClusterListRelationFilter
    tasks?: TaskListRelationFilter
  }, "id" | "apiKey">

  export type NodeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    ipAddress?: SortOrder
    publicFqdn?: SortOrderInput | SortOrder
    totalRam?: SortOrder
    totalCpu?: SortOrder
    diskType?: SortOrder
    isClusterStorage?: SortOrder
    maintenanceMode?: SortOrder
    maxConcurrentUpdates?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NodeCountOrderByAggregateInput
    _avg?: NodeAvgOrderByAggregateInput
    _max?: NodeMaxOrderByAggregateInput
    _min?: NodeMinOrderByAggregateInput
    _sum?: NodeSumOrderByAggregateInput
  }

  export type NodeScalarWhereWithAggregatesInput = {
    AND?: NodeScalarWhereWithAggregatesInput | NodeScalarWhereWithAggregatesInput[]
    OR?: NodeScalarWhereWithAggregatesInput[]
    NOT?: NodeScalarWhereWithAggregatesInput | NodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Node"> | string
    name?: StringWithAggregatesFilter<"Node"> | string
    apiKey?: StringWithAggregatesFilter<"Node"> | string
    ipAddress?: StringWithAggregatesFilter<"Node"> | string
    publicFqdn?: StringNullableWithAggregatesFilter<"Node"> | string | null
    totalRam?: IntWithAggregatesFilter<"Node"> | number
    totalCpu?: IntWithAggregatesFilter<"Node"> | number
    diskType?: EnumDiskTypeWithAggregatesFilter<"Node"> | $Enums.DiskType
    isClusterStorage?: BoolWithAggregatesFilter<"Node"> | boolean
    maintenanceMode?: BoolWithAggregatesFilter<"Node"> | boolean
    maxConcurrentUpdates?: IntWithAggregatesFilter<"Node"> | number
    status?: EnumNodeStatusWithAggregatesFilter<"Node"> | $Enums.NodeStatus
    lastHeartbeat?: DateTimeNullableWithAggregatesFilter<"Node"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Node"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Node"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    nodeId?: StringFilter<"Task"> | string
    type?: EnumTaskTypeFilter<"Task"> | $Enums.TaskType
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    data?: JsonFilter<"Task">
    error?: StringNullableFilter<"Task"> | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    node?: XOR<NodeRelationFilter, NodeWhereInput>
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    error?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    node?: NodeOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    nodeId?: StringFilter<"Task"> | string
    type?: EnumTaskTypeFilter<"Task"> | $Enums.TaskType
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    data?: JsonFilter<"Task">
    error?: StringNullableFilter<"Task"> | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    node?: XOR<NodeRelationFilter, NodeWhereInput>
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    error?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    nodeId?: StringWithAggregatesFilter<"Task"> | string
    type?: EnumTaskTypeWithAggregatesFilter<"Task"> | $Enums.TaskType
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    data?: JsonWithAggregatesFilter<"Task">
    error?: StringNullableWithAggregatesFilter<"Task"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type NetworkAllocationWhereInput = {
    AND?: NetworkAllocationWhereInput | NetworkAllocationWhereInput[]
    OR?: NetworkAllocationWhereInput[]
    NOT?: NetworkAllocationWhereInput | NetworkAllocationWhereInput[]
    id?: StringFilter<"NetworkAllocation"> | string
    nodeId?: StringFilter<"NetworkAllocation"> | string
    port?: IntFilter<"NetworkAllocation"> | number
    protocol?: EnumProtocolFilter<"NetworkAllocation"> | $Enums.Protocol
    type?: EnumPortTypeFilter<"NetworkAllocation"> | $Enums.PortType
    serverUuid?: StringNullableFilter<"NetworkAllocation"> | string | null
    createdAt?: DateTimeFilter<"NetworkAllocation"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkAllocation"> | Date | string
    node?: XOR<NodeRelationFilter, NodeWhereInput>
    server?: XOR<GameServerNullableRelationFilter, GameServerWhereInput> | null
  }

  export type NetworkAllocationOrderByWithRelationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    port?: SortOrder
    protocol?: SortOrder
    type?: SortOrder
    serverUuid?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    node?: NodeOrderByWithRelationInput
    server?: GameServerOrderByWithRelationInput
  }

  export type NetworkAllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nodeId_port_protocol?: NetworkAllocationNodeIdPortProtocolCompoundUniqueInput
    AND?: NetworkAllocationWhereInput | NetworkAllocationWhereInput[]
    OR?: NetworkAllocationWhereInput[]
    NOT?: NetworkAllocationWhereInput | NetworkAllocationWhereInput[]
    nodeId?: StringFilter<"NetworkAllocation"> | string
    port?: IntFilter<"NetworkAllocation"> | number
    protocol?: EnumProtocolFilter<"NetworkAllocation"> | $Enums.Protocol
    type?: EnumPortTypeFilter<"NetworkAllocation"> | $Enums.PortType
    serverUuid?: StringNullableFilter<"NetworkAllocation"> | string | null
    createdAt?: DateTimeFilter<"NetworkAllocation"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkAllocation"> | Date | string
    node?: XOR<NodeRelationFilter, NodeWhereInput>
    server?: XOR<GameServerNullableRelationFilter, GameServerWhereInput> | null
  }, "id" | "nodeId_port_protocol">

  export type NetworkAllocationOrderByWithAggregationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    port?: SortOrder
    protocol?: SortOrder
    type?: SortOrder
    serverUuid?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NetworkAllocationCountOrderByAggregateInput
    _avg?: NetworkAllocationAvgOrderByAggregateInput
    _max?: NetworkAllocationMaxOrderByAggregateInput
    _min?: NetworkAllocationMinOrderByAggregateInput
    _sum?: NetworkAllocationSumOrderByAggregateInput
  }

  export type NetworkAllocationScalarWhereWithAggregatesInput = {
    AND?: NetworkAllocationScalarWhereWithAggregatesInput | NetworkAllocationScalarWhereWithAggregatesInput[]
    OR?: NetworkAllocationScalarWhereWithAggregatesInput[]
    NOT?: NetworkAllocationScalarWhereWithAggregatesInput | NetworkAllocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NetworkAllocation"> | string
    nodeId?: StringWithAggregatesFilter<"NetworkAllocation"> | string
    port?: IntWithAggregatesFilter<"NetworkAllocation"> | number
    protocol?: EnumProtocolWithAggregatesFilter<"NetworkAllocation"> | $Enums.Protocol
    type?: EnumPortTypeWithAggregatesFilter<"NetworkAllocation"> | $Enums.PortType
    serverUuid?: StringNullableWithAggregatesFilter<"NetworkAllocation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NetworkAllocation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NetworkAllocation"> | Date | string
  }

  export type SubdomainWhereInput = {
    AND?: SubdomainWhereInput | SubdomainWhereInput[]
    OR?: SubdomainWhereInput[]
    NOT?: SubdomainWhereInput | SubdomainWhereInput[]
    id?: StringFilter<"Subdomain"> | string
    subdomain?: StringFilter<"Subdomain"> | string
    domain?: StringFilter<"Subdomain"> | string
    serverUuid?: StringFilter<"Subdomain"> | string
    cloudflareId?: StringFilter<"Subdomain"> | string
    targetIP?: StringFilter<"Subdomain"> | string
    createdAt?: DateTimeFilter<"Subdomain"> | Date | string
    updatedAt?: DateTimeFilter<"Subdomain"> | Date | string
    server?: XOR<GameServerRelationFilter, GameServerWhereInput>
  }

  export type SubdomainOrderByWithRelationInput = {
    id?: SortOrder
    subdomain?: SortOrder
    domain?: SortOrder
    serverUuid?: SortOrder
    cloudflareId?: SortOrder
    targetIP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    server?: GameServerOrderByWithRelationInput
  }

  export type SubdomainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subdomain_domain?: SubdomainSubdomainDomainCompoundUniqueInput
    AND?: SubdomainWhereInput | SubdomainWhereInput[]
    OR?: SubdomainWhereInput[]
    NOT?: SubdomainWhereInput | SubdomainWhereInput[]
    subdomain?: StringFilter<"Subdomain"> | string
    domain?: StringFilter<"Subdomain"> | string
    serverUuid?: StringFilter<"Subdomain"> | string
    cloudflareId?: StringFilter<"Subdomain"> | string
    targetIP?: StringFilter<"Subdomain"> | string
    createdAt?: DateTimeFilter<"Subdomain"> | Date | string
    updatedAt?: DateTimeFilter<"Subdomain"> | Date | string
    server?: XOR<GameServerRelationFilter, GameServerWhereInput>
  }, "id" | "subdomain_domain">

  export type SubdomainOrderByWithAggregationInput = {
    id?: SortOrder
    subdomain?: SortOrder
    domain?: SortOrder
    serverUuid?: SortOrder
    cloudflareId?: SortOrder
    targetIP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubdomainCountOrderByAggregateInput
    _max?: SubdomainMaxOrderByAggregateInput
    _min?: SubdomainMinOrderByAggregateInput
  }

  export type SubdomainScalarWhereWithAggregatesInput = {
    AND?: SubdomainScalarWhereWithAggregatesInput | SubdomainScalarWhereWithAggregatesInput[]
    OR?: SubdomainScalarWhereWithAggregatesInput[]
    NOT?: SubdomainScalarWhereWithAggregatesInput | SubdomainScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subdomain"> | string
    subdomain?: StringWithAggregatesFilter<"Subdomain"> | string
    domain?: StringWithAggregatesFilter<"Subdomain"> | string
    serverUuid?: StringWithAggregatesFilter<"Subdomain"> | string
    cloudflareId?: StringWithAggregatesFilter<"Subdomain"> | string
    targetIP?: StringWithAggregatesFilter<"Subdomain"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subdomain"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subdomain"> | Date | string
  }

  export type GameServerWhereInput = {
    AND?: GameServerWhereInput | GameServerWhereInput[]
    OR?: GameServerWhereInput[]
    NOT?: GameServerWhereInput | GameServerWhereInput[]
    id?: StringFilter<"GameServer"> | string
    uuid?: StringFilter<"GameServer"> | string
    gameType?: EnumGameTypeFilter<"GameServer"> | $Enums.GameType
    status?: EnumServerStatusFilter<"GameServer"> | $Enums.ServerStatus
    nodeId?: StringFilter<"GameServer"> | string
    ownerId?: StringFilter<"GameServer"> | string
    planId?: StringNullableFilter<"GameServer"> | string | null
    startupPriority?: IntFilter<"GameServer"> | number
    resources?: JsonFilter<"GameServer">
    envVars?: JsonFilter<"GameServer">
    clusterId?: StringNullableFilter<"GameServer"> | string | null
    createdAt?: DateTimeFilter<"GameServer"> | Date | string
    updatedAt?: DateTimeFilter<"GameServer"> | Date | string
    node?: XOR<NodeRelationFilter, NodeWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<PlanNullableRelationFilter, PlanWhereInput> | null
    cluster?: XOR<GameClusterNullableRelationFilter, GameClusterWhereInput> | null
    networkAllocations?: NetworkAllocationListRelationFilter
    subdomains?: SubdomainListRelationFilter
    backups?: BackupListRelationFilter
    metrics?: MetricListRelationFilter
    alerts?: AlertListRelationFilter
    orders?: OrderListRelationFilter
  }

  export type GameServerOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    gameType?: SortOrder
    status?: SortOrder
    nodeId?: SortOrder
    ownerId?: SortOrder
    planId?: SortOrderInput | SortOrder
    startupPriority?: SortOrder
    resources?: SortOrder
    envVars?: SortOrder
    clusterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    node?: NodeOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    plan?: PlanOrderByWithRelationInput
    cluster?: GameClusterOrderByWithRelationInput
    networkAllocations?: NetworkAllocationOrderByRelationAggregateInput
    subdomains?: SubdomainOrderByRelationAggregateInput
    backups?: BackupOrderByRelationAggregateInput
    metrics?: MetricOrderByRelationAggregateInput
    alerts?: AlertOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
  }

  export type GameServerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uuid?: string
    AND?: GameServerWhereInput | GameServerWhereInput[]
    OR?: GameServerWhereInput[]
    NOT?: GameServerWhereInput | GameServerWhereInput[]
    gameType?: EnumGameTypeFilter<"GameServer"> | $Enums.GameType
    status?: EnumServerStatusFilter<"GameServer"> | $Enums.ServerStatus
    nodeId?: StringFilter<"GameServer"> | string
    ownerId?: StringFilter<"GameServer"> | string
    planId?: StringNullableFilter<"GameServer"> | string | null
    startupPriority?: IntFilter<"GameServer"> | number
    resources?: JsonFilter<"GameServer">
    envVars?: JsonFilter<"GameServer">
    clusterId?: StringNullableFilter<"GameServer"> | string | null
    createdAt?: DateTimeFilter<"GameServer"> | Date | string
    updatedAt?: DateTimeFilter<"GameServer"> | Date | string
    node?: XOR<NodeRelationFilter, NodeWhereInput>
    owner?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<PlanNullableRelationFilter, PlanWhereInput> | null
    cluster?: XOR<GameClusterNullableRelationFilter, GameClusterWhereInput> | null
    networkAllocations?: NetworkAllocationListRelationFilter
    subdomains?: SubdomainListRelationFilter
    backups?: BackupListRelationFilter
    metrics?: MetricListRelationFilter
    alerts?: AlertListRelationFilter
    orders?: OrderListRelationFilter
  }, "id" | "uuid">

  export type GameServerOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    gameType?: SortOrder
    status?: SortOrder
    nodeId?: SortOrder
    ownerId?: SortOrder
    planId?: SortOrderInput | SortOrder
    startupPriority?: SortOrder
    resources?: SortOrder
    envVars?: SortOrder
    clusterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameServerCountOrderByAggregateInput
    _avg?: GameServerAvgOrderByAggregateInput
    _max?: GameServerMaxOrderByAggregateInput
    _min?: GameServerMinOrderByAggregateInput
    _sum?: GameServerSumOrderByAggregateInput
  }

  export type GameServerScalarWhereWithAggregatesInput = {
    AND?: GameServerScalarWhereWithAggregatesInput | GameServerScalarWhereWithAggregatesInput[]
    OR?: GameServerScalarWhereWithAggregatesInput[]
    NOT?: GameServerScalarWhereWithAggregatesInput | GameServerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameServer"> | string
    uuid?: StringWithAggregatesFilter<"GameServer"> | string
    gameType?: EnumGameTypeWithAggregatesFilter<"GameServer"> | $Enums.GameType
    status?: EnumServerStatusWithAggregatesFilter<"GameServer"> | $Enums.ServerStatus
    nodeId?: StringWithAggregatesFilter<"GameServer"> | string
    ownerId?: StringWithAggregatesFilter<"GameServer"> | string
    planId?: StringNullableWithAggregatesFilter<"GameServer"> | string | null
    startupPriority?: IntWithAggregatesFilter<"GameServer"> | number
    resources?: JsonWithAggregatesFilter<"GameServer">
    envVars?: JsonWithAggregatesFilter<"GameServer">
    clusterId?: StringNullableWithAggregatesFilter<"GameServer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GameServer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameServer"> | Date | string
  }

  export type GameClusterWhereInput = {
    AND?: GameClusterWhereInput | GameClusterWhereInput[]
    OR?: GameClusterWhereInput[]
    NOT?: GameClusterWhereInput | GameClusterWhereInput[]
    id?: StringFilter<"GameCluster"> | string
    gameType?: EnumGameTypeFilter<"GameCluster"> | $Enums.GameType
    sharedSecret?: StringFilter<"GameCluster"> | string
    storageNodeId?: StringFilter<"GameCluster"> | string
    mountPath?: StringFilter<"GameCluster"> | string
    createdAt?: DateTimeFilter<"GameCluster"> | Date | string
    updatedAt?: DateTimeFilter<"GameCluster"> | Date | string
    storageNode?: XOR<NodeRelationFilter, NodeWhereInput>
    servers?: GameServerListRelationFilter
  }

  export type GameClusterOrderByWithRelationInput = {
    id?: SortOrder
    gameType?: SortOrder
    sharedSecret?: SortOrder
    storageNodeId?: SortOrder
    mountPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    storageNode?: NodeOrderByWithRelationInput
    servers?: GameServerOrderByRelationAggregateInput
  }

  export type GameClusterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameClusterWhereInput | GameClusterWhereInput[]
    OR?: GameClusterWhereInput[]
    NOT?: GameClusterWhereInput | GameClusterWhereInput[]
    gameType?: EnumGameTypeFilter<"GameCluster"> | $Enums.GameType
    sharedSecret?: StringFilter<"GameCluster"> | string
    storageNodeId?: StringFilter<"GameCluster"> | string
    mountPath?: StringFilter<"GameCluster"> | string
    createdAt?: DateTimeFilter<"GameCluster"> | Date | string
    updatedAt?: DateTimeFilter<"GameCluster"> | Date | string
    storageNode?: XOR<NodeRelationFilter, NodeWhereInput>
    servers?: GameServerListRelationFilter
  }, "id">

  export type GameClusterOrderByWithAggregationInput = {
    id?: SortOrder
    gameType?: SortOrder
    sharedSecret?: SortOrder
    storageNodeId?: SortOrder
    mountPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GameClusterCountOrderByAggregateInput
    _max?: GameClusterMaxOrderByAggregateInput
    _min?: GameClusterMinOrderByAggregateInput
  }

  export type GameClusterScalarWhereWithAggregatesInput = {
    AND?: GameClusterScalarWhereWithAggregatesInput | GameClusterScalarWhereWithAggregatesInput[]
    OR?: GameClusterScalarWhereWithAggregatesInput[]
    NOT?: GameClusterScalarWhereWithAggregatesInput | GameClusterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GameCluster"> | string
    gameType?: EnumGameTypeWithAggregatesFilter<"GameCluster"> | $Enums.GameType
    sharedSecret?: StringWithAggregatesFilter<"GameCluster"> | string
    storageNodeId?: StringWithAggregatesFilter<"GameCluster"> | string
    mountPath?: StringWithAggregatesFilter<"GameCluster"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GameCluster"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameCluster"> | Date | string
  }

  export type BackupWhereInput = {
    AND?: BackupWhereInput | BackupWhereInput[]
    OR?: BackupWhereInput[]
    NOT?: BackupWhereInput | BackupWhereInput[]
    id?: StringFilter<"Backup"> | string
    serverUuid?: StringFilter<"Backup"> | string
    snapshotId?: StringFilter<"Backup"> | string
    sizeBytes?: BigIntFilter<"Backup"> | bigint | number
    location?: EnumBackupLocationFilter<"Backup"> | $Enums.BackupLocation
    lastRestoredAt?: DateTimeNullableFilter<"Backup"> | Date | string | null
    createdAt?: DateTimeFilter<"Backup"> | Date | string
    updatedAt?: DateTimeFilter<"Backup"> | Date | string
    server?: XOR<GameServerRelationFilter, GameServerWhereInput>
  }

  export type BackupOrderByWithRelationInput = {
    id?: SortOrder
    serverUuid?: SortOrder
    snapshotId?: SortOrder
    sizeBytes?: SortOrder
    location?: SortOrder
    lastRestoredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    server?: GameServerOrderByWithRelationInput
  }

  export type BackupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BackupWhereInput | BackupWhereInput[]
    OR?: BackupWhereInput[]
    NOT?: BackupWhereInput | BackupWhereInput[]
    serverUuid?: StringFilter<"Backup"> | string
    snapshotId?: StringFilter<"Backup"> | string
    sizeBytes?: BigIntFilter<"Backup"> | bigint | number
    location?: EnumBackupLocationFilter<"Backup"> | $Enums.BackupLocation
    lastRestoredAt?: DateTimeNullableFilter<"Backup"> | Date | string | null
    createdAt?: DateTimeFilter<"Backup"> | Date | string
    updatedAt?: DateTimeFilter<"Backup"> | Date | string
    server?: XOR<GameServerRelationFilter, GameServerWhereInput>
  }, "id">

  export type BackupOrderByWithAggregationInput = {
    id?: SortOrder
    serverUuid?: SortOrder
    snapshotId?: SortOrder
    sizeBytes?: SortOrder
    location?: SortOrder
    lastRestoredAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BackupCountOrderByAggregateInput
    _avg?: BackupAvgOrderByAggregateInput
    _max?: BackupMaxOrderByAggregateInput
    _min?: BackupMinOrderByAggregateInput
    _sum?: BackupSumOrderByAggregateInput
  }

  export type BackupScalarWhereWithAggregatesInput = {
    AND?: BackupScalarWhereWithAggregatesInput | BackupScalarWhereWithAggregatesInput[]
    OR?: BackupScalarWhereWithAggregatesInput[]
    NOT?: BackupScalarWhereWithAggregatesInput | BackupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Backup"> | string
    serverUuid?: StringWithAggregatesFilter<"Backup"> | string
    snapshotId?: StringWithAggregatesFilter<"Backup"> | string
    sizeBytes?: BigIntWithAggregatesFilter<"Backup"> | bigint | number
    location?: EnumBackupLocationWithAggregatesFilter<"Backup"> | $Enums.BackupLocation
    lastRestoredAt?: DateTimeNullableWithAggregatesFilter<"Backup"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Backup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Backup"> | Date | string
  }

  export type MetricWhereInput = {
    AND?: MetricWhereInput | MetricWhereInput[]
    OR?: MetricWhereInput[]
    NOT?: MetricWhereInput | MetricWhereInput[]
    id?: StringFilter<"Metric"> | string
    nodeId?: StringFilter<"Metric"> | string
    serverUuid?: StringNullableFilter<"Metric"> | string | null
    timestamp?: DateTimeFilter<"Metric"> | Date | string
    cpuUsage?: FloatFilter<"Metric"> | number
    ramUsage?: FloatFilter<"Metric"> | number
    ramUsagePercent?: FloatFilter<"Metric"> | number
    diskUsage?: FloatFilter<"Metric"> | number
    diskUsagePercent?: FloatFilter<"Metric"> | number
    networkIn?: BigIntFilter<"Metric"> | bigint | number
    networkOut?: BigIntFilter<"Metric"> | bigint | number
    uptime?: IntNullableFilter<"Metric"> | number | null
    node?: XOR<NodeRelationFilter, NodeWhereInput>
    server?: XOR<GameServerNullableRelationFilter, GameServerWhereInput> | null
  }

  export type MetricOrderByWithRelationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    serverUuid?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    cpuUsage?: SortOrder
    ramUsage?: SortOrder
    ramUsagePercent?: SortOrder
    diskUsage?: SortOrder
    diskUsagePercent?: SortOrder
    networkIn?: SortOrder
    networkOut?: SortOrder
    uptime?: SortOrderInput | SortOrder
    node?: NodeOrderByWithRelationInput
    server?: GameServerOrderByWithRelationInput
  }

  export type MetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MetricWhereInput | MetricWhereInput[]
    OR?: MetricWhereInput[]
    NOT?: MetricWhereInput | MetricWhereInput[]
    nodeId?: StringFilter<"Metric"> | string
    serverUuid?: StringNullableFilter<"Metric"> | string | null
    timestamp?: DateTimeFilter<"Metric"> | Date | string
    cpuUsage?: FloatFilter<"Metric"> | number
    ramUsage?: FloatFilter<"Metric"> | number
    ramUsagePercent?: FloatFilter<"Metric"> | number
    diskUsage?: FloatFilter<"Metric"> | number
    diskUsagePercent?: FloatFilter<"Metric"> | number
    networkIn?: BigIntFilter<"Metric"> | bigint | number
    networkOut?: BigIntFilter<"Metric"> | bigint | number
    uptime?: IntNullableFilter<"Metric"> | number | null
    node?: XOR<NodeRelationFilter, NodeWhereInput>
    server?: XOR<GameServerNullableRelationFilter, GameServerWhereInput> | null
  }, "id">

  export type MetricOrderByWithAggregationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    serverUuid?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    cpuUsage?: SortOrder
    ramUsage?: SortOrder
    ramUsagePercent?: SortOrder
    diskUsage?: SortOrder
    diskUsagePercent?: SortOrder
    networkIn?: SortOrder
    networkOut?: SortOrder
    uptime?: SortOrderInput | SortOrder
    _count?: MetricCountOrderByAggregateInput
    _avg?: MetricAvgOrderByAggregateInput
    _max?: MetricMaxOrderByAggregateInput
    _min?: MetricMinOrderByAggregateInput
    _sum?: MetricSumOrderByAggregateInput
  }

  export type MetricScalarWhereWithAggregatesInput = {
    AND?: MetricScalarWhereWithAggregatesInput | MetricScalarWhereWithAggregatesInput[]
    OR?: MetricScalarWhereWithAggregatesInput[]
    NOT?: MetricScalarWhereWithAggregatesInput | MetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Metric"> | string
    nodeId?: StringWithAggregatesFilter<"Metric"> | string
    serverUuid?: StringNullableWithAggregatesFilter<"Metric"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Metric"> | Date | string
    cpuUsage?: FloatWithAggregatesFilter<"Metric"> | number
    ramUsage?: FloatWithAggregatesFilter<"Metric"> | number
    ramUsagePercent?: FloatWithAggregatesFilter<"Metric"> | number
    diskUsage?: FloatWithAggregatesFilter<"Metric"> | number
    diskUsagePercent?: FloatWithAggregatesFilter<"Metric"> | number
    networkIn?: BigIntWithAggregatesFilter<"Metric"> | bigint | number
    networkOut?: BigIntWithAggregatesFilter<"Metric"> | bigint | number
    uptime?: IntNullableWithAggregatesFilter<"Metric"> | number | null
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    severity?: EnumAlertSeverityFilter<"Alert"> | $Enums.AlertSeverity
    type?: StringFilter<"Alert"> | string
    message?: StringFilter<"Alert"> | string
    resourceId?: StringFilter<"Alert"> | string
    resourceType?: EnumResourceTypeFilter<"Alert"> | $Enums.ResourceType
    resolved?: BoolFilter<"Alert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    resolvedById?: StringNullableFilter<"Alert"> | string | null
    metadata?: JsonNullableFilter<"Alert">
    nodeId?: StringNullableFilter<"Alert"> | string | null
    serverUuid?: StringNullableFilter<"Alert"> | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    resolvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    node?: XOR<NodeNullableRelationFilter, NodeWhereInput> | null
    server?: XOR<GameServerNullableRelationFilter, GameServerWhereInput> | null
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    message?: SortOrder
    resourceId?: SortOrder
    resourceType?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedById?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    nodeId?: SortOrderInput | SortOrder
    serverUuid?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedBy?: UserOrderByWithRelationInput
    node?: NodeOrderByWithRelationInput
    server?: GameServerOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    severity?: EnumAlertSeverityFilter<"Alert"> | $Enums.AlertSeverity
    type?: StringFilter<"Alert"> | string
    message?: StringFilter<"Alert"> | string
    resourceId?: StringFilter<"Alert"> | string
    resourceType?: EnumResourceTypeFilter<"Alert"> | $Enums.ResourceType
    resolved?: BoolFilter<"Alert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    resolvedById?: StringNullableFilter<"Alert"> | string | null
    metadata?: JsonNullableFilter<"Alert">
    nodeId?: StringNullableFilter<"Alert"> | string | null
    serverUuid?: StringNullableFilter<"Alert"> | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    resolvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    node?: XOR<NodeNullableRelationFilter, NodeWhereInput> | null
    server?: XOR<GameServerNullableRelationFilter, GameServerWhereInput> | null
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    message?: SortOrder
    resourceId?: SortOrder
    resourceType?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedById?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    nodeId?: SortOrderInput | SortOrder
    serverUuid?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    severity?: EnumAlertSeverityWithAggregatesFilter<"Alert"> | $Enums.AlertSeverity
    type?: StringWithAggregatesFilter<"Alert"> | string
    message?: StringWithAggregatesFilter<"Alert"> | string
    resourceId?: StringWithAggregatesFilter<"Alert"> | string
    resourceType?: EnumResourceTypeWithAggregatesFilter<"Alert"> | $Enums.ResourceType
    resolved?: BoolWithAggregatesFilter<"Alert"> | boolean
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
    resolvedById?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Alert">
    nodeId?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    serverUuid?: StringNullableWithAggregatesFilter<"Alert"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
  }

  export type ResourceQuotaWhereInput = {
    AND?: ResourceQuotaWhereInput | ResourceQuotaWhereInput[]
    OR?: ResourceQuotaWhereInput[]
    NOT?: ResourceQuotaWhereInput | ResourceQuotaWhereInput[]
    id?: StringFilter<"ResourceQuota"> | string
    userId?: StringFilter<"ResourceQuota"> | string
    tenantId?: StringNullableFilter<"ResourceQuota"> | string | null
    maxServers?: IntFilter<"ResourceQuota"> | number
    maxRam?: IntFilter<"ResourceQuota"> | number
    maxDisk?: IntFilter<"ResourceQuota"> | number
    maxCpu?: IntFilter<"ResourceQuota"> | number
    currentUsage?: JsonFilter<"ResourceQuota">
    enforced?: BoolFilter<"ResourceQuota"> | boolean
    createdAt?: DateTimeFilter<"ResourceQuota"> | Date | string
    updatedAt?: DateTimeFilter<"ResourceQuota"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }

  export type ResourceQuotaOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    maxServers?: SortOrder
    maxRam?: SortOrder
    maxDisk?: SortOrder
    maxCpu?: SortOrder
    currentUsage?: SortOrder
    enforced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type ResourceQuotaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ResourceQuotaWhereInput | ResourceQuotaWhereInput[]
    OR?: ResourceQuotaWhereInput[]
    NOT?: ResourceQuotaWhereInput | ResourceQuotaWhereInput[]
    tenantId?: StringNullableFilter<"ResourceQuota"> | string | null
    maxServers?: IntFilter<"ResourceQuota"> | number
    maxRam?: IntFilter<"ResourceQuota"> | number
    maxDisk?: IntFilter<"ResourceQuota"> | number
    maxCpu?: IntFilter<"ResourceQuota"> | number
    currentUsage?: JsonFilter<"ResourceQuota">
    enforced?: BoolFilter<"ResourceQuota"> | boolean
    createdAt?: DateTimeFilter<"ResourceQuota"> | Date | string
    updatedAt?: DateTimeFilter<"ResourceQuota"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }, "id" | "userId">

  export type ResourceQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    maxServers?: SortOrder
    maxRam?: SortOrder
    maxDisk?: SortOrder
    maxCpu?: SortOrder
    currentUsage?: SortOrder
    enforced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResourceQuotaCountOrderByAggregateInput
    _avg?: ResourceQuotaAvgOrderByAggregateInput
    _max?: ResourceQuotaMaxOrderByAggregateInput
    _min?: ResourceQuotaMinOrderByAggregateInput
    _sum?: ResourceQuotaSumOrderByAggregateInput
  }

  export type ResourceQuotaScalarWhereWithAggregatesInput = {
    AND?: ResourceQuotaScalarWhereWithAggregatesInput | ResourceQuotaScalarWhereWithAggregatesInput[]
    OR?: ResourceQuotaScalarWhereWithAggregatesInput[]
    NOT?: ResourceQuotaScalarWhereWithAggregatesInput | ResourceQuotaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResourceQuota"> | string
    userId?: StringWithAggregatesFilter<"ResourceQuota"> | string
    tenantId?: StringNullableWithAggregatesFilter<"ResourceQuota"> | string | null
    maxServers?: IntWithAggregatesFilter<"ResourceQuota"> | number
    maxRam?: IntWithAggregatesFilter<"ResourceQuota"> | number
    maxDisk?: IntWithAggregatesFilter<"ResourceQuota"> | number
    maxCpu?: IntWithAggregatesFilter<"ResourceQuota"> | number
    currentUsage?: JsonWithAggregatesFilter<"ResourceQuota">
    enforced?: BoolWithAggregatesFilter<"ResourceQuota"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ResourceQuota"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResourceQuota"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    permissions?: JsonNullableFilter<"ApiKey">
    rateLimit?: IntFilter<"ApiKey"> | number
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    name?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    rateLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyHash?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    permissions?: JsonNullableFilter<"ApiKey">
    rateLimit?: IntFilter<"ApiKey"> | number
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "keyHash">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    name?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    permissions?: SortOrderInput | SortOrder
    rateLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _avg?: ApiKeyAvgOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
    _sum?: ApiKeySumOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    userId?: StringWithAggregatesFilter<"ApiKey"> | string
    keyHash?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    permissions?: JsonNullableWithAggregatesFilter<"ApiKey">
    rateLimit?: IntWithAggregatesFilter<"ApiKey"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type IncidentWhereInput = {
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    id?: StringFilter<"Incident"> | string
    title?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    assignedToId?: StringNullableFilter<"Incident"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    rootCause?: StringNullableFilter<"Incident"> | string | null
    resolution?: StringNullableFilter<"Incident"> | string | null
    affectedResources?: JsonNullableFilter<"Incident">
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type IncidentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    rootCause?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    affectedResources?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedTo?: UserOrderByWithRelationInput
  }

  export type IncidentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncidentWhereInput | IncidentWhereInput[]
    OR?: IncidentWhereInput[]
    NOT?: IncidentWhereInput | IncidentWhereInput[]
    title?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    assignedToId?: StringNullableFilter<"Incident"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    rootCause?: StringNullableFilter<"Incident"> | string | null
    resolution?: StringNullableFilter<"Incident"> | string | null
    affectedResources?: JsonNullableFilter<"Incident">
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type IncidentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    rootCause?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    affectedResources?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncidentCountOrderByAggregateInput
    _max?: IncidentMaxOrderByAggregateInput
    _min?: IncidentMinOrderByAggregateInput
  }

  export type IncidentScalarWhereWithAggregatesInput = {
    AND?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    OR?: IncidentScalarWhereWithAggregatesInput[]
    NOT?: IncidentScalarWhereWithAggregatesInput | IncidentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incident"> | string
    title?: StringWithAggregatesFilter<"Incident"> | string
    description?: StringWithAggregatesFilter<"Incident"> | string
    severity?: EnumIncidentSeverityWithAggregatesFilter<"Incident"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusWithAggregatesFilter<"Incident"> | $Enums.IncidentStatus
    assignedToId?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Incident"> | Date | string | null
    rootCause?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    resolution?: StringNullableWithAggregatesFilter<"Incident"> | string | null
    affectedResources?: JsonNullableWithAggregatesFilter<"Incident">
    createdAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Incident"> | Date | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    slug?: StringFilter<"Plan"> | string
    gameType?: EnumGameTypeFilter<"Plan"> | $Enums.GameType
    status?: EnumPlanStatusFilter<"Plan"> | $Enums.PlanStatus
    ramMb?: IntFilter<"Plan"> | number
    cpuCores?: IntFilter<"Plan"> | number
    diskGb?: IntFilter<"Plan"> | number
    maxSlots?: IntNullableFilter<"Plan"> | number | null
    monthlyPrice?: IntFilter<"Plan"> | number
    hourlyPrice?: IntNullableFilter<"Plan"> | number | null
    setupFee?: IntFilter<"Plan"> | number
    features?: JsonNullableFilter<"Plan">
    description?: StringNullableFilter<"Plan"> | string | null
    isPopular?: BoolFilter<"Plan"> | boolean
    sortOrder?: IntFilter<"Plan"> | number
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    servers?: GameServerListRelationFilter
    orders?: OrderListRelationFilter
    promotions?: PromotionListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    gameType?: SortOrder
    status?: SortOrder
    ramMb?: SortOrder
    cpuCores?: SortOrder
    diskGb?: SortOrder
    maxSlots?: SortOrderInput | SortOrder
    monthlyPrice?: SortOrder
    hourlyPrice?: SortOrderInput | SortOrder
    setupFee?: SortOrder
    features?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isPopular?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    servers?: GameServerOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    promotions?: PromotionOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringFilter<"Plan"> | string
    gameType?: EnumGameTypeFilter<"Plan"> | $Enums.GameType
    status?: EnumPlanStatusFilter<"Plan"> | $Enums.PlanStatus
    ramMb?: IntFilter<"Plan"> | number
    cpuCores?: IntFilter<"Plan"> | number
    diskGb?: IntFilter<"Plan"> | number
    maxSlots?: IntNullableFilter<"Plan"> | number | null
    monthlyPrice?: IntFilter<"Plan"> | number
    hourlyPrice?: IntNullableFilter<"Plan"> | number | null
    setupFee?: IntFilter<"Plan"> | number
    features?: JsonNullableFilter<"Plan">
    description?: StringNullableFilter<"Plan"> | string | null
    isPopular?: BoolFilter<"Plan"> | boolean
    sortOrder?: IntFilter<"Plan"> | number
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    servers?: GameServerListRelationFilter
    orders?: OrderListRelationFilter
    promotions?: PromotionListRelationFilter
  }, "id" | "slug">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    gameType?: SortOrder
    status?: SortOrder
    ramMb?: SortOrder
    cpuCores?: SortOrder
    diskGb?: SortOrder
    maxSlots?: SortOrderInput | SortOrder
    monthlyPrice?: SortOrder
    hourlyPrice?: SortOrderInput | SortOrder
    setupFee?: SortOrder
    features?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isPopular?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    slug?: StringWithAggregatesFilter<"Plan"> | string
    gameType?: EnumGameTypeWithAggregatesFilter<"Plan"> | $Enums.GameType
    status?: EnumPlanStatusWithAggregatesFilter<"Plan"> | $Enums.PlanStatus
    ramMb?: IntWithAggregatesFilter<"Plan"> | number
    cpuCores?: IntWithAggregatesFilter<"Plan"> | number
    diskGb?: IntWithAggregatesFilter<"Plan"> | number
    maxSlots?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    monthlyPrice?: IntWithAggregatesFilter<"Plan"> | number
    hourlyPrice?: IntNullableWithAggregatesFilter<"Plan"> | number | null
    setupFee?: IntWithAggregatesFilter<"Plan"> | number
    features?: JsonNullableWithAggregatesFilter<"Plan">
    description?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    isPopular?: BoolWithAggregatesFilter<"Plan"> | boolean
    sortOrder?: IntWithAggregatesFilter<"Plan"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: StringFilter<"Promotion"> | string
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    scope?: EnumPromotionScopeFilter<"Promotion"> | $Enums.PromotionScope
    discountPercent?: IntFilter<"Promotion"> | number
    gameType?: EnumGameTypeNullableFilter<"Promotion"> | $Enums.GameType | null
    planId?: StringNullableFilter<"Promotion"> | string | null
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    active?: BoolFilter<"Promotion"> | boolean
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    plan?: XOR<PlanNullableRelationFilter, PlanWhereInput> | null
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    scope?: SortOrder
    discountPercent?: SortOrder
    gameType?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    scope?: EnumPromotionScopeFilter<"Promotion"> | $Enums.PromotionScope
    discountPercent?: IntFilter<"Promotion"> | number
    gameType?: EnumGameTypeNullableFilter<"Promotion"> | $Enums.GameType | null
    planId?: StringNullableFilter<"Promotion"> | string | null
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    active?: BoolFilter<"Promotion"> | boolean
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    plan?: XOR<PlanNullableRelationFilter, PlanWhereInput> | null
  }, "id">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    scope?: SortOrder
    discountPercent?: SortOrder
    gameType?: SortOrderInput | SortOrder
    planId?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Promotion"> | string
    name?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    scope?: EnumPromotionScopeWithAggregatesFilter<"Promotion"> | $Enums.PromotionScope
    discountPercent?: IntWithAggregatesFilter<"Promotion"> | number
    gameType?: EnumGameTypeNullableWithAggregatesFilter<"Promotion"> | $Enums.GameType | null
    planId?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Promotion"> | Date | string | null
    active?: BoolWithAggregatesFilter<"Promotion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    planId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    priceSnapshot?: JsonFilter<"Order">
    totalAmount?: IntFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentId?: StringNullableFilter<"Order"> | string | null
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    serverId?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
    server?: XOR<GameServerNullableRelationFilter, GameServerWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    priceSnapshot?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    serverId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    plan?: PlanOrderByWithRelationInput
    server?: GameServerOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serverId?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    userId?: StringFilter<"Order"> | string
    planId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    priceSnapshot?: JsonFilter<"Order">
    totalAmount?: IntFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentId?: StringNullableFilter<"Order"> | string | null
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    plan?: XOR<PlanRelationFilter, PlanWhereInput>
    server?: XOR<GameServerNullableRelationFilter, GameServerWhereInput> | null
  }, "id" | "serverId">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    priceSnapshot?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    serverId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    userId?: StringWithAggregatesFilter<"Order"> | string
    planId?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    priceSnapshot?: JsonWithAggregatesFilter<"Order">
    totalAmount?: IntWithAggregatesFilter<"Order"> | number
    currency?: StringWithAggregatesFilter<"Order"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paymentId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    serverId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type PaymentEventWhereInput = {
    AND?: PaymentEventWhereInput | PaymentEventWhereInput[]
    OR?: PaymentEventWhereInput[]
    NOT?: PaymentEventWhereInput | PaymentEventWhereInput[]
    id?: StringFilter<"PaymentEvent"> | string
    provider?: EnumPaymentProviderFilter<"PaymentEvent"> | $Enums.PaymentProvider
    eventType?: StringFilter<"PaymentEvent"> | string
    eventId?: StringFilter<"PaymentEvent"> | string
    paymentId?: StringNullableFilter<"PaymentEvent"> | string | null
    orderId?: StringNullableFilter<"PaymentEvent"> | string | null
    status?: EnumPaymentEventStatusFilter<"PaymentEvent"> | $Enums.PaymentEventStatus
    payload?: JsonNullableFilter<"PaymentEvent">
    error?: StringNullableFilter<"PaymentEvent"> | string | null
    createdAt?: DateTimeFilter<"PaymentEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"PaymentEvent"> | Date | string | null
    updatedAt?: DateTimeFilter<"PaymentEvent"> | Date | string
  }

  export type PaymentEventOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    eventId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    status?: SortOrder
    payload?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_eventType_eventId?: PaymentEventProviderEventTypeEventIdCompoundUniqueInput
    AND?: PaymentEventWhereInput | PaymentEventWhereInput[]
    OR?: PaymentEventWhereInput[]
    NOT?: PaymentEventWhereInput | PaymentEventWhereInput[]
    provider?: EnumPaymentProviderFilter<"PaymentEvent"> | $Enums.PaymentProvider
    eventType?: StringFilter<"PaymentEvent"> | string
    eventId?: StringFilter<"PaymentEvent"> | string
    paymentId?: StringNullableFilter<"PaymentEvent"> | string | null
    orderId?: StringNullableFilter<"PaymentEvent"> | string | null
    status?: EnumPaymentEventStatusFilter<"PaymentEvent"> | $Enums.PaymentEventStatus
    payload?: JsonNullableFilter<"PaymentEvent">
    error?: StringNullableFilter<"PaymentEvent"> | string | null
    createdAt?: DateTimeFilter<"PaymentEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"PaymentEvent"> | Date | string | null
    updatedAt?: DateTimeFilter<"PaymentEvent"> | Date | string
  }, "id" | "provider_eventType_eventId">

  export type PaymentEventOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    eventId?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    status?: SortOrder
    payload?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: PaymentEventCountOrderByAggregateInput
    _max?: PaymentEventMaxOrderByAggregateInput
    _min?: PaymentEventMinOrderByAggregateInput
  }

  export type PaymentEventScalarWhereWithAggregatesInput = {
    AND?: PaymentEventScalarWhereWithAggregatesInput | PaymentEventScalarWhereWithAggregatesInput[]
    OR?: PaymentEventScalarWhereWithAggregatesInput[]
    NOT?: PaymentEventScalarWhereWithAggregatesInput | PaymentEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentEvent"> | string
    provider?: EnumPaymentProviderWithAggregatesFilter<"PaymentEvent"> | $Enums.PaymentProvider
    eventType?: StringWithAggregatesFilter<"PaymentEvent"> | string
    eventId?: StringWithAggregatesFilter<"PaymentEvent"> | string
    paymentId?: StringNullableWithAggregatesFilter<"PaymentEvent"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"PaymentEvent"> | string | null
    status?: EnumPaymentEventStatusWithAggregatesFilter<"PaymentEvent"> | $Enums.PaymentEventStatus
    payload?: JsonNullableWithAggregatesFilter<"PaymentEvent">
    error?: StringNullableWithAggregatesFilter<"PaymentEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentEvent"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"PaymentEvent"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentEvent"> | Date | string
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    ticketNumber?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    priority?: EnumTicketPriorityFilter<"SupportTicket"> | $Enums.TicketPriority
    category?: StringNullableFilter<"SupportTicket"> | string | null
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    assignedToId?: StringNullableFilter<"SupportTicket"> | string | null
    assignedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    slaResponseDeadline?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    slaResolveDeadline?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    firstResponseAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    userId?: StringFilter<"SupportTicket"> | string
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    closedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    comments?: TicketCommentListRelationFilter
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    slaResponseDeadline?: SortOrderInput | SortOrder
    slaResolveDeadline?: SortOrderInput | SortOrder
    firstResponseAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    assignedTo?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    comments?: TicketCommentOrderByRelationAggregateInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ticketNumber?: string
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    subject?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    priority?: EnumTicketPriorityFilter<"SupportTicket"> | $Enums.TicketPriority
    category?: StringNullableFilter<"SupportTicket"> | string | null
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    assignedToId?: StringNullableFilter<"SupportTicket"> | string | null
    assignedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    slaResponseDeadline?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    slaResolveDeadline?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    firstResponseAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    userId?: StringFilter<"SupportTicket"> | string
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    closedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    assignedTo?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    comments?: TicketCommentListRelationFilter
  }, "id" | "ticketNumber">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    category?: SortOrderInput | SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    slaResponseDeadline?: SortOrderInput | SortOrder
    slaResolveDeadline?: SortOrderInput | SortOrder
    firstResponseAt?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportTicket"> | string
    ticketNumber?: StringWithAggregatesFilter<"SupportTicket"> | string
    subject?: StringWithAggregatesFilter<"SupportTicket"> | string
    description?: StringWithAggregatesFilter<"SupportTicket"> | string
    priority?: EnumTicketPriorityWithAggregatesFilter<"SupportTicket"> | $Enums.TicketPriority
    category?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    status?: EnumTicketStatusWithAggregatesFilter<"SupportTicket"> | $Enums.TicketStatus
    assignedToId?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"SupportTicket"> | Date | string | null
    slaResponseDeadline?: DateTimeNullableWithAggregatesFilter<"SupportTicket"> | Date | string | null
    slaResolveDeadline?: DateTimeNullableWithAggregatesFilter<"SupportTicket"> | Date | string | null
    firstResponseAt?: DateTimeNullableWithAggregatesFilter<"SupportTicket"> | Date | string | null
    userId?: StringWithAggregatesFilter<"SupportTicket"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"SupportTicket"> | Date | string | null
  }

  export type SlaPolicyWhereInput = {
    AND?: SlaPolicyWhereInput | SlaPolicyWhereInput[]
    OR?: SlaPolicyWhereInput[]
    NOT?: SlaPolicyWhereInput | SlaPolicyWhereInput[]
    id?: StringFilter<"SlaPolicy"> | string
    priority?: EnumTicketPriorityFilter<"SlaPolicy"> | $Enums.TicketPriority
    responseTimeHours?: IntFilter<"SlaPolicy"> | number
    resolveTimeHours?: IntFilter<"SlaPolicy"> | number
    createdAt?: DateTimeFilter<"SlaPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"SlaPolicy"> | Date | string
  }

  export type SlaPolicyOrderByWithRelationInput = {
    id?: SortOrder
    priority?: SortOrder
    responseTimeHours?: SortOrder
    resolveTimeHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlaPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    priority?: $Enums.TicketPriority
    AND?: SlaPolicyWhereInput | SlaPolicyWhereInput[]
    OR?: SlaPolicyWhereInput[]
    NOT?: SlaPolicyWhereInput | SlaPolicyWhereInput[]
    responseTimeHours?: IntFilter<"SlaPolicy"> | number
    resolveTimeHours?: IntFilter<"SlaPolicy"> | number
    createdAt?: DateTimeFilter<"SlaPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"SlaPolicy"> | Date | string
  }, "id" | "priority">

  export type SlaPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    priority?: SortOrder
    responseTimeHours?: SortOrder
    resolveTimeHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SlaPolicyCountOrderByAggregateInput
    _avg?: SlaPolicyAvgOrderByAggregateInput
    _max?: SlaPolicyMaxOrderByAggregateInput
    _min?: SlaPolicyMinOrderByAggregateInput
    _sum?: SlaPolicySumOrderByAggregateInput
  }

  export type SlaPolicyScalarWhereWithAggregatesInput = {
    AND?: SlaPolicyScalarWhereWithAggregatesInput | SlaPolicyScalarWhereWithAggregatesInput[]
    OR?: SlaPolicyScalarWhereWithAggregatesInput[]
    NOT?: SlaPolicyScalarWhereWithAggregatesInput | SlaPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SlaPolicy"> | string
    priority?: EnumTicketPriorityWithAggregatesFilter<"SlaPolicy"> | $Enums.TicketPriority
    responseTimeHours?: IntWithAggregatesFilter<"SlaPolicy"> | number
    resolveTimeHours?: IntWithAggregatesFilter<"SlaPolicy"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SlaPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SlaPolicy"> | Date | string
  }

  export type TicketCommentWhereInput = {
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    id?: StringFilter<"TicketComment"> | string
    ticketId?: StringFilter<"TicketComment"> | string
    authorId?: StringFilter<"TicketComment"> | string
    message?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticket?: XOR<SupportTicketRelationFilter, SupportTicketWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TicketCommentOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticket?: SupportTicketOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type TicketCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    ticketId?: StringFilter<"TicketComment"> | string
    authorId?: StringFilter<"TicketComment"> | string
    message?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticket?: XOR<SupportTicketRelationFilter, SupportTicketWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type TicketCommentOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TicketCommentCountOrderByAggregateInput
    _max?: TicketCommentMaxOrderByAggregateInput
    _min?: TicketCommentMinOrderByAggregateInput
  }

  export type TicketCommentScalarWhereWithAggregatesInput = {
    AND?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    OR?: TicketCommentScalarWhereWithAggregatesInput[]
    NOT?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketComment"> | string
    ticketId?: StringWithAggregatesFilter<"TicketComment"> | string
    authorId?: StringWithAggregatesFilter<"TicketComment"> | string
    message?: StringWithAggregatesFilter<"TicketComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TicketComment"> | Date | string
  }

  export type KnowledgeBaseArticleWhereInput = {
    AND?: KnowledgeBaseArticleWhereInput | KnowledgeBaseArticleWhereInput[]
    OR?: KnowledgeBaseArticleWhereInput[]
    NOT?: KnowledgeBaseArticleWhereInput | KnowledgeBaseArticleWhereInput[]
    id?: StringFilter<"KnowledgeBaseArticle"> | string
    title?: StringFilter<"KnowledgeBaseArticle"> | string
    slug?: StringFilter<"KnowledgeBaseArticle"> | string
    content?: StringFilter<"KnowledgeBaseArticle"> | string
    excerpt?: StringNullableFilter<"KnowledgeBaseArticle"> | string | null
    categoryId?: StringFilter<"KnowledgeBaseArticle"> | string
    authorId?: StringFilter<"KnowledgeBaseArticle"> | string
    tags?: JsonFilter<"KnowledgeBaseArticle">
    published?: BoolFilter<"KnowledgeBaseArticle"> | boolean
    views?: IntFilter<"KnowledgeBaseArticle"> | number
    helpful?: IntFilter<"KnowledgeBaseArticle"> | number
    notHelpful?: IntFilter<"KnowledgeBaseArticle"> | number
    createdAt?: DateTimeFilter<"KnowledgeBaseArticle"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBaseArticle"> | Date | string
    publishedAt?: DateTimeNullableFilter<"KnowledgeBaseArticle"> | Date | string | null
    category?: XOR<KnowledgeBaseCategoryRelationFilter, KnowledgeBaseCategoryWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    versions?: ArticleVersionListRelationFilter
  }

  export type KnowledgeBaseArticleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    tags?: SortOrder
    published?: SortOrder
    views?: SortOrder
    helpful?: SortOrder
    notHelpful?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    category?: KnowledgeBaseCategoryOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    versions?: ArticleVersionOrderByRelationAggregateInput
  }

  export type KnowledgeBaseArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: KnowledgeBaseArticleWhereInput | KnowledgeBaseArticleWhereInput[]
    OR?: KnowledgeBaseArticleWhereInput[]
    NOT?: KnowledgeBaseArticleWhereInput | KnowledgeBaseArticleWhereInput[]
    title?: StringFilter<"KnowledgeBaseArticle"> | string
    content?: StringFilter<"KnowledgeBaseArticle"> | string
    excerpt?: StringNullableFilter<"KnowledgeBaseArticle"> | string | null
    categoryId?: StringFilter<"KnowledgeBaseArticle"> | string
    authorId?: StringFilter<"KnowledgeBaseArticle"> | string
    tags?: JsonFilter<"KnowledgeBaseArticle">
    published?: BoolFilter<"KnowledgeBaseArticle"> | boolean
    views?: IntFilter<"KnowledgeBaseArticle"> | number
    helpful?: IntFilter<"KnowledgeBaseArticle"> | number
    notHelpful?: IntFilter<"KnowledgeBaseArticle"> | number
    createdAt?: DateTimeFilter<"KnowledgeBaseArticle"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBaseArticle"> | Date | string
    publishedAt?: DateTimeNullableFilter<"KnowledgeBaseArticle"> | Date | string | null
    category?: XOR<KnowledgeBaseCategoryRelationFilter, KnowledgeBaseCategoryWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    versions?: ArticleVersionListRelationFilter
  }, "id" | "slug">

  export type KnowledgeBaseArticleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    tags?: SortOrder
    published?: SortOrder
    views?: SortOrder
    helpful?: SortOrder
    notHelpful?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    _count?: KnowledgeBaseArticleCountOrderByAggregateInput
    _avg?: KnowledgeBaseArticleAvgOrderByAggregateInput
    _max?: KnowledgeBaseArticleMaxOrderByAggregateInput
    _min?: KnowledgeBaseArticleMinOrderByAggregateInput
    _sum?: KnowledgeBaseArticleSumOrderByAggregateInput
  }

  export type KnowledgeBaseArticleScalarWhereWithAggregatesInput = {
    AND?: KnowledgeBaseArticleScalarWhereWithAggregatesInput | KnowledgeBaseArticleScalarWhereWithAggregatesInput[]
    OR?: KnowledgeBaseArticleScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeBaseArticleScalarWhereWithAggregatesInput | KnowledgeBaseArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeBaseArticle"> | string
    title?: StringWithAggregatesFilter<"KnowledgeBaseArticle"> | string
    slug?: StringWithAggregatesFilter<"KnowledgeBaseArticle"> | string
    content?: StringWithAggregatesFilter<"KnowledgeBaseArticle"> | string
    excerpt?: StringNullableWithAggregatesFilter<"KnowledgeBaseArticle"> | string | null
    categoryId?: StringWithAggregatesFilter<"KnowledgeBaseArticle"> | string
    authorId?: StringWithAggregatesFilter<"KnowledgeBaseArticle"> | string
    tags?: JsonWithAggregatesFilter<"KnowledgeBaseArticle">
    published?: BoolWithAggregatesFilter<"KnowledgeBaseArticle"> | boolean
    views?: IntWithAggregatesFilter<"KnowledgeBaseArticle"> | number
    helpful?: IntWithAggregatesFilter<"KnowledgeBaseArticle"> | number
    notHelpful?: IntWithAggregatesFilter<"KnowledgeBaseArticle"> | number
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeBaseArticle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeBaseArticle"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"KnowledgeBaseArticle"> | Date | string | null
  }

  export type KnowledgeBaseCategoryWhereInput = {
    AND?: KnowledgeBaseCategoryWhereInput | KnowledgeBaseCategoryWhereInput[]
    OR?: KnowledgeBaseCategoryWhereInput[]
    NOT?: KnowledgeBaseCategoryWhereInput | KnowledgeBaseCategoryWhereInput[]
    id?: StringFilter<"KnowledgeBaseCategory"> | string
    name?: StringFilter<"KnowledgeBaseCategory"> | string
    slug?: StringFilter<"KnowledgeBaseCategory"> | string
    description?: StringNullableFilter<"KnowledgeBaseCategory"> | string | null
    icon?: StringNullableFilter<"KnowledgeBaseCategory"> | string | null
    order?: IntFilter<"KnowledgeBaseCategory"> | number
    parentId?: StringNullableFilter<"KnowledgeBaseCategory"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeBaseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBaseCategory"> | Date | string
    parent?: XOR<KnowledgeBaseCategoryNullableRelationFilter, KnowledgeBaseCategoryWhereInput> | null
    children?: KnowledgeBaseCategoryListRelationFilter
    articles?: KnowledgeBaseArticleListRelationFilter
  }

  export type KnowledgeBaseCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: KnowledgeBaseCategoryOrderByWithRelationInput
    children?: KnowledgeBaseCategoryOrderByRelationAggregateInput
    articles?: KnowledgeBaseArticleOrderByRelationAggregateInput
  }

  export type KnowledgeBaseCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: KnowledgeBaseCategoryWhereInput | KnowledgeBaseCategoryWhereInput[]
    OR?: KnowledgeBaseCategoryWhereInput[]
    NOT?: KnowledgeBaseCategoryWhereInput | KnowledgeBaseCategoryWhereInput[]
    description?: StringNullableFilter<"KnowledgeBaseCategory"> | string | null
    icon?: StringNullableFilter<"KnowledgeBaseCategory"> | string | null
    order?: IntFilter<"KnowledgeBaseCategory"> | number
    parentId?: StringNullableFilter<"KnowledgeBaseCategory"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeBaseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBaseCategory"> | Date | string
    parent?: XOR<KnowledgeBaseCategoryNullableRelationFilter, KnowledgeBaseCategoryWhereInput> | null
    children?: KnowledgeBaseCategoryListRelationFilter
    articles?: KnowledgeBaseArticleListRelationFilter
  }, "id" | "name" | "slug">

  export type KnowledgeBaseCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeBaseCategoryCountOrderByAggregateInput
    _avg?: KnowledgeBaseCategoryAvgOrderByAggregateInput
    _max?: KnowledgeBaseCategoryMaxOrderByAggregateInput
    _min?: KnowledgeBaseCategoryMinOrderByAggregateInput
    _sum?: KnowledgeBaseCategorySumOrderByAggregateInput
  }

  export type KnowledgeBaseCategoryScalarWhereWithAggregatesInput = {
    AND?: KnowledgeBaseCategoryScalarWhereWithAggregatesInput | KnowledgeBaseCategoryScalarWhereWithAggregatesInput[]
    OR?: KnowledgeBaseCategoryScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeBaseCategoryScalarWhereWithAggregatesInput | KnowledgeBaseCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeBaseCategory"> | string
    name?: StringWithAggregatesFilter<"KnowledgeBaseCategory"> | string
    slug?: StringWithAggregatesFilter<"KnowledgeBaseCategory"> | string
    description?: StringNullableWithAggregatesFilter<"KnowledgeBaseCategory"> | string | null
    icon?: StringNullableWithAggregatesFilter<"KnowledgeBaseCategory"> | string | null
    order?: IntWithAggregatesFilter<"KnowledgeBaseCategory"> | number
    parentId?: StringNullableWithAggregatesFilter<"KnowledgeBaseCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeBaseCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeBaseCategory"> | Date | string
  }

  export type ArticleVersionWhereInput = {
    AND?: ArticleVersionWhereInput | ArticleVersionWhereInput[]
    OR?: ArticleVersionWhereInput[]
    NOT?: ArticleVersionWhereInput | ArticleVersionWhereInput[]
    id?: StringFilter<"ArticleVersion"> | string
    articleId?: StringFilter<"ArticleVersion"> | string
    version?: IntFilter<"ArticleVersion"> | number
    title?: StringFilter<"ArticleVersion"> | string
    content?: StringFilter<"ArticleVersion"> | string
    excerpt?: StringNullableFilter<"ArticleVersion"> | string | null
    createdBy?: StringFilter<"ArticleVersion"> | string
    createdAt?: DateTimeFilter<"ArticleVersion"> | Date | string
    article?: XOR<KnowledgeBaseArticleRelationFilter, KnowledgeBaseArticleWhereInput>
  }

  export type ArticleVersionOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    article?: KnowledgeBaseArticleOrderByWithRelationInput
  }

  export type ArticleVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    articleId_version?: ArticleVersionArticleIdVersionCompoundUniqueInput
    AND?: ArticleVersionWhereInput | ArticleVersionWhereInput[]
    OR?: ArticleVersionWhereInput[]
    NOT?: ArticleVersionWhereInput | ArticleVersionWhereInput[]
    articleId?: StringFilter<"ArticleVersion"> | string
    version?: IntFilter<"ArticleVersion"> | number
    title?: StringFilter<"ArticleVersion"> | string
    content?: StringFilter<"ArticleVersion"> | string
    excerpt?: StringNullableFilter<"ArticleVersion"> | string | null
    createdBy?: StringFilter<"ArticleVersion"> | string
    createdAt?: DateTimeFilter<"ArticleVersion"> | Date | string
    article?: XOR<KnowledgeBaseArticleRelationFilter, KnowledgeBaseArticleWhereInput>
  }, "id" | "articleId_version">

  export type ArticleVersionOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: ArticleVersionCountOrderByAggregateInput
    _avg?: ArticleVersionAvgOrderByAggregateInput
    _max?: ArticleVersionMaxOrderByAggregateInput
    _min?: ArticleVersionMinOrderByAggregateInput
    _sum?: ArticleVersionSumOrderByAggregateInput
  }

  export type ArticleVersionScalarWhereWithAggregatesInput = {
    AND?: ArticleVersionScalarWhereWithAggregatesInput | ArticleVersionScalarWhereWithAggregatesInput[]
    OR?: ArticleVersionScalarWhereWithAggregatesInput[]
    NOT?: ArticleVersionScalarWhereWithAggregatesInput | ArticleVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArticleVersion"> | string
    articleId?: StringWithAggregatesFilter<"ArticleVersion"> | string
    version?: IntWithAggregatesFilter<"ArticleVersion"> | number
    title?: StringWithAggregatesFilter<"ArticleVersion"> | string
    content?: StringWithAggregatesFilter<"ArticleVersion"> | string
    excerpt?: StringNullableWithAggregatesFilter<"ArticleVersion"> | string | null
    createdBy?: StringWithAggregatesFilter<"ArticleVersion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ArticleVersion"> | Date | string
  }

  export type InvoiceMetadataWhereInput = {
    AND?: InvoiceMetadataWhereInput | InvoiceMetadataWhereInput[]
    OR?: InvoiceMetadataWhereInput[]
    NOT?: InvoiceMetadataWhereInput | InvoiceMetadataWhereInput[]
    id?: StringFilter<"InvoiceMetadata"> | string
    tenantId?: StringNullableFilter<"InvoiceMetadata"> | string | null
    prefix?: StringFilter<"InvoiceMetadata"> | string
    sequenceNumber?: IntFilter<"InvoiceMetadata"> | number
    lastUsedDate?: DateTimeFilter<"InvoiceMetadata"> | Date | string
    year?: IntNullableFilter<"InvoiceMetadata"> | number | null
    createdAt?: DateTimeFilter<"InvoiceMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceMetadata"> | Date | string
  }

  export type InvoiceMetadataOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    prefix?: SortOrder
    sequenceNumber?: SortOrder
    lastUsedDate?: SortOrder
    year?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_prefix_year?: InvoiceMetadataTenantIdPrefixYearCompoundUniqueInput
    AND?: InvoiceMetadataWhereInput | InvoiceMetadataWhereInput[]
    OR?: InvoiceMetadataWhereInput[]
    NOT?: InvoiceMetadataWhereInput | InvoiceMetadataWhereInput[]
    tenantId?: StringNullableFilter<"InvoiceMetadata"> | string | null
    prefix?: StringFilter<"InvoiceMetadata"> | string
    sequenceNumber?: IntFilter<"InvoiceMetadata"> | number
    lastUsedDate?: DateTimeFilter<"InvoiceMetadata"> | Date | string
    year?: IntNullableFilter<"InvoiceMetadata"> | number | null
    createdAt?: DateTimeFilter<"InvoiceMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceMetadata"> | Date | string
  }, "id" | "tenantId_prefix_year">

  export type InvoiceMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    prefix?: SortOrder
    sequenceNumber?: SortOrder
    lastUsedDate?: SortOrder
    year?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceMetadataCountOrderByAggregateInput
    _avg?: InvoiceMetadataAvgOrderByAggregateInput
    _max?: InvoiceMetadataMaxOrderByAggregateInput
    _min?: InvoiceMetadataMinOrderByAggregateInput
    _sum?: InvoiceMetadataSumOrderByAggregateInput
  }

  export type InvoiceMetadataScalarWhereWithAggregatesInput = {
    AND?: InvoiceMetadataScalarWhereWithAggregatesInput | InvoiceMetadataScalarWhereWithAggregatesInput[]
    OR?: InvoiceMetadataScalarWhereWithAggregatesInput[]
    NOT?: InvoiceMetadataScalarWhereWithAggregatesInput | InvoiceMetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceMetadata"> | string
    tenantId?: StringNullableWithAggregatesFilter<"InvoiceMetadata"> | string | null
    prefix?: StringWithAggregatesFilter<"InvoiceMetadata"> | string
    sequenceNumber?: IntWithAggregatesFilter<"InvoiceMetadata"> | number
    lastUsedDate?: DateTimeWithAggregatesFilter<"InvoiceMetadata"> | Date | string
    year?: IntNullableWithAggregatesFilter<"InvoiceMetadata"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceMetadata"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvoiceMetadata"> | Date | string
  }

  export type SystemLicenseCreateInput = {
    id?: string
    licenseKey: string
    status: $Enums.LicenseStatus
    validUntil: Date | string
    maxNodesAllowed: number
    whitelabelEnabled?: boolean
    signature: string
    gracePeriodEnds?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemLicenseUncheckedCreateInput = {
    id?: string
    licenseKey: string
    status: $Enums.LicenseStatus
    validUntil: Date | string
    maxNodesAllowed: number
    whitelabelEnabled?: boolean
    signature: string
    gracePeriodEnds?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemLicenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    maxNodesAllowed?: IntFieldUpdateOperationsInput | number
    whitelabelEnabled?: BoolFieldUpdateOperationsInput | boolean
    signature?: StringFieldUpdateOperationsInput | string
    gracePeriodEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLicenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    maxNodesAllowed?: IntFieldUpdateOperationsInput | number
    whitelabelEnabled?: BoolFieldUpdateOperationsInput | boolean
    signature?: StringFieldUpdateOperationsInput | string
    gracePeriodEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLicenseCreateManyInput = {
    id?: string
    licenseKey: string
    status: $Enums.LicenseStatus
    validUntil: Date | string
    maxNodesAllowed: number
    whitelabelEnabled?: boolean
    signature: string
    gracePeriodEnds?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemLicenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    maxNodesAllowed?: IntFieldUpdateOperationsInput | number
    whitelabelEnabled?: BoolFieldUpdateOperationsInput | boolean
    signature?: StringFieldUpdateOperationsInput | string
    gracePeriodEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLicenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    status?: EnumLicenseStatusFieldUpdateOperationsInput | $Enums.LicenseStatus
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    maxNodesAllowed?: IntFieldUpdateOperationsInput | number
    whitelabelEnabled?: BoolFieldUpdateOperationsInput | boolean
    signature?: StringFieldUpdateOperationsInput | string
    gracePeriodEnds?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    domain: string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    domain: string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    domain: string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    ownedServers?: GameServerCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentCreateNestedManyWithoutAssignedToInput
    orders?: OrderCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerUncheckedCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertUncheckedCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentUncheckedCreateNestedManyWithoutAssignedToInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    ownedServers?: GameServerUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUncheckedUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUncheckedUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUncheckedUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resourceId: string
    ipAddress: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resourceId: string
    ipAddress: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    resourceId: string
    ipAddress: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeCreateInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerCreateNestedManyWithoutNodeInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutNodeInput
    metrics?: MetricCreateNestedManyWithoutNodeInput
    alerts?: AlertCreateNestedManyWithoutNodeInput
    storageClusters?: GameClusterCreateNestedManyWithoutStorageNodeInput
    tasks?: TaskCreateNestedManyWithoutNodeInput
  }

  export type NodeUncheckedCreateInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerUncheckedCreateNestedManyWithoutNodeInput
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutNodeInput
    metrics?: MetricUncheckedCreateNestedManyWithoutNodeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutNodeInput
    storageClusters?: GameClusterUncheckedCreateNestedManyWithoutStorageNodeInput
    tasks?: TaskUncheckedCreateNestedManyWithoutNodeInput
  }

  export type NodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUpdateManyWithoutNodeNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutNodeNestedInput
    metrics?: MetricUpdateManyWithoutNodeNestedInput
    alerts?: AlertUpdateManyWithoutNodeNestedInput
    storageClusters?: GameClusterUpdateManyWithoutStorageNodeNestedInput
    tasks?: TaskUpdateManyWithoutNodeNestedInput
  }

  export type NodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUncheckedUpdateManyWithoutNodeNestedInput
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutNodeNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutNodeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutNodeNestedInput
    storageClusters?: GameClusterUncheckedUpdateManyWithoutStorageNodeNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type NodeCreateManyInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    type: $Enums.TaskType
    status?: $Enums.TaskStatus
    data: JsonNullValueInput | InputJsonValue
    error?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    nodeId: string
    type: $Enums.TaskType
    status?: $Enums.TaskStatus
    data: JsonNullValueInput | InputJsonValue
    error?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    data?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    data?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    nodeId: string
    type: $Enums.TaskType
    status?: $Enums.TaskStatus
    data: JsonNullValueInput | InputJsonValue
    error?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    data?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    data?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkAllocationCreateInput = {
    id?: string
    port: number
    protocol: $Enums.Protocol
    type: $Enums.PortType
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutNetworkAllocationsInput
    server?: GameServerCreateNestedOneWithoutNetworkAllocationsInput
  }

  export type NetworkAllocationUncheckedCreateInput = {
    id?: string
    nodeId: string
    port: number
    protocol: $Enums.Protocol
    type: $Enums.PortType
    serverUuid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkAllocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    type?: EnumPortTypeFieldUpdateOperationsInput | $Enums.PortType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutNetworkAllocationsNestedInput
    server?: GameServerUpdateOneWithoutNetworkAllocationsNestedInput
  }

  export type NetworkAllocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    type?: EnumPortTypeFieldUpdateOperationsInput | $Enums.PortType
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkAllocationCreateManyInput = {
    id?: string
    nodeId: string
    port: number
    protocol: $Enums.Protocol
    type: $Enums.PortType
    serverUuid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkAllocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    type?: EnumPortTypeFieldUpdateOperationsInput | $Enums.PortType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkAllocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    type?: EnumPortTypeFieldUpdateOperationsInput | $Enums.PortType
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdomainCreateInput = {
    id?: string
    subdomain: string
    domain: string
    cloudflareId: string
    targetIP: string
    createdAt?: Date | string
    updatedAt?: Date | string
    server: GameServerCreateNestedOneWithoutSubdomainsInput
  }

  export type SubdomainUncheckedCreateInput = {
    id?: string
    subdomain: string
    domain: string
    serverUuid: string
    cloudflareId: string
    targetIP: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubdomainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    cloudflareId?: StringFieldUpdateOperationsInput | string
    targetIP?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    server?: GameServerUpdateOneRequiredWithoutSubdomainsNestedInput
  }

  export type SubdomainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    serverUuid?: StringFieldUpdateOperationsInput | string
    cloudflareId?: StringFieldUpdateOperationsInput | string
    targetIP?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdomainCreateManyInput = {
    id?: string
    subdomain: string
    domain: string
    serverUuid: string
    cloudflareId: string
    targetIP: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubdomainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    cloudflareId?: StringFieldUpdateOperationsInput | string
    targetIP?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdomainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    serverUuid?: StringFieldUpdateOperationsInput | string
    cloudflareId?: StringFieldUpdateOperationsInput | string
    targetIP?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameServerCreateInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutServersInput
    owner: UserCreateNestedOneWithoutOwnedServersInput
    plan?: PlanCreateNestedOneWithoutServersInput
    cluster?: GameClusterCreateNestedOneWithoutServersInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutServerInput
    subdomains?: SubdomainCreateNestedManyWithoutServerInput
    backups?: BackupCreateNestedManyWithoutServerInput
    metrics?: MetricCreateNestedManyWithoutServerInput
    alerts?: AlertCreateNestedManyWithoutServerInput
    orders?: OrderCreateNestedManyWithoutServerInput
  }

  export type GameServerUncheckedCreateInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutServerInput
    subdomains?: SubdomainUncheckedCreateNestedManyWithoutServerInput
    backups?: BackupUncheckedCreateNestedManyWithoutServerInput
    metrics?: MetricUncheckedCreateNestedManyWithoutServerInput
    alerts?: AlertUncheckedCreateNestedManyWithoutServerInput
    orders?: OrderUncheckedCreateNestedManyWithoutServerInput
  }

  export type GameServerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutServersNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedServersNestedInput
    plan?: PlanUpdateOneWithoutServersNestedInput
    cluster?: GameClusterUpdateOneWithoutServersNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUpdateManyWithoutServerNestedInput
    backups?: BackupUpdateManyWithoutServerNestedInput
    metrics?: MetricUpdateManyWithoutServerNestedInput
    alerts?: AlertUpdateManyWithoutServerNestedInput
    orders?: OrderUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUncheckedUpdateManyWithoutServerNestedInput
    backups?: BackupUncheckedUpdateManyWithoutServerNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutServerNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutServerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutServerNestedInput
  }

  export type GameServerCreateManyInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameServerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameServerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameClusterCreateInput = {
    id?: string
    gameType: $Enums.GameType
    sharedSecret: string
    mountPath: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storageNode: NodeCreateNestedOneWithoutStorageClustersInput
    servers?: GameServerCreateNestedManyWithoutClusterInput
  }

  export type GameClusterUncheckedCreateInput = {
    id?: string
    gameType: $Enums.GameType
    sharedSecret: string
    storageNodeId: string
    mountPath: string
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerUncheckedCreateNestedManyWithoutClusterInput
  }

  export type GameClusterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    sharedSecret?: StringFieldUpdateOperationsInput | string
    mountPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storageNode?: NodeUpdateOneRequiredWithoutStorageClustersNestedInput
    servers?: GameServerUpdateManyWithoutClusterNestedInput
  }

  export type GameClusterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    sharedSecret?: StringFieldUpdateOperationsInput | string
    storageNodeId?: StringFieldUpdateOperationsInput | string
    mountPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUncheckedUpdateManyWithoutClusterNestedInput
  }

  export type GameClusterCreateManyInput = {
    id?: string
    gameType: $Enums.GameType
    sharedSecret: string
    storageNodeId: string
    mountPath: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameClusterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    sharedSecret?: StringFieldUpdateOperationsInput | string
    mountPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameClusterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    sharedSecret?: StringFieldUpdateOperationsInput | string
    storageNodeId?: StringFieldUpdateOperationsInput | string
    mountPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupCreateInput = {
    id?: string
    snapshotId: string
    sizeBytes: bigint | number
    location: $Enums.BackupLocation
    lastRestoredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    server: GameServerCreateNestedOneWithoutBackupsInput
  }

  export type BackupUncheckedCreateInput = {
    id?: string
    serverUuid: string
    snapshotId: string
    sizeBytes: bigint | number
    location: $Enums.BackupLocation
    lastRestoredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotId?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: EnumBackupLocationFieldUpdateOperationsInput | $Enums.BackupLocation
    lastRestoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    server?: GameServerUpdateOneRequiredWithoutBackupsNestedInput
  }

  export type BackupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serverUuid?: StringFieldUpdateOperationsInput | string
    snapshotId?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: EnumBackupLocationFieldUpdateOperationsInput | $Enums.BackupLocation
    lastRestoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupCreateManyInput = {
    id?: string
    serverUuid: string
    snapshotId: string
    sizeBytes: bigint | number
    location: $Enums.BackupLocation
    lastRestoredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotId?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: EnumBackupLocationFieldUpdateOperationsInput | $Enums.BackupLocation
    lastRestoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serverUuid?: StringFieldUpdateOperationsInput | string
    snapshotId?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: EnumBackupLocationFieldUpdateOperationsInput | $Enums.BackupLocation
    lastRestoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricCreateInput = {
    id?: string
    timestamp?: Date | string
    cpuUsage: number
    ramUsage: number
    ramUsagePercent: number
    diskUsage: number
    diskUsagePercent: number
    networkIn: bigint | number
    networkOut: bigint | number
    uptime?: number | null
    node: NodeCreateNestedOneWithoutMetricsInput
    server?: GameServerCreateNestedOneWithoutMetricsInput
  }

  export type MetricUncheckedCreateInput = {
    id?: string
    nodeId: string
    serverUuid?: string | null
    timestamp?: Date | string
    cpuUsage: number
    ramUsage: number
    ramUsagePercent: number
    diskUsage: number
    diskUsagePercent: number
    networkIn: bigint | number
    networkOut: bigint | number
    uptime?: number | null
  }

  export type MetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    ramUsage?: FloatFieldUpdateOperationsInput | number
    ramUsagePercent?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    diskUsagePercent?: FloatFieldUpdateOperationsInput | number
    networkIn?: BigIntFieldUpdateOperationsInput | bigint | number
    networkOut?: BigIntFieldUpdateOperationsInput | bigint | number
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
    node?: NodeUpdateOneRequiredWithoutMetricsNestedInput
    server?: GameServerUpdateOneWithoutMetricsNestedInput
  }

  export type MetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    ramUsage?: FloatFieldUpdateOperationsInput | number
    ramUsagePercent?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    diskUsagePercent?: FloatFieldUpdateOperationsInput | number
    networkIn?: BigIntFieldUpdateOperationsInput | bigint | number
    networkOut?: BigIntFieldUpdateOperationsInput | bigint | number
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MetricCreateManyInput = {
    id?: string
    nodeId: string
    serverUuid?: string | null
    timestamp?: Date | string
    cpuUsage: number
    ramUsage: number
    ramUsagePercent: number
    diskUsage: number
    diskUsagePercent: number
    networkIn: bigint | number
    networkOut: bigint | number
    uptime?: number | null
  }

  export type MetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    ramUsage?: FloatFieldUpdateOperationsInput | number
    ramUsagePercent?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    diskUsagePercent?: FloatFieldUpdateOperationsInput | number
    networkIn?: BigIntFieldUpdateOperationsInput | bigint | number
    networkOut?: BigIntFieldUpdateOperationsInput | bigint | number
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    ramUsage?: FloatFieldUpdateOperationsInput | number
    ramUsagePercent?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    diskUsagePercent?: FloatFieldUpdateOperationsInput | number
    networkIn?: BigIntFieldUpdateOperationsInput | bigint | number
    networkOut?: BigIntFieldUpdateOperationsInput | bigint | number
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AlertCreateInput = {
    id?: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved?: boolean
    resolvedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedBy?: UserCreateNestedOneWithoutResolvedAlertsInput
    node?: NodeCreateNestedOneWithoutAlertsInput
    server?: GameServerCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeId?: string | null
    serverUuid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: UserUpdateOneWithoutResolvedAlertsNestedInput
    node?: NodeUpdateOneWithoutAlertsNestedInput
    server?: GameServerUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyInput = {
    id?: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeId?: string | null
    serverUuid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceQuotaCreateInput = {
    id?: string
    maxServers: number
    maxRam: number
    maxDisk: number
    maxCpu: number
    currentUsage: JsonNullValueInput | InputJsonValue
    enforced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResourceQuotasInput
    tenant?: TenantCreateNestedOneWithoutResourceQuotasInput
  }

  export type ResourceQuotaUncheckedCreateInput = {
    id?: string
    userId: string
    tenantId?: string | null
    maxServers: number
    maxRam: number
    maxDisk: number
    maxCpu: number
    currentUsage: JsonNullValueInput | InputJsonValue
    enforced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceQuotaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxServers?: IntFieldUpdateOperationsInput | number
    maxRam?: IntFieldUpdateOperationsInput | number
    maxDisk?: IntFieldUpdateOperationsInput | number
    maxCpu?: IntFieldUpdateOperationsInput | number
    currentUsage?: JsonNullValueInput | InputJsonValue
    enforced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResourceQuotasNestedInput
    tenant?: TenantUpdateOneWithoutResourceQuotasNestedInput
  }

  export type ResourceQuotaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    maxServers?: IntFieldUpdateOperationsInput | number
    maxRam?: IntFieldUpdateOperationsInput | number
    maxDisk?: IntFieldUpdateOperationsInput | number
    maxCpu?: IntFieldUpdateOperationsInput | number
    currentUsage?: JsonNullValueInput | InputJsonValue
    enforced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceQuotaCreateManyInput = {
    id?: string
    userId: string
    tenantId?: string | null
    maxServers: number
    maxRam: number
    maxDisk: number
    maxCpu: number
    currentUsage: JsonNullValueInput | InputJsonValue
    enforced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceQuotaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxServers?: IntFieldUpdateOperationsInput | number
    maxRam?: IntFieldUpdateOperationsInput | number
    maxDisk?: IntFieldUpdateOperationsInput | number
    maxCpu?: IntFieldUpdateOperationsInput | number
    currentUsage?: JsonNullValueInput | InputJsonValue
    enforced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceQuotaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    maxServers?: IntFieldUpdateOperationsInput | number
    maxRam?: IntFieldUpdateOperationsInput | number
    maxDisk?: IntFieldUpdateOperationsInput | number
    maxCpu?: IntFieldUpdateOperationsInput | number
    currentUsage?: JsonNullValueInput | InputJsonValue
    enforced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    keyHash: string
    name: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    userId: string
    keyHash: string
    name: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    userId: string
    keyHash: string
    name: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateInput = {
    id?: string
    title: string
    description: string
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    resolvedAt?: Date | string | null
    rootCause?: string | null
    resolution?: string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: UserCreateNestedOneWithoutAssignedIncidentsInput
  }

  export type IncidentUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    assignedToId?: string | null
    resolvedAt?: Date | string | null
    rootCause?: string | null
    resolution?: string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneWithoutAssignedIncidentsNestedInput
  }

  export type IncidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentCreateManyInput = {
    id?: string
    title: string
    description: string
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    assignedToId?: string | null
    resolvedAt?: Date | string | null
    rootCause?: string | null
    resolution?: string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    slug: string
    gameType: $Enums.GameType
    status?: $Enums.PlanStatus
    ramMb: number
    cpuCores: number
    diskGb: number
    maxSlots?: number | null
    monthlyPrice: number
    hourlyPrice?: number | null
    setupFee?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    isPopular?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerCreateNestedManyWithoutPlanInput
    orders?: OrderCreateNestedManyWithoutPlanInput
    promotions?: PromotionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    gameType: $Enums.GameType
    status?: $Enums.PlanStatus
    ramMb: number
    cpuCores: number
    diskGb: number
    maxSlots?: number | null
    monthlyPrice: number
    hourlyPrice?: number | null
    setupFee?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    isPopular?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerUncheckedCreateNestedManyWithoutPlanInput
    orders?: OrderUncheckedCreateNestedManyWithoutPlanInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumPlanStatusFieldUpdateOperationsInput | $Enums.PlanStatus
    ramMb?: IntFieldUpdateOperationsInput | number
    cpuCores?: IntFieldUpdateOperationsInput | number
    diskGb?: IntFieldUpdateOperationsInput | number
    maxSlots?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    hourlyPrice?: NullableIntFieldUpdateOperationsInput | number | null
    setupFee?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUpdateManyWithoutPlanNestedInput
    orders?: OrderUpdateManyWithoutPlanNestedInput
    promotions?: PromotionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumPlanStatusFieldUpdateOperationsInput | $Enums.PlanStatus
    ramMb?: IntFieldUpdateOperationsInput | number
    cpuCores?: IntFieldUpdateOperationsInput | number
    diskGb?: IntFieldUpdateOperationsInput | number
    maxSlots?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    hourlyPrice?: NullableIntFieldUpdateOperationsInput | number | null
    setupFee?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUncheckedUpdateManyWithoutPlanNestedInput
    orders?: OrderUncheckedUpdateManyWithoutPlanNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    slug: string
    gameType: $Enums.GameType
    status?: $Enums.PlanStatus
    ramMb: number
    cpuCores: number
    diskGb: number
    maxSlots?: number | null
    monthlyPrice: number
    hourlyPrice?: number | null
    setupFee?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    isPopular?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumPlanStatusFieldUpdateOperationsInput | $Enums.PlanStatus
    ramMb?: IntFieldUpdateOperationsInput | number
    cpuCores?: IntFieldUpdateOperationsInput | number
    diskGb?: IntFieldUpdateOperationsInput | number
    maxSlots?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    hourlyPrice?: NullableIntFieldUpdateOperationsInput | number | null
    setupFee?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumPlanStatusFieldUpdateOperationsInput | $Enums.PlanStatus
    ramMb?: IntFieldUpdateOperationsInput | number
    cpuCores?: IntFieldUpdateOperationsInput | number
    diskGb?: IntFieldUpdateOperationsInput | number
    maxSlots?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    hourlyPrice?: NullableIntFieldUpdateOperationsInput | number | null
    setupFee?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateInput = {
    id?: string
    name: string
    description?: string | null
    scope: $Enums.PromotionScope
    discountPercent: number
    gameType?: $Enums.GameType | null
    startDate: Date | string
    endDate?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: PlanCreateNestedOneWithoutPromotionsInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    scope: $Enums.PromotionScope
    discountPercent: number
    gameType?: $Enums.GameType | null
    planId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: EnumPromotionScopeFieldUpdateOperationsInput | $Enums.PromotionScope
    discountPercent?: IntFieldUpdateOperationsInput | number
    gameType?: NullableEnumGameTypeFieldUpdateOperationsInput | $Enums.GameType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneWithoutPromotionsNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: EnumPromotionScopeFieldUpdateOperationsInput | $Enums.PromotionScope
    discountPercent?: IntFieldUpdateOperationsInput | number
    gameType?: NullableEnumGameTypeFieldUpdateOperationsInput | $Enums.GameType | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    scope: $Enums.PromotionScope
    discountPercent: number
    gameType?: $Enums.GameType | null
    planId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: EnumPromotionScopeFieldUpdateOperationsInput | $Enums.PromotionScope
    discountPercent?: IntFieldUpdateOperationsInput | number
    gameType?: NullableEnumGameTypeFieldUpdateOperationsInput | $Enums.GameType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: EnumPromotionScopeFieldUpdateOperationsInput | $Enums.PromotionScope
    discountPercent?: IntFieldUpdateOperationsInput | number
    gameType?: NullableEnumGameTypeFieldUpdateOperationsInput | $Enums.GameType | null
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    status?: $Enums.OrderStatus
    priceSnapshot: JsonNullValueInput | InputJsonValue
    totalAmount: number
    currency?: string
    paymentMethod?: string | null
    paymentId?: string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    plan: PlanCreateNestedOneWithoutOrdersInput
    server?: GameServerCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    userId: string
    planId: string
    status?: $Enums.OrderStatus
    priceSnapshot: JsonNullValueInput | InputJsonValue
    totalAmount: number
    currency?: string
    paymentMethod?: string | null
    paymentId?: string | null
    paidAt?: Date | string | null
    serverId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    plan?: PlanUpdateOneRequiredWithoutOrdersNestedInput
    server?: GameServerUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyInput = {
    id?: string
    userId: string
    planId: string
    status?: $Enums.OrderStatus
    priceSnapshot: JsonNullValueInput | InputJsonValue
    totalAmount: number
    currency?: string
    paymentMethod?: string | null
    paymentId?: string | null
    paidAt?: Date | string | null
    serverId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventCreateInput = {
    id?: string
    provider: $Enums.PaymentProvider
    eventType: string
    eventId: string
    paymentId?: string | null
    orderId?: string | null
    status?: $Enums.PaymentEventStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type PaymentEventUncheckedCreateInput = {
    id?: string
    provider: $Enums.PaymentProvider
    eventType: string
    eventId: string
    paymentId?: string | null
    orderId?: string | null
    status?: $Enums.PaymentEventStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type PaymentEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    eventType?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentEventStatusFieldUpdateOperationsInput | $Enums.PaymentEventStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    eventType?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentEventStatusFieldUpdateOperationsInput | $Enums.PaymentEventStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventCreateManyInput = {
    id?: string
    provider: $Enums.PaymentProvider
    eventType: string
    eventId: string
    paymentId?: string | null
    orderId?: string | null
    status?: $Enums.PaymentEventStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type PaymentEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    eventType?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentEventStatusFieldUpdateOperationsInput | $Enums.PaymentEventStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    eventType?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentEventStatusFieldUpdateOperationsInput | $Enums.PaymentEventStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketCreateInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    priority?: $Enums.TicketPriority
    category?: string | null
    status?: $Enums.TicketStatus
    assignedAt?: Date | string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    firstResponseAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    user: UserCreateNestedOneWithoutSupportTicketsInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    priority?: $Enums.TicketPriority
    category?: string | null
    status?: $Enums.TicketStatus
    assignedToId?: string | null
    assignedAt?: Date | string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    firstResponseAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    user?: UserUpdateOneRequiredWithoutSupportTicketsNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketCreateManyInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    priority?: $Enums.TicketPriority
    category?: string | null
    status?: $Enums.TicketStatus
    assignedToId?: string | null
    assignedAt?: Date | string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    firstResponseAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type SupportTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SlaPolicyCreateInput = {
    id?: string
    priority: $Enums.TicketPriority
    responseTimeHours: number
    resolveTimeHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlaPolicyUncheckedCreateInput = {
    id?: string
    priority: $Enums.TicketPriority
    responseTimeHours: number
    resolveTimeHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlaPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    responseTimeHours?: IntFieldUpdateOperationsInput | number
    resolveTimeHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlaPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    responseTimeHours?: IntFieldUpdateOperationsInput | number
    resolveTimeHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlaPolicyCreateManyInput = {
    id?: string
    priority: $Enums.TicketPriority
    responseTimeHours: number
    resolveTimeHours: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SlaPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    responseTimeHours?: IntFieldUpdateOperationsInput | number
    resolveTimeHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SlaPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    responseTimeHours?: IntFieldUpdateOperationsInput | number
    resolveTimeHours?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: SupportTicketCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateInput = {
    id?: string
    ticketId: string
    authorId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentCreateManyInput = {
    id?: string
    ticketId: string
    authorId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseArticleCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    published?: boolean
    views?: number
    helpful?: number
    notHelpful?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    category: KnowledgeBaseCategoryCreateNestedOneWithoutArticlesInput
    author: UserCreateNestedOneWithoutKnowledgeBaseArticlesInput
    versions?: ArticleVersionCreateNestedManyWithoutArticleInput
  }

  export type KnowledgeBaseArticleUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    categoryId: string
    authorId: string
    tags?: JsonNullValueInput | InputJsonValue
    published?: boolean
    views?: number
    helpful?: number
    notHelpful?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    versions?: ArticleVersionUncheckedCreateNestedManyWithoutArticleInput
  }

  export type KnowledgeBaseArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    helpful?: IntFieldUpdateOperationsInput | number
    notHelpful?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: KnowledgeBaseCategoryUpdateOneRequiredWithoutArticlesNestedInput
    author?: UserUpdateOneRequiredWithoutKnowledgeBaseArticlesNestedInput
    versions?: ArticleVersionUpdateManyWithoutArticleNestedInput
  }

  export type KnowledgeBaseArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    helpful?: IntFieldUpdateOperationsInput | number
    notHelpful?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versions?: ArticleVersionUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type KnowledgeBaseArticleCreateManyInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    categoryId: string
    authorId: string
    tags?: JsonNullValueInput | InputJsonValue
    published?: boolean
    views?: number
    helpful?: number
    notHelpful?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type KnowledgeBaseArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    helpful?: IntFieldUpdateOperationsInput | number
    notHelpful?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeBaseArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    helpful?: IntFieldUpdateOperationsInput | number
    notHelpful?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeBaseCategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: KnowledgeBaseCategoryCreateNestedOneWithoutChildrenInput
    children?: KnowledgeBaseCategoryCreateNestedManyWithoutParentInput
    articles?: KnowledgeBaseArticleCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeBaseCategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: KnowledgeBaseCategoryUncheckedCreateNestedManyWithoutParentInput
    articles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeBaseCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: KnowledgeBaseCategoryUpdateOneWithoutChildrenNestedInput
    children?: KnowledgeBaseCategoryUpdateManyWithoutParentNestedInput
    articles?: KnowledgeBaseArticleUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeBaseCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: KnowledgeBaseCategoryUncheckedUpdateManyWithoutParentNestedInput
    articles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeBaseCategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleVersionCreateInput = {
    id?: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    createdBy: string
    createdAt?: Date | string
    article: KnowledgeBaseArticleCreateNestedOneWithoutVersionsInput
  }

  export type ArticleVersionUncheckedCreateInput = {
    id?: string
    articleId: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ArticleVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: KnowledgeBaseArticleUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type ArticleVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleVersionCreateManyInput = {
    id?: string
    articleId: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ArticleVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceMetadataCreateInput = {
    id?: string
    tenantId?: string | null
    prefix?: string
    sequenceNumber?: number
    lastUsedDate?: Date | string
    year?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceMetadataUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    prefix?: string
    sequenceNumber?: number
    lastUsedDate?: Date | string
    year?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceMetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: IntFieldUpdateOperationsInput | number
    lastUsedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceMetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: IntFieldUpdateOperationsInput | number
    lastUsedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceMetadataCreateManyInput = {
    id?: string
    tenantId?: string | null
    prefix?: string
    sequenceNumber?: number
    lastUsedDate?: Date | string
    year?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceMetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: IntFieldUpdateOperationsInput | number
    lastUsedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceMetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: StringFieldUpdateOperationsInput | string
    sequenceNumber?: IntFieldUpdateOperationsInput | number
    lastUsedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumLicenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseStatus[]
    notIn?: $Enums.LicenseStatus[]
    not?: NestedEnumLicenseStatusFilter<$PrismaModel> | $Enums.LicenseStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SystemLicenseCountOrderByAggregateInput = {
    id?: SortOrder
    licenseKey?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    maxNodesAllowed?: SortOrder
    whitelabelEnabled?: SortOrder
    signature?: SortOrder
    gracePeriodEnds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemLicenseAvgOrderByAggregateInput = {
    maxNodesAllowed?: SortOrder
  }

  export type SystemLicenseMaxOrderByAggregateInput = {
    id?: SortOrder
    licenseKey?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    maxNodesAllowed?: SortOrder
    whitelabelEnabled?: SortOrder
    signature?: SortOrder
    gracePeriodEnds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemLicenseMinOrderByAggregateInput = {
    id?: SortOrder
    licenseKey?: SortOrder
    status?: SortOrder
    validUntil?: SortOrder
    maxNodesAllowed?: SortOrder
    whitelabelEnabled?: SortOrder
    signature?: SortOrder
    gracePeriodEnds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemLicenseSumOrderByAggregateInput = {
    maxNodesAllowed?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumLicenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseStatus[]
    notIn?: $Enums.LicenseStatus[]
    not?: NestedEnumLicenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LicenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLicenseStatusFilter<$PrismaModel>
    _max?: NestedEnumLicenseStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ResourceQuotaListRelationFilter = {
    every?: ResourceQuotaWhereInput
    some?: ResourceQuotaWhereInput
    none?: ResourceQuotaWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceQuotaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    themeConfig?: SortOrder
    smtpConfig?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TenantNullableRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type GameServerListRelationFilter = {
    every?: GameServerWhereInput
    some?: GameServerWhereInput
    none?: GameServerWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type IncidentListRelationFilter = {
    every?: IncidentWhereInput
    some?: IncidentWhereInput
    none?: IncidentWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type TicketCommentListRelationFilter = {
    every?: TicketCommentWhereInput
    some?: TicketCommentWhereInput
    none?: TicketCommentWhereInput
  }

  export type KnowledgeBaseArticleListRelationFilter = {
    every?: KnowledgeBaseArticleWhereInput
    some?: KnowledgeBaseArticleWhereInput
    none?: KnowledgeBaseArticleWhereInput
  }

  export type GameServerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncidentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeBaseArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrder
    twoFactorBackupCodes?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
    balance?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrder
    twoFactorBackupCodes?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
    balance?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorMethod?: SortOrder
    twoFactorBackupCodes?: SortOrder
    resetToken?: SortOrder
    resetTokenExpires?: SortOrder
    balance?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDiskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiskType | EnumDiskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiskType[]
    notIn?: $Enums.DiskType[]
    not?: NestedEnumDiskTypeFilter<$PrismaModel> | $Enums.DiskType
  }

  export type EnumNodeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeStatus | EnumNodeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NodeStatus[]
    notIn?: $Enums.NodeStatus[]
    not?: NestedEnumNodeStatusFilter<$PrismaModel> | $Enums.NodeStatus
  }

  export type NetworkAllocationListRelationFilter = {
    every?: NetworkAllocationWhereInput
    some?: NetworkAllocationWhereInput
    none?: NetworkAllocationWhereInput
  }

  export type MetricListRelationFilter = {
    every?: MetricWhereInput
    some?: MetricWhereInput
    none?: MetricWhereInput
  }

  export type GameClusterListRelationFilter = {
    every?: GameClusterWhereInput
    some?: GameClusterWhereInput
    none?: GameClusterWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type NetworkAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameClusterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NodeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    ipAddress?: SortOrder
    publicFqdn?: SortOrder
    totalRam?: SortOrder
    totalCpu?: SortOrder
    diskType?: SortOrder
    isClusterStorage?: SortOrder
    maintenanceMode?: SortOrder
    maxConcurrentUpdates?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NodeAvgOrderByAggregateInput = {
    totalRam?: SortOrder
    totalCpu?: SortOrder
    maxConcurrentUpdates?: SortOrder
  }

  export type NodeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    ipAddress?: SortOrder
    publicFqdn?: SortOrder
    totalRam?: SortOrder
    totalCpu?: SortOrder
    diskType?: SortOrder
    isClusterStorage?: SortOrder
    maintenanceMode?: SortOrder
    maxConcurrentUpdates?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NodeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    ipAddress?: SortOrder
    publicFqdn?: SortOrder
    totalRam?: SortOrder
    totalCpu?: SortOrder
    diskType?: SortOrder
    isClusterStorage?: SortOrder
    maintenanceMode?: SortOrder
    maxConcurrentUpdates?: SortOrder
    status?: SortOrder
    lastHeartbeat?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NodeSumOrderByAggregateInput = {
    totalRam?: SortOrder
    totalCpu?: SortOrder
    maxConcurrentUpdates?: SortOrder
  }

  export type EnumDiskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiskType | EnumDiskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiskType[]
    notIn?: $Enums.DiskType[]
    not?: NestedEnumDiskTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiskTypeFilter<$PrismaModel>
    _max?: NestedEnumDiskTypeFilter<$PrismaModel>
  }

  export type EnumNodeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeStatus | EnumNodeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NodeStatus[]
    notIn?: $Enums.NodeStatus[]
    not?: NestedEnumNodeStatusWithAggregatesFilter<$PrismaModel> | $Enums.NodeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNodeStatusFilter<$PrismaModel>
    _max?: NestedEnumNodeStatusFilter<$PrismaModel>
  }

  export type EnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[]
    notIn?: $Enums.TaskType[]
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[]
    notIn?: $Enums.TaskStatus[]
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NodeRelationFilter = {
    is?: NodeWhereInput
    isNot?: NodeWhereInput
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    error?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    error?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    error?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[]
    notIn?: $Enums.TaskType[]
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[]
    notIn?: $Enums.TaskStatus[]
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumProtocolFilter<$PrismaModel = never> = {
    equals?: $Enums.Protocol | EnumProtocolFieldRefInput<$PrismaModel>
    in?: $Enums.Protocol[]
    notIn?: $Enums.Protocol[]
    not?: NestedEnumProtocolFilter<$PrismaModel> | $Enums.Protocol
  }

  export type EnumPortTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PortType | EnumPortTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PortType[]
    notIn?: $Enums.PortType[]
    not?: NestedEnumPortTypeFilter<$PrismaModel> | $Enums.PortType
  }

  export type GameServerNullableRelationFilter = {
    is?: GameServerWhereInput | null
    isNot?: GameServerWhereInput | null
  }

  export type NetworkAllocationNodeIdPortProtocolCompoundUniqueInput = {
    nodeId: string
    port: number
    protocol: $Enums.Protocol
  }

  export type NetworkAllocationCountOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    port?: SortOrder
    protocol?: SortOrder
    type?: SortOrder
    serverUuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkAllocationAvgOrderByAggregateInput = {
    port?: SortOrder
  }

  export type NetworkAllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    port?: SortOrder
    protocol?: SortOrder
    type?: SortOrder
    serverUuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkAllocationMinOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    port?: SortOrder
    protocol?: SortOrder
    type?: SortOrder
    serverUuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkAllocationSumOrderByAggregateInput = {
    port?: SortOrder
  }

  export type EnumProtocolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Protocol | EnumProtocolFieldRefInput<$PrismaModel>
    in?: $Enums.Protocol[]
    notIn?: $Enums.Protocol[]
    not?: NestedEnumProtocolWithAggregatesFilter<$PrismaModel> | $Enums.Protocol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProtocolFilter<$PrismaModel>
    _max?: NestedEnumProtocolFilter<$PrismaModel>
  }

  export type EnumPortTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PortType | EnumPortTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PortType[]
    notIn?: $Enums.PortType[]
    not?: NestedEnumPortTypeWithAggregatesFilter<$PrismaModel> | $Enums.PortType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPortTypeFilter<$PrismaModel>
    _max?: NestedEnumPortTypeFilter<$PrismaModel>
  }

  export type GameServerRelationFilter = {
    is?: GameServerWhereInput
    isNot?: GameServerWhereInput
  }

  export type SubdomainSubdomainDomainCompoundUniqueInput = {
    subdomain: string
    domain: string
  }

  export type SubdomainCountOrderByAggregateInput = {
    id?: SortOrder
    subdomain?: SortOrder
    domain?: SortOrder
    serverUuid?: SortOrder
    cloudflareId?: SortOrder
    targetIP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubdomainMaxOrderByAggregateInput = {
    id?: SortOrder
    subdomain?: SortOrder
    domain?: SortOrder
    serverUuid?: SortOrder
    cloudflareId?: SortOrder
    targetIP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubdomainMinOrderByAggregateInput = {
    id?: SortOrder
    subdomain?: SortOrder
    domain?: SortOrder
    serverUuid?: SortOrder
    cloudflareId?: SortOrder
    targetIP?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGameTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameType[]
    notIn?: $Enums.GameType[]
    not?: NestedEnumGameTypeFilter<$PrismaModel> | $Enums.GameType
  }

  export type EnumServerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServerStatus | EnumServerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServerStatus[]
    notIn?: $Enums.ServerStatus[]
    not?: NestedEnumServerStatusFilter<$PrismaModel> | $Enums.ServerStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PlanNullableRelationFilter = {
    is?: PlanWhereInput | null
    isNot?: PlanWhereInput | null
  }

  export type GameClusterNullableRelationFilter = {
    is?: GameClusterWhereInput | null
    isNot?: GameClusterWhereInput | null
  }

  export type SubdomainListRelationFilter = {
    every?: SubdomainWhereInput
    some?: SubdomainWhereInput
    none?: SubdomainWhereInput
  }

  export type BackupListRelationFilter = {
    every?: BackupWhereInput
    some?: BackupWhereInput
    none?: BackupWhereInput
  }

  export type SubdomainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BackupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameServerCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    gameType?: SortOrder
    status?: SortOrder
    nodeId?: SortOrder
    ownerId?: SortOrder
    planId?: SortOrder
    startupPriority?: SortOrder
    resources?: SortOrder
    envVars?: SortOrder
    clusterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameServerAvgOrderByAggregateInput = {
    startupPriority?: SortOrder
  }

  export type GameServerMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    gameType?: SortOrder
    status?: SortOrder
    nodeId?: SortOrder
    ownerId?: SortOrder
    planId?: SortOrder
    startupPriority?: SortOrder
    clusterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameServerMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    gameType?: SortOrder
    status?: SortOrder
    nodeId?: SortOrder
    ownerId?: SortOrder
    planId?: SortOrder
    startupPriority?: SortOrder
    clusterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameServerSumOrderByAggregateInput = {
    startupPriority?: SortOrder
  }

  export type EnumGameTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameType[]
    notIn?: $Enums.GameType[]
    not?: NestedEnumGameTypeWithAggregatesFilter<$PrismaModel> | $Enums.GameType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameTypeFilter<$PrismaModel>
    _max?: NestedEnumGameTypeFilter<$PrismaModel>
  }

  export type EnumServerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServerStatus | EnumServerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServerStatus[]
    notIn?: $Enums.ServerStatus[]
    not?: NestedEnumServerStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServerStatusFilter<$PrismaModel>
    _max?: NestedEnumServerStatusFilter<$PrismaModel>
  }

  export type GameClusterCountOrderByAggregateInput = {
    id?: SortOrder
    gameType?: SortOrder
    sharedSecret?: SortOrder
    storageNodeId?: SortOrder
    mountPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameClusterMaxOrderByAggregateInput = {
    id?: SortOrder
    gameType?: SortOrder
    sharedSecret?: SortOrder
    storageNodeId?: SortOrder
    mountPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GameClusterMinOrderByAggregateInput = {
    id?: SortOrder
    gameType?: SortOrder
    sharedSecret?: SortOrder
    storageNodeId?: SortOrder
    mountPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EnumBackupLocationFilter<$PrismaModel = never> = {
    equals?: $Enums.BackupLocation | EnumBackupLocationFieldRefInput<$PrismaModel>
    in?: $Enums.BackupLocation[]
    notIn?: $Enums.BackupLocation[]
    not?: NestedEnumBackupLocationFilter<$PrismaModel> | $Enums.BackupLocation
  }

  export type BackupCountOrderByAggregateInput = {
    id?: SortOrder
    serverUuid?: SortOrder
    snapshotId?: SortOrder
    sizeBytes?: SortOrder
    location?: SortOrder
    lastRestoredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BackupAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type BackupMaxOrderByAggregateInput = {
    id?: SortOrder
    serverUuid?: SortOrder
    snapshotId?: SortOrder
    sizeBytes?: SortOrder
    location?: SortOrder
    lastRestoredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BackupMinOrderByAggregateInput = {
    id?: SortOrder
    serverUuid?: SortOrder
    snapshotId?: SortOrder
    sizeBytes?: SortOrder
    location?: SortOrder
    lastRestoredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BackupSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumBackupLocationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BackupLocation | EnumBackupLocationFieldRefInput<$PrismaModel>
    in?: $Enums.BackupLocation[]
    notIn?: $Enums.BackupLocation[]
    not?: NestedEnumBackupLocationWithAggregatesFilter<$PrismaModel> | $Enums.BackupLocation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBackupLocationFilter<$PrismaModel>
    _max?: NestedEnumBackupLocationFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MetricCountOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    serverUuid?: SortOrder
    timestamp?: SortOrder
    cpuUsage?: SortOrder
    ramUsage?: SortOrder
    ramUsagePercent?: SortOrder
    diskUsage?: SortOrder
    diskUsagePercent?: SortOrder
    networkIn?: SortOrder
    networkOut?: SortOrder
    uptime?: SortOrder
  }

  export type MetricAvgOrderByAggregateInput = {
    cpuUsage?: SortOrder
    ramUsage?: SortOrder
    ramUsagePercent?: SortOrder
    diskUsage?: SortOrder
    diskUsagePercent?: SortOrder
    networkIn?: SortOrder
    networkOut?: SortOrder
    uptime?: SortOrder
  }

  export type MetricMaxOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    serverUuid?: SortOrder
    timestamp?: SortOrder
    cpuUsage?: SortOrder
    ramUsage?: SortOrder
    ramUsagePercent?: SortOrder
    diskUsage?: SortOrder
    diskUsagePercent?: SortOrder
    networkIn?: SortOrder
    networkOut?: SortOrder
    uptime?: SortOrder
  }

  export type MetricMinOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    serverUuid?: SortOrder
    timestamp?: SortOrder
    cpuUsage?: SortOrder
    ramUsage?: SortOrder
    ramUsagePercent?: SortOrder
    diskUsage?: SortOrder
    diskUsagePercent?: SortOrder
    networkIn?: SortOrder
    networkOut?: SortOrder
    uptime?: SortOrder
  }

  export type MetricSumOrderByAggregateInput = {
    cpuUsage?: SortOrder
    ramUsage?: SortOrder
    ramUsagePercent?: SortOrder
    diskUsage?: SortOrder
    diskUsagePercent?: SortOrder
    networkIn?: SortOrder
    networkOut?: SortOrder
    uptime?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumAlertSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[]
    notIn?: $Enums.AlertSeverity[]
    not?: NestedEnumAlertSeverityFilter<$PrismaModel> | $Enums.AlertSeverity
  }

  export type EnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[]
    notIn?: $Enums.ResourceType[]
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type NodeNullableRelationFilter = {
    is?: NodeWhereInput | null
    isNot?: NodeWhereInput | null
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    message?: SortOrder
    resourceId?: SortOrder
    resourceType?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedById?: SortOrder
    metadata?: SortOrder
    nodeId?: SortOrder
    serverUuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    message?: SortOrder
    resourceId?: SortOrder
    resourceType?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedById?: SortOrder
    nodeId?: SortOrder
    serverUuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    severity?: SortOrder
    type?: SortOrder
    message?: SortOrder
    resourceId?: SortOrder
    resourceType?: SortOrder
    resolved?: SortOrder
    resolvedAt?: SortOrder
    resolvedById?: SortOrder
    nodeId?: SortOrder
    serverUuid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAlertSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[]
    notIn?: $Enums.AlertSeverity[]
    not?: NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel> | $Enums.AlertSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertSeverityFilter<$PrismaModel>
    _max?: NestedEnumAlertSeverityFilter<$PrismaModel>
  }

  export type EnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[]
    notIn?: $Enums.ResourceType[]
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type ResourceQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    maxServers?: SortOrder
    maxRam?: SortOrder
    maxDisk?: SortOrder
    maxCpu?: SortOrder
    currentUsage?: SortOrder
    enforced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceQuotaAvgOrderByAggregateInput = {
    maxServers?: SortOrder
    maxRam?: SortOrder
    maxDisk?: SortOrder
    maxCpu?: SortOrder
  }

  export type ResourceQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    maxServers?: SortOrder
    maxRam?: SortOrder
    maxDisk?: SortOrder
    maxCpu?: SortOrder
    enforced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    maxServers?: SortOrder
    maxRam?: SortOrder
    maxDisk?: SortOrder
    maxCpu?: SortOrder
    enforced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceQuotaSumOrderByAggregateInput = {
    maxServers?: SortOrder
    maxRam?: SortOrder
    maxDisk?: SortOrder
    maxCpu?: SortOrder
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    name?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    permissions?: SortOrder
    rateLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyAvgOrderByAggregateInput = {
    rateLimit?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    name?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    rateLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    name?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    rateLimit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeySumOrderByAggregateInput = {
    rateLimit?: SortOrder
  }

  export type EnumIncidentSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[]
    notIn?: $Enums.IncidentSeverity[]
    not?: NestedEnumIncidentSeverityFilter<$PrismaModel> | $Enums.IncidentSeverity
  }

  export type EnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[]
    notIn?: $Enums.IncidentStatus[]
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type IncidentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    resolvedAt?: SortOrder
    rootCause?: SortOrder
    resolution?: SortOrder
    affectedResources?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    resolvedAt?: SortOrder
    rootCause?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncidentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    resolvedAt?: SortOrder
    rootCause?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIncidentSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[]
    notIn?: $Enums.IncidentSeverity[]
    not?: NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IncidentSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentSeverityFilter<$PrismaModel>
    _max?: NestedEnumIncidentSeverityFilter<$PrismaModel>
  }

  export type EnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[]
    notIn?: $Enums.IncidentStatus[]
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type EnumPlanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanStatus | EnumPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlanStatus[]
    notIn?: $Enums.PlanStatus[]
    not?: NestedEnumPlanStatusFilter<$PrismaModel> | $Enums.PlanStatus
  }

  export type PromotionListRelationFilter = {
    every?: PromotionWhereInput
    some?: PromotionWhereInput
    none?: PromotionWhereInput
  }

  export type PromotionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    gameType?: SortOrder
    status?: SortOrder
    ramMb?: SortOrder
    cpuCores?: SortOrder
    diskGb?: SortOrder
    maxSlots?: SortOrder
    monthlyPrice?: SortOrder
    hourlyPrice?: SortOrder
    setupFee?: SortOrder
    features?: SortOrder
    description?: SortOrder
    isPopular?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    ramMb?: SortOrder
    cpuCores?: SortOrder
    diskGb?: SortOrder
    maxSlots?: SortOrder
    monthlyPrice?: SortOrder
    hourlyPrice?: SortOrder
    setupFee?: SortOrder
    sortOrder?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    gameType?: SortOrder
    status?: SortOrder
    ramMb?: SortOrder
    cpuCores?: SortOrder
    diskGb?: SortOrder
    maxSlots?: SortOrder
    monthlyPrice?: SortOrder
    hourlyPrice?: SortOrder
    setupFee?: SortOrder
    description?: SortOrder
    isPopular?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    gameType?: SortOrder
    status?: SortOrder
    ramMb?: SortOrder
    cpuCores?: SortOrder
    diskGb?: SortOrder
    maxSlots?: SortOrder
    monthlyPrice?: SortOrder
    hourlyPrice?: SortOrder
    setupFee?: SortOrder
    description?: SortOrder
    isPopular?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    ramMb?: SortOrder
    cpuCores?: SortOrder
    diskGb?: SortOrder
    maxSlots?: SortOrder
    monthlyPrice?: SortOrder
    hourlyPrice?: SortOrder
    setupFee?: SortOrder
    sortOrder?: SortOrder
  }

  export type EnumPlanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanStatus | EnumPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlanStatus[]
    notIn?: $Enums.PlanStatus[]
    not?: NestedEnumPlanStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanStatusFilter<$PrismaModel>
    _max?: NestedEnumPlanStatusFilter<$PrismaModel>
  }

  export type EnumPromotionScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromotionScope | EnumPromotionScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PromotionScope[]
    notIn?: $Enums.PromotionScope[]
    not?: NestedEnumPromotionScopeFilter<$PrismaModel> | $Enums.PromotionScope
  }

  export type EnumGameTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.GameType[] | null
    notIn?: $Enums.GameType[] | null
    not?: NestedEnumGameTypeNullableFilter<$PrismaModel> | $Enums.GameType | null
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scope?: SortOrder
    discountPercent?: SortOrder
    gameType?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    discountPercent?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scope?: SortOrder
    discountPercent?: SortOrder
    gameType?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scope?: SortOrder
    discountPercent?: SortOrder
    gameType?: SortOrder
    planId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    discountPercent?: SortOrder
  }

  export type EnumPromotionScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromotionScope | EnumPromotionScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PromotionScope[]
    notIn?: $Enums.PromotionScope[]
    not?: NestedEnumPromotionScopeWithAggregatesFilter<$PrismaModel> | $Enums.PromotionScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromotionScopeFilter<$PrismaModel>
    _max?: NestedEnumPromotionScopeFilter<$PrismaModel>
  }

  export type EnumGameTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.GameType[] | null
    notIn?: $Enums.GameType[] | null
    not?: NestedEnumGameTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.GameType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGameTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumGameTypeNullableFilter<$PrismaModel>
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type PlanRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    priceSnapshot?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentId?: SortOrder
    paidAt?: SortOrder
    serverId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentId?: SortOrder
    paidAt?: SortOrder
    serverId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentId?: SortOrder
    paidAt?: SortOrder
    serverId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[]
    notIn?: $Enums.PaymentProvider[]
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type EnumPaymentEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentEventStatus | EnumPaymentEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentEventStatus[]
    notIn?: $Enums.PaymentEventStatus[]
    not?: NestedEnumPaymentEventStatusFilter<$PrismaModel> | $Enums.PaymentEventStatus
  }

  export type PaymentEventProviderEventTypeEventIdCompoundUniqueInput = {
    provider: $Enums.PaymentProvider
    eventType: string
    eventId: string
  }

  export type PaymentEventCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    eventId?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    payload?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentEventMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    eventId?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentEventMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    eventType?: SortOrder
    eventId?: SortOrder
    paymentId?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[]
    notIn?: $Enums.PaymentProvider[]
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type EnumPaymentEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentEventStatus | EnumPaymentEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentEventStatus[]
    notIn?: $Enums.PaymentEventStatus[]
    not?: NestedEnumPaymentEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentEventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentEventStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentEventStatusFilter<$PrismaModel>
  }

  export type EnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[]
    notIn?: $Enums.TicketPriority[]
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[]
    notIn?: $Enums.TicketStatus[]
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    assignedAt?: SortOrder
    slaResponseDeadline?: SortOrder
    slaResolveDeadline?: SortOrder
    firstResponseAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    assignedAt?: SortOrder
    slaResponseDeadline?: SortOrder
    slaResolveDeadline?: SortOrder
    firstResponseAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    assignedAt?: SortOrder
    slaResponseDeadline?: SortOrder
    slaResolveDeadline?: SortOrder
    firstResponseAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    closedAt?: SortOrder
  }

  export type EnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[]
    notIn?: $Enums.TicketPriority[]
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[]
    notIn?: $Enums.TicketStatus[]
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type SlaPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
    responseTimeHours?: SortOrder
    resolveTimeHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlaPolicyAvgOrderByAggregateInput = {
    responseTimeHours?: SortOrder
    resolveTimeHours?: SortOrder
  }

  export type SlaPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
    responseTimeHours?: SortOrder
    resolveTimeHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlaPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
    responseTimeHours?: SortOrder
    resolveTimeHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SlaPolicySumOrderByAggregateInput = {
    responseTimeHours?: SortOrder
    resolveTimeHours?: SortOrder
  }

  export type SupportTicketRelationFilter = {
    is?: SupportTicketWhereInput
    isNot?: SupportTicketWhereInput
  }

  export type TicketCommentCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketCommentMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseCategoryRelationFilter = {
    is?: KnowledgeBaseCategoryWhereInput
    isNot?: KnowledgeBaseCategoryWhereInput
  }

  export type ArticleVersionListRelationFilter = {
    every?: ArticleVersionWhereInput
    some?: ArticleVersionWhereInput
    none?: ArticleVersionWhereInput
  }

  export type ArticleVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeBaseArticleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    tags?: SortOrder
    published?: SortOrder
    views?: SortOrder
    helpful?: SortOrder
    notHelpful?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type KnowledgeBaseArticleAvgOrderByAggregateInput = {
    views?: SortOrder
    helpful?: SortOrder
    notHelpful?: SortOrder
  }

  export type KnowledgeBaseArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    published?: SortOrder
    views?: SortOrder
    helpful?: SortOrder
    notHelpful?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type KnowledgeBaseArticleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    categoryId?: SortOrder
    authorId?: SortOrder
    published?: SortOrder
    views?: SortOrder
    helpful?: SortOrder
    notHelpful?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type KnowledgeBaseArticleSumOrderByAggregateInput = {
    views?: SortOrder
    helpful?: SortOrder
    notHelpful?: SortOrder
  }

  export type KnowledgeBaseCategoryNullableRelationFilter = {
    is?: KnowledgeBaseCategoryWhereInput | null
    isNot?: KnowledgeBaseCategoryWhereInput | null
  }

  export type KnowledgeBaseCategoryListRelationFilter = {
    every?: KnowledgeBaseCategoryWhereInput
    some?: KnowledgeBaseCategoryWhereInput
    none?: KnowledgeBaseCategoryWhereInput
  }

  export type KnowledgeBaseCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeBaseCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type KnowledgeBaseCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeBaseCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type KnowledgeBaseArticleRelationFilter = {
    is?: KnowledgeBaseArticleWhereInput
    isNot?: KnowledgeBaseArticleWhereInput
  }

  export type ArticleVersionArticleIdVersionCompoundUniqueInput = {
    articleId: string
    version: number
  }

  export type ArticleVersionCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ArticleVersionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ArticleVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ArticleVersionMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ArticleVersionSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type InvoiceMetadataTenantIdPrefixYearCompoundUniqueInput = {
    tenantId: string
    prefix: string
    year: number
  }

  export type InvoiceMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    prefix?: SortOrder
    sequenceNumber?: SortOrder
    lastUsedDate?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMetadataAvgOrderByAggregateInput = {
    sequenceNumber?: SortOrder
    year?: SortOrder
  }

  export type InvoiceMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    prefix?: SortOrder
    sequenceNumber?: SortOrder
    lastUsedDate?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    prefix?: SortOrder
    sequenceNumber?: SortOrder
    lastUsedDate?: SortOrder
    year?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMetadataSumOrderByAggregateInput = {
    sequenceNumber?: SortOrder
    year?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumLicenseStatusFieldUpdateOperationsInput = {
    set?: $Enums.LicenseStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ResourceQuotaCreateNestedManyWithoutTenantInput = {
    create?: XOR<ResourceQuotaCreateWithoutTenantInput, ResourceQuotaUncheckedCreateWithoutTenantInput> | ResourceQuotaCreateWithoutTenantInput[] | ResourceQuotaUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ResourceQuotaCreateOrConnectWithoutTenantInput | ResourceQuotaCreateOrConnectWithoutTenantInput[]
    createMany?: ResourceQuotaCreateManyTenantInputEnvelope
    connect?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ResourceQuotaUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ResourceQuotaCreateWithoutTenantInput, ResourceQuotaUncheckedCreateWithoutTenantInput> | ResourceQuotaCreateWithoutTenantInput[] | ResourceQuotaUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ResourceQuotaCreateOrConnectWithoutTenantInput | ResourceQuotaCreateOrConnectWithoutTenantInput[]
    createMany?: ResourceQuotaCreateManyTenantInputEnvelope
    connect?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ResourceQuotaUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ResourceQuotaCreateWithoutTenantInput, ResourceQuotaUncheckedCreateWithoutTenantInput> | ResourceQuotaCreateWithoutTenantInput[] | ResourceQuotaUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ResourceQuotaCreateOrConnectWithoutTenantInput | ResourceQuotaCreateOrConnectWithoutTenantInput[]
    upsert?: ResourceQuotaUpsertWithWhereUniqueWithoutTenantInput | ResourceQuotaUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ResourceQuotaCreateManyTenantInputEnvelope
    set?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    disconnect?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    delete?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    connect?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    update?: ResourceQuotaUpdateWithWhereUniqueWithoutTenantInput | ResourceQuotaUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ResourceQuotaUpdateManyWithWhereWithoutTenantInput | ResourceQuotaUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ResourceQuotaScalarWhereInput | ResourceQuotaScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ResourceQuotaUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ResourceQuotaCreateWithoutTenantInput, ResourceQuotaUncheckedCreateWithoutTenantInput> | ResourceQuotaCreateWithoutTenantInput[] | ResourceQuotaUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ResourceQuotaCreateOrConnectWithoutTenantInput | ResourceQuotaCreateOrConnectWithoutTenantInput[]
    upsert?: ResourceQuotaUpsertWithWhereUniqueWithoutTenantInput | ResourceQuotaUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ResourceQuotaCreateManyTenantInputEnvelope
    set?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    disconnect?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    delete?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    connect?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    update?: ResourceQuotaUpdateWithWhereUniqueWithoutTenantInput | ResourceQuotaUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ResourceQuotaUpdateManyWithWhereWithoutTenantInput | ResourceQuotaUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ResourceQuotaScalarWhereInput | ResourceQuotaScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type GameServerCreateNestedManyWithoutOwnerInput = {
    create?: XOR<GameServerCreateWithoutOwnerInput, GameServerUncheckedCreateWithoutOwnerInput> | GameServerCreateWithoutOwnerInput[] | GameServerUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutOwnerInput | GameServerCreateOrConnectWithoutOwnerInput[]
    createMany?: GameServerCreateManyOwnerInputEnvelope
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AlertCreateNestedManyWithoutResolvedByInput = {
    create?: XOR<AlertCreateWithoutResolvedByInput, AlertUncheckedCreateWithoutResolvedByInput> | AlertCreateWithoutResolvedByInput[] | AlertUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutResolvedByInput | AlertCreateOrConnectWithoutResolvedByInput[]
    createMany?: AlertCreateManyResolvedByInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type ResourceQuotaCreateNestedManyWithoutUserInput = {
    create?: XOR<ResourceQuotaCreateWithoutUserInput, ResourceQuotaUncheckedCreateWithoutUserInput> | ResourceQuotaCreateWithoutUserInput[] | ResourceQuotaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceQuotaCreateOrConnectWithoutUserInput | ResourceQuotaCreateOrConnectWithoutUserInput[]
    createMany?: ResourceQuotaCreateManyUserInputEnvelope
    connect?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type IncidentCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<IncidentCreateWithoutAssignedToInput, IncidentUncheckedCreateWithoutAssignedToInput> | IncidentCreateWithoutAssignedToInput[] | IncidentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutAssignedToInput | IncidentCreateOrConnectWithoutAssignedToInput[]
    createMany?: IncidentCreateManyAssignedToInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type TicketCommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput> | TicketCommentCreateWithoutAuthorInput[] | TicketCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutAuthorInput | TicketCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: TicketCommentCreateManyAuthorInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput = {
    create?: XOR<KnowledgeBaseArticleCreateWithoutAuthorInput, KnowledgeBaseArticleUncheckedCreateWithoutAuthorInput> | KnowledgeBaseArticleCreateWithoutAuthorInput[] | KnowledgeBaseArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: KnowledgeBaseArticleCreateOrConnectWithoutAuthorInput | KnowledgeBaseArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: KnowledgeBaseArticleCreateManyAuthorInputEnvelope
    connect?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
  }

  export type GameServerUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<GameServerCreateWithoutOwnerInput, GameServerUncheckedCreateWithoutOwnerInput> | GameServerCreateWithoutOwnerInput[] | GameServerUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutOwnerInput | GameServerCreateOrConnectWithoutOwnerInput[]
    createMany?: GameServerCreateManyOwnerInputEnvelope
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutResolvedByInput = {
    create?: XOR<AlertCreateWithoutResolvedByInput, AlertUncheckedCreateWithoutResolvedByInput> | AlertCreateWithoutResolvedByInput[] | AlertUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutResolvedByInput | AlertCreateOrConnectWithoutResolvedByInput[]
    createMany?: AlertCreateManyResolvedByInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type ResourceQuotaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResourceQuotaCreateWithoutUserInput, ResourceQuotaUncheckedCreateWithoutUserInput> | ResourceQuotaCreateWithoutUserInput[] | ResourceQuotaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceQuotaCreateOrConnectWithoutUserInput | ResourceQuotaCreateOrConnectWithoutUserInput[]
    createMany?: ResourceQuotaCreateManyUserInputEnvelope
    connect?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type IncidentUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<IncidentCreateWithoutAssignedToInput, IncidentUncheckedCreateWithoutAssignedToInput> | IncidentCreateWithoutAssignedToInput[] | IncidentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutAssignedToInput | IncidentCreateOrConnectWithoutAssignedToInput[]
    createMany?: IncidentCreateManyAssignedToInputEnvelope
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput> | TicketCommentCreateWithoutAuthorInput[] | TicketCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutAuthorInput | TicketCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: TicketCommentCreateManyAuthorInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<KnowledgeBaseArticleCreateWithoutAuthorInput, KnowledgeBaseArticleUncheckedCreateWithoutAuthorInput> | KnowledgeBaseArticleCreateWithoutAuthorInput[] | KnowledgeBaseArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: KnowledgeBaseArticleCreateOrConnectWithoutAuthorInput | KnowledgeBaseArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: KnowledgeBaseArticleCreateManyAuthorInputEnvelope
    connect?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type GameServerUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<GameServerCreateWithoutOwnerInput, GameServerUncheckedCreateWithoutOwnerInput> | GameServerCreateWithoutOwnerInput[] | GameServerUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutOwnerInput | GameServerCreateOrConnectWithoutOwnerInput[]
    upsert?: GameServerUpsertWithWhereUniqueWithoutOwnerInput | GameServerUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: GameServerCreateManyOwnerInputEnvelope
    set?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    disconnect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    delete?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    update?: GameServerUpdateWithWhereUniqueWithoutOwnerInput | GameServerUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: GameServerUpdateManyWithWhereWithoutOwnerInput | GameServerUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: GameServerScalarWhereInput | GameServerScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AlertUpdateManyWithoutResolvedByNestedInput = {
    create?: XOR<AlertCreateWithoutResolvedByInput, AlertUncheckedCreateWithoutResolvedByInput> | AlertCreateWithoutResolvedByInput[] | AlertUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutResolvedByInput | AlertCreateOrConnectWithoutResolvedByInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutResolvedByInput | AlertUpsertWithWhereUniqueWithoutResolvedByInput[]
    createMany?: AlertCreateManyResolvedByInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutResolvedByInput | AlertUpdateWithWhereUniqueWithoutResolvedByInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutResolvedByInput | AlertUpdateManyWithWhereWithoutResolvedByInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type ResourceQuotaUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResourceQuotaCreateWithoutUserInput, ResourceQuotaUncheckedCreateWithoutUserInput> | ResourceQuotaCreateWithoutUserInput[] | ResourceQuotaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceQuotaCreateOrConnectWithoutUserInput | ResourceQuotaCreateOrConnectWithoutUserInput[]
    upsert?: ResourceQuotaUpsertWithWhereUniqueWithoutUserInput | ResourceQuotaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResourceQuotaCreateManyUserInputEnvelope
    set?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    disconnect?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    delete?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    connect?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    update?: ResourceQuotaUpdateWithWhereUniqueWithoutUserInput | ResourceQuotaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResourceQuotaUpdateManyWithWhereWithoutUserInput | ResourceQuotaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResourceQuotaScalarWhereInput | ResourceQuotaScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type IncidentUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<IncidentCreateWithoutAssignedToInput, IncidentUncheckedCreateWithoutAssignedToInput> | IncidentCreateWithoutAssignedToInput[] | IncidentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutAssignedToInput | IncidentCreateOrConnectWithoutAssignedToInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutAssignedToInput | IncidentUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: IncidentCreateManyAssignedToInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutAssignedToInput | IncidentUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutAssignedToInput | IncidentUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type TicketCommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput> | TicketCommentCreateWithoutAuthorInput[] | TicketCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutAuthorInput | TicketCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutAuthorInput | TicketCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TicketCommentCreateManyAuthorInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutAuthorInput | TicketCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutAuthorInput | TicketCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput | SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput | SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutAssignedToInput | SupportTicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<KnowledgeBaseArticleCreateWithoutAuthorInput, KnowledgeBaseArticleUncheckedCreateWithoutAuthorInput> | KnowledgeBaseArticleCreateWithoutAuthorInput[] | KnowledgeBaseArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: KnowledgeBaseArticleCreateOrConnectWithoutAuthorInput | KnowledgeBaseArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: KnowledgeBaseArticleUpsertWithWhereUniqueWithoutAuthorInput | KnowledgeBaseArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: KnowledgeBaseArticleCreateManyAuthorInputEnvelope
    set?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    disconnect?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    delete?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    connect?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    update?: KnowledgeBaseArticleUpdateWithWhereUniqueWithoutAuthorInput | KnowledgeBaseArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: KnowledgeBaseArticleUpdateManyWithWhereWithoutAuthorInput | KnowledgeBaseArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: KnowledgeBaseArticleScalarWhereInput | KnowledgeBaseArticleScalarWhereInput[]
  }

  export type GameServerUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<GameServerCreateWithoutOwnerInput, GameServerUncheckedCreateWithoutOwnerInput> | GameServerCreateWithoutOwnerInput[] | GameServerUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutOwnerInput | GameServerCreateOrConnectWithoutOwnerInput[]
    upsert?: GameServerUpsertWithWhereUniqueWithoutOwnerInput | GameServerUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: GameServerCreateManyOwnerInputEnvelope
    set?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    disconnect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    delete?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    update?: GameServerUpdateWithWhereUniqueWithoutOwnerInput | GameServerUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: GameServerUpdateManyWithWhereWithoutOwnerInput | GameServerUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: GameServerScalarWhereInput | GameServerScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutResolvedByNestedInput = {
    create?: XOR<AlertCreateWithoutResolvedByInput, AlertUncheckedCreateWithoutResolvedByInput> | AlertCreateWithoutResolvedByInput[] | AlertUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutResolvedByInput | AlertCreateOrConnectWithoutResolvedByInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutResolvedByInput | AlertUpsertWithWhereUniqueWithoutResolvedByInput[]
    createMany?: AlertCreateManyResolvedByInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutResolvedByInput | AlertUpdateWithWhereUniqueWithoutResolvedByInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutResolvedByInput | AlertUpdateManyWithWhereWithoutResolvedByInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResourceQuotaCreateWithoutUserInput, ResourceQuotaUncheckedCreateWithoutUserInput> | ResourceQuotaCreateWithoutUserInput[] | ResourceQuotaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResourceQuotaCreateOrConnectWithoutUserInput | ResourceQuotaCreateOrConnectWithoutUserInput[]
    upsert?: ResourceQuotaUpsertWithWhereUniqueWithoutUserInput | ResourceQuotaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResourceQuotaCreateManyUserInputEnvelope
    set?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    disconnect?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    delete?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    connect?: ResourceQuotaWhereUniqueInput | ResourceQuotaWhereUniqueInput[]
    update?: ResourceQuotaUpdateWithWhereUniqueWithoutUserInput | ResourceQuotaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResourceQuotaUpdateManyWithWhereWithoutUserInput | ResourceQuotaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResourceQuotaScalarWhereInput | ResourceQuotaScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type IncidentUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<IncidentCreateWithoutAssignedToInput, IncidentUncheckedCreateWithoutAssignedToInput> | IncidentCreateWithoutAssignedToInput[] | IncidentUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: IncidentCreateOrConnectWithoutAssignedToInput | IncidentCreateOrConnectWithoutAssignedToInput[]
    upsert?: IncidentUpsertWithWhereUniqueWithoutAssignedToInput | IncidentUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: IncidentCreateManyAssignedToInputEnvelope
    set?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    disconnect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    delete?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    connect?: IncidentWhereUniqueInput | IncidentWhereUniqueInput[]
    update?: IncidentUpdateWithWhereUniqueWithoutAssignedToInput | IncidentUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: IncidentUpdateManyWithWhereWithoutAssignedToInput | IncidentUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput> | TicketCommentCreateWithoutAuthorInput[] | TicketCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutAuthorInput | TicketCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutAuthorInput | TicketCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: TicketCommentCreateManyAuthorInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutAuthorInput | TicketCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutAuthorInput | TicketCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput> | SupportTicketCreateWithoutAssignedToInput[] | SupportTicketUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutAssignedToInput | SupportTicketCreateOrConnectWithoutAssignedToInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput | SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: SupportTicketCreateManyAssignedToInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput | SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutAssignedToInput | SupportTicketUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<KnowledgeBaseArticleCreateWithoutAuthorInput, KnowledgeBaseArticleUncheckedCreateWithoutAuthorInput> | KnowledgeBaseArticleCreateWithoutAuthorInput[] | KnowledgeBaseArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: KnowledgeBaseArticleCreateOrConnectWithoutAuthorInput | KnowledgeBaseArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: KnowledgeBaseArticleUpsertWithWhereUniqueWithoutAuthorInput | KnowledgeBaseArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: KnowledgeBaseArticleCreateManyAuthorInputEnvelope
    set?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    disconnect?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    delete?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    connect?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    update?: KnowledgeBaseArticleUpdateWithWhereUniqueWithoutAuthorInput | KnowledgeBaseArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: KnowledgeBaseArticleUpdateManyWithWhereWithoutAuthorInput | KnowledgeBaseArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: KnowledgeBaseArticleScalarWhereInput | KnowledgeBaseArticleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type GameServerCreateNestedManyWithoutNodeInput = {
    create?: XOR<GameServerCreateWithoutNodeInput, GameServerUncheckedCreateWithoutNodeInput> | GameServerCreateWithoutNodeInput[] | GameServerUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutNodeInput | GameServerCreateOrConnectWithoutNodeInput[]
    createMany?: GameServerCreateManyNodeInputEnvelope
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
  }

  export type NetworkAllocationCreateNestedManyWithoutNodeInput = {
    create?: XOR<NetworkAllocationCreateWithoutNodeInput, NetworkAllocationUncheckedCreateWithoutNodeInput> | NetworkAllocationCreateWithoutNodeInput[] | NetworkAllocationUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: NetworkAllocationCreateOrConnectWithoutNodeInput | NetworkAllocationCreateOrConnectWithoutNodeInput[]
    createMany?: NetworkAllocationCreateManyNodeInputEnvelope
    connect?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
  }

  export type MetricCreateNestedManyWithoutNodeInput = {
    create?: XOR<MetricCreateWithoutNodeInput, MetricUncheckedCreateWithoutNodeInput> | MetricCreateWithoutNodeInput[] | MetricUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: MetricCreateOrConnectWithoutNodeInput | MetricCreateOrConnectWithoutNodeInput[]
    createMany?: MetricCreateManyNodeInputEnvelope
    connect?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
  }

  export type AlertCreateNestedManyWithoutNodeInput = {
    create?: XOR<AlertCreateWithoutNodeInput, AlertUncheckedCreateWithoutNodeInput> | AlertCreateWithoutNodeInput[] | AlertUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutNodeInput | AlertCreateOrConnectWithoutNodeInput[]
    createMany?: AlertCreateManyNodeInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type GameClusterCreateNestedManyWithoutStorageNodeInput = {
    create?: XOR<GameClusterCreateWithoutStorageNodeInput, GameClusterUncheckedCreateWithoutStorageNodeInput> | GameClusterCreateWithoutStorageNodeInput[] | GameClusterUncheckedCreateWithoutStorageNodeInput[]
    connectOrCreate?: GameClusterCreateOrConnectWithoutStorageNodeInput | GameClusterCreateOrConnectWithoutStorageNodeInput[]
    createMany?: GameClusterCreateManyStorageNodeInputEnvelope
    connect?: GameClusterWhereUniqueInput | GameClusterWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutNodeInput = {
    create?: XOR<TaskCreateWithoutNodeInput, TaskUncheckedCreateWithoutNodeInput> | TaskCreateWithoutNodeInput[] | TaskUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutNodeInput | TaskCreateOrConnectWithoutNodeInput[]
    createMany?: TaskCreateManyNodeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type GameServerUncheckedCreateNestedManyWithoutNodeInput = {
    create?: XOR<GameServerCreateWithoutNodeInput, GameServerUncheckedCreateWithoutNodeInput> | GameServerCreateWithoutNodeInput[] | GameServerUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutNodeInput | GameServerCreateOrConnectWithoutNodeInput[]
    createMany?: GameServerCreateManyNodeInputEnvelope
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
  }

  export type NetworkAllocationUncheckedCreateNestedManyWithoutNodeInput = {
    create?: XOR<NetworkAllocationCreateWithoutNodeInput, NetworkAllocationUncheckedCreateWithoutNodeInput> | NetworkAllocationCreateWithoutNodeInput[] | NetworkAllocationUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: NetworkAllocationCreateOrConnectWithoutNodeInput | NetworkAllocationCreateOrConnectWithoutNodeInput[]
    createMany?: NetworkAllocationCreateManyNodeInputEnvelope
    connect?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
  }

  export type MetricUncheckedCreateNestedManyWithoutNodeInput = {
    create?: XOR<MetricCreateWithoutNodeInput, MetricUncheckedCreateWithoutNodeInput> | MetricCreateWithoutNodeInput[] | MetricUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: MetricCreateOrConnectWithoutNodeInput | MetricCreateOrConnectWithoutNodeInput[]
    createMany?: MetricCreateManyNodeInputEnvelope
    connect?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutNodeInput = {
    create?: XOR<AlertCreateWithoutNodeInput, AlertUncheckedCreateWithoutNodeInput> | AlertCreateWithoutNodeInput[] | AlertUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutNodeInput | AlertCreateOrConnectWithoutNodeInput[]
    createMany?: AlertCreateManyNodeInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type GameClusterUncheckedCreateNestedManyWithoutStorageNodeInput = {
    create?: XOR<GameClusterCreateWithoutStorageNodeInput, GameClusterUncheckedCreateWithoutStorageNodeInput> | GameClusterCreateWithoutStorageNodeInput[] | GameClusterUncheckedCreateWithoutStorageNodeInput[]
    connectOrCreate?: GameClusterCreateOrConnectWithoutStorageNodeInput | GameClusterCreateOrConnectWithoutStorageNodeInput[]
    createMany?: GameClusterCreateManyStorageNodeInputEnvelope
    connect?: GameClusterWhereUniqueInput | GameClusterWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutNodeInput = {
    create?: XOR<TaskCreateWithoutNodeInput, TaskUncheckedCreateWithoutNodeInput> | TaskCreateWithoutNodeInput[] | TaskUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutNodeInput | TaskCreateOrConnectWithoutNodeInput[]
    createMany?: TaskCreateManyNodeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type EnumDiskTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiskType
  }

  export type EnumNodeStatusFieldUpdateOperationsInput = {
    set?: $Enums.NodeStatus
  }

  export type GameServerUpdateManyWithoutNodeNestedInput = {
    create?: XOR<GameServerCreateWithoutNodeInput, GameServerUncheckedCreateWithoutNodeInput> | GameServerCreateWithoutNodeInput[] | GameServerUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutNodeInput | GameServerCreateOrConnectWithoutNodeInput[]
    upsert?: GameServerUpsertWithWhereUniqueWithoutNodeInput | GameServerUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: GameServerCreateManyNodeInputEnvelope
    set?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    disconnect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    delete?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    update?: GameServerUpdateWithWhereUniqueWithoutNodeInput | GameServerUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: GameServerUpdateManyWithWhereWithoutNodeInput | GameServerUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: GameServerScalarWhereInput | GameServerScalarWhereInput[]
  }

  export type NetworkAllocationUpdateManyWithoutNodeNestedInput = {
    create?: XOR<NetworkAllocationCreateWithoutNodeInput, NetworkAllocationUncheckedCreateWithoutNodeInput> | NetworkAllocationCreateWithoutNodeInput[] | NetworkAllocationUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: NetworkAllocationCreateOrConnectWithoutNodeInput | NetworkAllocationCreateOrConnectWithoutNodeInput[]
    upsert?: NetworkAllocationUpsertWithWhereUniqueWithoutNodeInput | NetworkAllocationUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: NetworkAllocationCreateManyNodeInputEnvelope
    set?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    disconnect?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    delete?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    connect?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    update?: NetworkAllocationUpdateWithWhereUniqueWithoutNodeInput | NetworkAllocationUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: NetworkAllocationUpdateManyWithWhereWithoutNodeInput | NetworkAllocationUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: NetworkAllocationScalarWhereInput | NetworkAllocationScalarWhereInput[]
  }

  export type MetricUpdateManyWithoutNodeNestedInput = {
    create?: XOR<MetricCreateWithoutNodeInput, MetricUncheckedCreateWithoutNodeInput> | MetricCreateWithoutNodeInput[] | MetricUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: MetricCreateOrConnectWithoutNodeInput | MetricCreateOrConnectWithoutNodeInput[]
    upsert?: MetricUpsertWithWhereUniqueWithoutNodeInput | MetricUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: MetricCreateManyNodeInputEnvelope
    set?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    disconnect?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    delete?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    connect?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    update?: MetricUpdateWithWhereUniqueWithoutNodeInput | MetricUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: MetricUpdateManyWithWhereWithoutNodeInput | MetricUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: MetricScalarWhereInput | MetricScalarWhereInput[]
  }

  export type AlertUpdateManyWithoutNodeNestedInput = {
    create?: XOR<AlertCreateWithoutNodeInput, AlertUncheckedCreateWithoutNodeInput> | AlertCreateWithoutNodeInput[] | AlertUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutNodeInput | AlertCreateOrConnectWithoutNodeInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutNodeInput | AlertUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: AlertCreateManyNodeInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutNodeInput | AlertUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutNodeInput | AlertUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type GameClusterUpdateManyWithoutStorageNodeNestedInput = {
    create?: XOR<GameClusterCreateWithoutStorageNodeInput, GameClusterUncheckedCreateWithoutStorageNodeInput> | GameClusterCreateWithoutStorageNodeInput[] | GameClusterUncheckedCreateWithoutStorageNodeInput[]
    connectOrCreate?: GameClusterCreateOrConnectWithoutStorageNodeInput | GameClusterCreateOrConnectWithoutStorageNodeInput[]
    upsert?: GameClusterUpsertWithWhereUniqueWithoutStorageNodeInput | GameClusterUpsertWithWhereUniqueWithoutStorageNodeInput[]
    createMany?: GameClusterCreateManyStorageNodeInputEnvelope
    set?: GameClusterWhereUniqueInput | GameClusterWhereUniqueInput[]
    disconnect?: GameClusterWhereUniqueInput | GameClusterWhereUniqueInput[]
    delete?: GameClusterWhereUniqueInput | GameClusterWhereUniqueInput[]
    connect?: GameClusterWhereUniqueInput | GameClusterWhereUniqueInput[]
    update?: GameClusterUpdateWithWhereUniqueWithoutStorageNodeInput | GameClusterUpdateWithWhereUniqueWithoutStorageNodeInput[]
    updateMany?: GameClusterUpdateManyWithWhereWithoutStorageNodeInput | GameClusterUpdateManyWithWhereWithoutStorageNodeInput[]
    deleteMany?: GameClusterScalarWhereInput | GameClusterScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutNodeNestedInput = {
    create?: XOR<TaskCreateWithoutNodeInput, TaskUncheckedCreateWithoutNodeInput> | TaskCreateWithoutNodeInput[] | TaskUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutNodeInput | TaskCreateOrConnectWithoutNodeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutNodeInput | TaskUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: TaskCreateManyNodeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutNodeInput | TaskUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutNodeInput | TaskUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type GameServerUncheckedUpdateManyWithoutNodeNestedInput = {
    create?: XOR<GameServerCreateWithoutNodeInput, GameServerUncheckedCreateWithoutNodeInput> | GameServerCreateWithoutNodeInput[] | GameServerUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutNodeInput | GameServerCreateOrConnectWithoutNodeInput[]
    upsert?: GameServerUpsertWithWhereUniqueWithoutNodeInput | GameServerUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: GameServerCreateManyNodeInputEnvelope
    set?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    disconnect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    delete?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    update?: GameServerUpdateWithWhereUniqueWithoutNodeInput | GameServerUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: GameServerUpdateManyWithWhereWithoutNodeInput | GameServerUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: GameServerScalarWhereInput | GameServerScalarWhereInput[]
  }

  export type NetworkAllocationUncheckedUpdateManyWithoutNodeNestedInput = {
    create?: XOR<NetworkAllocationCreateWithoutNodeInput, NetworkAllocationUncheckedCreateWithoutNodeInput> | NetworkAllocationCreateWithoutNodeInput[] | NetworkAllocationUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: NetworkAllocationCreateOrConnectWithoutNodeInput | NetworkAllocationCreateOrConnectWithoutNodeInput[]
    upsert?: NetworkAllocationUpsertWithWhereUniqueWithoutNodeInput | NetworkAllocationUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: NetworkAllocationCreateManyNodeInputEnvelope
    set?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    disconnect?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    delete?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    connect?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    update?: NetworkAllocationUpdateWithWhereUniqueWithoutNodeInput | NetworkAllocationUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: NetworkAllocationUpdateManyWithWhereWithoutNodeInput | NetworkAllocationUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: NetworkAllocationScalarWhereInput | NetworkAllocationScalarWhereInput[]
  }

  export type MetricUncheckedUpdateManyWithoutNodeNestedInput = {
    create?: XOR<MetricCreateWithoutNodeInput, MetricUncheckedCreateWithoutNodeInput> | MetricCreateWithoutNodeInput[] | MetricUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: MetricCreateOrConnectWithoutNodeInput | MetricCreateOrConnectWithoutNodeInput[]
    upsert?: MetricUpsertWithWhereUniqueWithoutNodeInput | MetricUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: MetricCreateManyNodeInputEnvelope
    set?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    disconnect?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    delete?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    connect?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    update?: MetricUpdateWithWhereUniqueWithoutNodeInput | MetricUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: MetricUpdateManyWithWhereWithoutNodeInput | MetricUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: MetricScalarWhereInput | MetricScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutNodeNestedInput = {
    create?: XOR<AlertCreateWithoutNodeInput, AlertUncheckedCreateWithoutNodeInput> | AlertCreateWithoutNodeInput[] | AlertUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutNodeInput | AlertCreateOrConnectWithoutNodeInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutNodeInput | AlertUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: AlertCreateManyNodeInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutNodeInput | AlertUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutNodeInput | AlertUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type GameClusterUncheckedUpdateManyWithoutStorageNodeNestedInput = {
    create?: XOR<GameClusterCreateWithoutStorageNodeInput, GameClusterUncheckedCreateWithoutStorageNodeInput> | GameClusterCreateWithoutStorageNodeInput[] | GameClusterUncheckedCreateWithoutStorageNodeInput[]
    connectOrCreate?: GameClusterCreateOrConnectWithoutStorageNodeInput | GameClusterCreateOrConnectWithoutStorageNodeInput[]
    upsert?: GameClusterUpsertWithWhereUniqueWithoutStorageNodeInput | GameClusterUpsertWithWhereUniqueWithoutStorageNodeInput[]
    createMany?: GameClusterCreateManyStorageNodeInputEnvelope
    set?: GameClusterWhereUniqueInput | GameClusterWhereUniqueInput[]
    disconnect?: GameClusterWhereUniqueInput | GameClusterWhereUniqueInput[]
    delete?: GameClusterWhereUniqueInput | GameClusterWhereUniqueInput[]
    connect?: GameClusterWhereUniqueInput | GameClusterWhereUniqueInput[]
    update?: GameClusterUpdateWithWhereUniqueWithoutStorageNodeInput | GameClusterUpdateWithWhereUniqueWithoutStorageNodeInput[]
    updateMany?: GameClusterUpdateManyWithWhereWithoutStorageNodeInput | GameClusterUpdateManyWithWhereWithoutStorageNodeInput[]
    deleteMany?: GameClusterScalarWhereInput | GameClusterScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutNodeNestedInput = {
    create?: XOR<TaskCreateWithoutNodeInput, TaskUncheckedCreateWithoutNodeInput> | TaskCreateWithoutNodeInput[] | TaskUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutNodeInput | TaskCreateOrConnectWithoutNodeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutNodeInput | TaskUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: TaskCreateManyNodeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutNodeInput | TaskUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutNodeInput | TaskUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type NodeCreateNestedOneWithoutTasksInput = {
    create?: XOR<NodeCreateWithoutTasksInput, NodeUncheckedCreateWithoutTasksInput>
    connectOrCreate?: NodeCreateOrConnectWithoutTasksInput
    connect?: NodeWhereUniqueInput
  }

  export type EnumTaskTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaskType
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type NodeUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<NodeCreateWithoutTasksInput, NodeUncheckedCreateWithoutTasksInput>
    connectOrCreate?: NodeCreateOrConnectWithoutTasksInput
    upsert?: NodeUpsertWithoutTasksInput
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutTasksInput, NodeUpdateWithoutTasksInput>, NodeUncheckedUpdateWithoutTasksInput>
  }

  export type NodeCreateNestedOneWithoutNetworkAllocationsInput = {
    create?: XOR<NodeCreateWithoutNetworkAllocationsInput, NodeUncheckedCreateWithoutNetworkAllocationsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutNetworkAllocationsInput
    connect?: NodeWhereUniqueInput
  }

  export type GameServerCreateNestedOneWithoutNetworkAllocationsInput = {
    create?: XOR<GameServerCreateWithoutNetworkAllocationsInput, GameServerUncheckedCreateWithoutNetworkAllocationsInput>
    connectOrCreate?: GameServerCreateOrConnectWithoutNetworkAllocationsInput
    connect?: GameServerWhereUniqueInput
  }

  export type EnumProtocolFieldUpdateOperationsInput = {
    set?: $Enums.Protocol
  }

  export type EnumPortTypeFieldUpdateOperationsInput = {
    set?: $Enums.PortType
  }

  export type NodeUpdateOneRequiredWithoutNetworkAllocationsNestedInput = {
    create?: XOR<NodeCreateWithoutNetworkAllocationsInput, NodeUncheckedCreateWithoutNetworkAllocationsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutNetworkAllocationsInput
    upsert?: NodeUpsertWithoutNetworkAllocationsInput
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutNetworkAllocationsInput, NodeUpdateWithoutNetworkAllocationsInput>, NodeUncheckedUpdateWithoutNetworkAllocationsInput>
  }

  export type GameServerUpdateOneWithoutNetworkAllocationsNestedInput = {
    create?: XOR<GameServerCreateWithoutNetworkAllocationsInput, GameServerUncheckedCreateWithoutNetworkAllocationsInput>
    connectOrCreate?: GameServerCreateOrConnectWithoutNetworkAllocationsInput
    upsert?: GameServerUpsertWithoutNetworkAllocationsInput
    disconnect?: GameServerWhereInput | boolean
    delete?: GameServerWhereInput | boolean
    connect?: GameServerWhereUniqueInput
    update?: XOR<XOR<GameServerUpdateToOneWithWhereWithoutNetworkAllocationsInput, GameServerUpdateWithoutNetworkAllocationsInput>, GameServerUncheckedUpdateWithoutNetworkAllocationsInput>
  }

  export type GameServerCreateNestedOneWithoutSubdomainsInput = {
    create?: XOR<GameServerCreateWithoutSubdomainsInput, GameServerUncheckedCreateWithoutSubdomainsInput>
    connectOrCreate?: GameServerCreateOrConnectWithoutSubdomainsInput
    connect?: GameServerWhereUniqueInput
  }

  export type GameServerUpdateOneRequiredWithoutSubdomainsNestedInput = {
    create?: XOR<GameServerCreateWithoutSubdomainsInput, GameServerUncheckedCreateWithoutSubdomainsInput>
    connectOrCreate?: GameServerCreateOrConnectWithoutSubdomainsInput
    upsert?: GameServerUpsertWithoutSubdomainsInput
    connect?: GameServerWhereUniqueInput
    update?: XOR<XOR<GameServerUpdateToOneWithWhereWithoutSubdomainsInput, GameServerUpdateWithoutSubdomainsInput>, GameServerUncheckedUpdateWithoutSubdomainsInput>
  }

  export type NodeCreateNestedOneWithoutServersInput = {
    create?: XOR<NodeCreateWithoutServersInput, NodeUncheckedCreateWithoutServersInput>
    connectOrCreate?: NodeCreateOrConnectWithoutServersInput
    connect?: NodeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedServersInput = {
    create?: XOR<UserCreateWithoutOwnedServersInput, UserUncheckedCreateWithoutOwnedServersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedServersInput
    connect?: UserWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutServersInput = {
    create?: XOR<PlanCreateWithoutServersInput, PlanUncheckedCreateWithoutServersInput>
    connectOrCreate?: PlanCreateOrConnectWithoutServersInput
    connect?: PlanWhereUniqueInput
  }

  export type GameClusterCreateNestedOneWithoutServersInput = {
    create?: XOR<GameClusterCreateWithoutServersInput, GameClusterUncheckedCreateWithoutServersInput>
    connectOrCreate?: GameClusterCreateOrConnectWithoutServersInput
    connect?: GameClusterWhereUniqueInput
  }

  export type NetworkAllocationCreateNestedManyWithoutServerInput = {
    create?: XOR<NetworkAllocationCreateWithoutServerInput, NetworkAllocationUncheckedCreateWithoutServerInput> | NetworkAllocationCreateWithoutServerInput[] | NetworkAllocationUncheckedCreateWithoutServerInput[]
    connectOrCreate?: NetworkAllocationCreateOrConnectWithoutServerInput | NetworkAllocationCreateOrConnectWithoutServerInput[]
    createMany?: NetworkAllocationCreateManyServerInputEnvelope
    connect?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
  }

  export type SubdomainCreateNestedManyWithoutServerInput = {
    create?: XOR<SubdomainCreateWithoutServerInput, SubdomainUncheckedCreateWithoutServerInput> | SubdomainCreateWithoutServerInput[] | SubdomainUncheckedCreateWithoutServerInput[]
    connectOrCreate?: SubdomainCreateOrConnectWithoutServerInput | SubdomainCreateOrConnectWithoutServerInput[]
    createMany?: SubdomainCreateManyServerInputEnvelope
    connect?: SubdomainWhereUniqueInput | SubdomainWhereUniqueInput[]
  }

  export type BackupCreateNestedManyWithoutServerInput = {
    create?: XOR<BackupCreateWithoutServerInput, BackupUncheckedCreateWithoutServerInput> | BackupCreateWithoutServerInput[] | BackupUncheckedCreateWithoutServerInput[]
    connectOrCreate?: BackupCreateOrConnectWithoutServerInput | BackupCreateOrConnectWithoutServerInput[]
    createMany?: BackupCreateManyServerInputEnvelope
    connect?: BackupWhereUniqueInput | BackupWhereUniqueInput[]
  }

  export type MetricCreateNestedManyWithoutServerInput = {
    create?: XOR<MetricCreateWithoutServerInput, MetricUncheckedCreateWithoutServerInput> | MetricCreateWithoutServerInput[] | MetricUncheckedCreateWithoutServerInput[]
    connectOrCreate?: MetricCreateOrConnectWithoutServerInput | MetricCreateOrConnectWithoutServerInput[]
    createMany?: MetricCreateManyServerInputEnvelope
    connect?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
  }

  export type AlertCreateNestedManyWithoutServerInput = {
    create?: XOR<AlertCreateWithoutServerInput, AlertUncheckedCreateWithoutServerInput> | AlertCreateWithoutServerInput[] | AlertUncheckedCreateWithoutServerInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutServerInput | AlertCreateOrConnectWithoutServerInput[]
    createMany?: AlertCreateManyServerInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutServerInput = {
    create?: XOR<OrderCreateWithoutServerInput, OrderUncheckedCreateWithoutServerInput> | OrderCreateWithoutServerInput[] | OrderUncheckedCreateWithoutServerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutServerInput | OrderCreateOrConnectWithoutServerInput[]
    createMany?: OrderCreateManyServerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NetworkAllocationUncheckedCreateNestedManyWithoutServerInput = {
    create?: XOR<NetworkAllocationCreateWithoutServerInput, NetworkAllocationUncheckedCreateWithoutServerInput> | NetworkAllocationCreateWithoutServerInput[] | NetworkAllocationUncheckedCreateWithoutServerInput[]
    connectOrCreate?: NetworkAllocationCreateOrConnectWithoutServerInput | NetworkAllocationCreateOrConnectWithoutServerInput[]
    createMany?: NetworkAllocationCreateManyServerInputEnvelope
    connect?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
  }

  export type SubdomainUncheckedCreateNestedManyWithoutServerInput = {
    create?: XOR<SubdomainCreateWithoutServerInput, SubdomainUncheckedCreateWithoutServerInput> | SubdomainCreateWithoutServerInput[] | SubdomainUncheckedCreateWithoutServerInput[]
    connectOrCreate?: SubdomainCreateOrConnectWithoutServerInput | SubdomainCreateOrConnectWithoutServerInput[]
    createMany?: SubdomainCreateManyServerInputEnvelope
    connect?: SubdomainWhereUniqueInput | SubdomainWhereUniqueInput[]
  }

  export type BackupUncheckedCreateNestedManyWithoutServerInput = {
    create?: XOR<BackupCreateWithoutServerInput, BackupUncheckedCreateWithoutServerInput> | BackupCreateWithoutServerInput[] | BackupUncheckedCreateWithoutServerInput[]
    connectOrCreate?: BackupCreateOrConnectWithoutServerInput | BackupCreateOrConnectWithoutServerInput[]
    createMany?: BackupCreateManyServerInputEnvelope
    connect?: BackupWhereUniqueInput | BackupWhereUniqueInput[]
  }

  export type MetricUncheckedCreateNestedManyWithoutServerInput = {
    create?: XOR<MetricCreateWithoutServerInput, MetricUncheckedCreateWithoutServerInput> | MetricCreateWithoutServerInput[] | MetricUncheckedCreateWithoutServerInput[]
    connectOrCreate?: MetricCreateOrConnectWithoutServerInput | MetricCreateOrConnectWithoutServerInput[]
    createMany?: MetricCreateManyServerInputEnvelope
    connect?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutServerInput = {
    create?: XOR<AlertCreateWithoutServerInput, AlertUncheckedCreateWithoutServerInput> | AlertCreateWithoutServerInput[] | AlertUncheckedCreateWithoutServerInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutServerInput | AlertCreateOrConnectWithoutServerInput[]
    createMany?: AlertCreateManyServerInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutServerInput = {
    create?: XOR<OrderCreateWithoutServerInput, OrderUncheckedCreateWithoutServerInput> | OrderCreateWithoutServerInput[] | OrderUncheckedCreateWithoutServerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutServerInput | OrderCreateOrConnectWithoutServerInput[]
    createMany?: OrderCreateManyServerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type EnumGameTypeFieldUpdateOperationsInput = {
    set?: $Enums.GameType
  }

  export type EnumServerStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServerStatus
  }

  export type NodeUpdateOneRequiredWithoutServersNestedInput = {
    create?: XOR<NodeCreateWithoutServersInput, NodeUncheckedCreateWithoutServersInput>
    connectOrCreate?: NodeCreateOrConnectWithoutServersInput
    upsert?: NodeUpsertWithoutServersInput
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutServersInput, NodeUpdateWithoutServersInput>, NodeUncheckedUpdateWithoutServersInput>
  }

  export type UserUpdateOneRequiredWithoutOwnedServersNestedInput = {
    create?: XOR<UserCreateWithoutOwnedServersInput, UserUncheckedCreateWithoutOwnedServersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedServersInput
    upsert?: UserUpsertWithoutOwnedServersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedServersInput, UserUpdateWithoutOwnedServersInput>, UserUncheckedUpdateWithoutOwnedServersInput>
  }

  export type PlanUpdateOneWithoutServersNestedInput = {
    create?: XOR<PlanCreateWithoutServersInput, PlanUncheckedCreateWithoutServersInput>
    connectOrCreate?: PlanCreateOrConnectWithoutServersInput
    upsert?: PlanUpsertWithoutServersInput
    disconnect?: PlanWhereInput | boolean
    delete?: PlanWhereInput | boolean
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutServersInput, PlanUpdateWithoutServersInput>, PlanUncheckedUpdateWithoutServersInput>
  }

  export type GameClusterUpdateOneWithoutServersNestedInput = {
    create?: XOR<GameClusterCreateWithoutServersInput, GameClusterUncheckedCreateWithoutServersInput>
    connectOrCreate?: GameClusterCreateOrConnectWithoutServersInput
    upsert?: GameClusterUpsertWithoutServersInput
    disconnect?: GameClusterWhereInput | boolean
    delete?: GameClusterWhereInput | boolean
    connect?: GameClusterWhereUniqueInput
    update?: XOR<XOR<GameClusterUpdateToOneWithWhereWithoutServersInput, GameClusterUpdateWithoutServersInput>, GameClusterUncheckedUpdateWithoutServersInput>
  }

  export type NetworkAllocationUpdateManyWithoutServerNestedInput = {
    create?: XOR<NetworkAllocationCreateWithoutServerInput, NetworkAllocationUncheckedCreateWithoutServerInput> | NetworkAllocationCreateWithoutServerInput[] | NetworkAllocationUncheckedCreateWithoutServerInput[]
    connectOrCreate?: NetworkAllocationCreateOrConnectWithoutServerInput | NetworkAllocationCreateOrConnectWithoutServerInput[]
    upsert?: NetworkAllocationUpsertWithWhereUniqueWithoutServerInput | NetworkAllocationUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: NetworkAllocationCreateManyServerInputEnvelope
    set?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    disconnect?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    delete?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    connect?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    update?: NetworkAllocationUpdateWithWhereUniqueWithoutServerInput | NetworkAllocationUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: NetworkAllocationUpdateManyWithWhereWithoutServerInput | NetworkAllocationUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: NetworkAllocationScalarWhereInput | NetworkAllocationScalarWhereInput[]
  }

  export type SubdomainUpdateManyWithoutServerNestedInput = {
    create?: XOR<SubdomainCreateWithoutServerInput, SubdomainUncheckedCreateWithoutServerInput> | SubdomainCreateWithoutServerInput[] | SubdomainUncheckedCreateWithoutServerInput[]
    connectOrCreate?: SubdomainCreateOrConnectWithoutServerInput | SubdomainCreateOrConnectWithoutServerInput[]
    upsert?: SubdomainUpsertWithWhereUniqueWithoutServerInput | SubdomainUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: SubdomainCreateManyServerInputEnvelope
    set?: SubdomainWhereUniqueInput | SubdomainWhereUniqueInput[]
    disconnect?: SubdomainWhereUniqueInput | SubdomainWhereUniqueInput[]
    delete?: SubdomainWhereUniqueInput | SubdomainWhereUniqueInput[]
    connect?: SubdomainWhereUniqueInput | SubdomainWhereUniqueInput[]
    update?: SubdomainUpdateWithWhereUniqueWithoutServerInput | SubdomainUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: SubdomainUpdateManyWithWhereWithoutServerInput | SubdomainUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: SubdomainScalarWhereInput | SubdomainScalarWhereInput[]
  }

  export type BackupUpdateManyWithoutServerNestedInput = {
    create?: XOR<BackupCreateWithoutServerInput, BackupUncheckedCreateWithoutServerInput> | BackupCreateWithoutServerInput[] | BackupUncheckedCreateWithoutServerInput[]
    connectOrCreate?: BackupCreateOrConnectWithoutServerInput | BackupCreateOrConnectWithoutServerInput[]
    upsert?: BackupUpsertWithWhereUniqueWithoutServerInput | BackupUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: BackupCreateManyServerInputEnvelope
    set?: BackupWhereUniqueInput | BackupWhereUniqueInput[]
    disconnect?: BackupWhereUniqueInput | BackupWhereUniqueInput[]
    delete?: BackupWhereUniqueInput | BackupWhereUniqueInput[]
    connect?: BackupWhereUniqueInput | BackupWhereUniqueInput[]
    update?: BackupUpdateWithWhereUniqueWithoutServerInput | BackupUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: BackupUpdateManyWithWhereWithoutServerInput | BackupUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: BackupScalarWhereInput | BackupScalarWhereInput[]
  }

  export type MetricUpdateManyWithoutServerNestedInput = {
    create?: XOR<MetricCreateWithoutServerInput, MetricUncheckedCreateWithoutServerInput> | MetricCreateWithoutServerInput[] | MetricUncheckedCreateWithoutServerInput[]
    connectOrCreate?: MetricCreateOrConnectWithoutServerInput | MetricCreateOrConnectWithoutServerInput[]
    upsert?: MetricUpsertWithWhereUniqueWithoutServerInput | MetricUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: MetricCreateManyServerInputEnvelope
    set?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    disconnect?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    delete?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    connect?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    update?: MetricUpdateWithWhereUniqueWithoutServerInput | MetricUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: MetricUpdateManyWithWhereWithoutServerInput | MetricUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: MetricScalarWhereInput | MetricScalarWhereInput[]
  }

  export type AlertUpdateManyWithoutServerNestedInput = {
    create?: XOR<AlertCreateWithoutServerInput, AlertUncheckedCreateWithoutServerInput> | AlertCreateWithoutServerInput[] | AlertUncheckedCreateWithoutServerInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutServerInput | AlertCreateOrConnectWithoutServerInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutServerInput | AlertUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: AlertCreateManyServerInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutServerInput | AlertUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutServerInput | AlertUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutServerNestedInput = {
    create?: XOR<OrderCreateWithoutServerInput, OrderUncheckedCreateWithoutServerInput> | OrderCreateWithoutServerInput[] | OrderUncheckedCreateWithoutServerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutServerInput | OrderCreateOrConnectWithoutServerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutServerInput | OrderUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: OrderCreateManyServerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutServerInput | OrderUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutServerInput | OrderUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type NetworkAllocationUncheckedUpdateManyWithoutServerNestedInput = {
    create?: XOR<NetworkAllocationCreateWithoutServerInput, NetworkAllocationUncheckedCreateWithoutServerInput> | NetworkAllocationCreateWithoutServerInput[] | NetworkAllocationUncheckedCreateWithoutServerInput[]
    connectOrCreate?: NetworkAllocationCreateOrConnectWithoutServerInput | NetworkAllocationCreateOrConnectWithoutServerInput[]
    upsert?: NetworkAllocationUpsertWithWhereUniqueWithoutServerInput | NetworkAllocationUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: NetworkAllocationCreateManyServerInputEnvelope
    set?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    disconnect?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    delete?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    connect?: NetworkAllocationWhereUniqueInput | NetworkAllocationWhereUniqueInput[]
    update?: NetworkAllocationUpdateWithWhereUniqueWithoutServerInput | NetworkAllocationUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: NetworkAllocationUpdateManyWithWhereWithoutServerInput | NetworkAllocationUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: NetworkAllocationScalarWhereInput | NetworkAllocationScalarWhereInput[]
  }

  export type SubdomainUncheckedUpdateManyWithoutServerNestedInput = {
    create?: XOR<SubdomainCreateWithoutServerInput, SubdomainUncheckedCreateWithoutServerInput> | SubdomainCreateWithoutServerInput[] | SubdomainUncheckedCreateWithoutServerInput[]
    connectOrCreate?: SubdomainCreateOrConnectWithoutServerInput | SubdomainCreateOrConnectWithoutServerInput[]
    upsert?: SubdomainUpsertWithWhereUniqueWithoutServerInput | SubdomainUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: SubdomainCreateManyServerInputEnvelope
    set?: SubdomainWhereUniqueInput | SubdomainWhereUniqueInput[]
    disconnect?: SubdomainWhereUniqueInput | SubdomainWhereUniqueInput[]
    delete?: SubdomainWhereUniqueInput | SubdomainWhereUniqueInput[]
    connect?: SubdomainWhereUniqueInput | SubdomainWhereUniqueInput[]
    update?: SubdomainUpdateWithWhereUniqueWithoutServerInput | SubdomainUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: SubdomainUpdateManyWithWhereWithoutServerInput | SubdomainUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: SubdomainScalarWhereInput | SubdomainScalarWhereInput[]
  }

  export type BackupUncheckedUpdateManyWithoutServerNestedInput = {
    create?: XOR<BackupCreateWithoutServerInput, BackupUncheckedCreateWithoutServerInput> | BackupCreateWithoutServerInput[] | BackupUncheckedCreateWithoutServerInput[]
    connectOrCreate?: BackupCreateOrConnectWithoutServerInput | BackupCreateOrConnectWithoutServerInput[]
    upsert?: BackupUpsertWithWhereUniqueWithoutServerInput | BackupUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: BackupCreateManyServerInputEnvelope
    set?: BackupWhereUniqueInput | BackupWhereUniqueInput[]
    disconnect?: BackupWhereUniqueInput | BackupWhereUniqueInput[]
    delete?: BackupWhereUniqueInput | BackupWhereUniqueInput[]
    connect?: BackupWhereUniqueInput | BackupWhereUniqueInput[]
    update?: BackupUpdateWithWhereUniqueWithoutServerInput | BackupUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: BackupUpdateManyWithWhereWithoutServerInput | BackupUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: BackupScalarWhereInput | BackupScalarWhereInput[]
  }

  export type MetricUncheckedUpdateManyWithoutServerNestedInput = {
    create?: XOR<MetricCreateWithoutServerInput, MetricUncheckedCreateWithoutServerInput> | MetricCreateWithoutServerInput[] | MetricUncheckedCreateWithoutServerInput[]
    connectOrCreate?: MetricCreateOrConnectWithoutServerInput | MetricCreateOrConnectWithoutServerInput[]
    upsert?: MetricUpsertWithWhereUniqueWithoutServerInput | MetricUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: MetricCreateManyServerInputEnvelope
    set?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    disconnect?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    delete?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    connect?: MetricWhereUniqueInput | MetricWhereUniqueInput[]
    update?: MetricUpdateWithWhereUniqueWithoutServerInput | MetricUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: MetricUpdateManyWithWhereWithoutServerInput | MetricUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: MetricScalarWhereInput | MetricScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutServerNestedInput = {
    create?: XOR<AlertCreateWithoutServerInput, AlertUncheckedCreateWithoutServerInput> | AlertCreateWithoutServerInput[] | AlertUncheckedCreateWithoutServerInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutServerInput | AlertCreateOrConnectWithoutServerInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutServerInput | AlertUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: AlertCreateManyServerInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutServerInput | AlertUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutServerInput | AlertUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutServerNestedInput = {
    create?: XOR<OrderCreateWithoutServerInput, OrderUncheckedCreateWithoutServerInput> | OrderCreateWithoutServerInput[] | OrderUncheckedCreateWithoutServerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutServerInput | OrderCreateOrConnectWithoutServerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutServerInput | OrderUpsertWithWhereUniqueWithoutServerInput[]
    createMany?: OrderCreateManyServerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutServerInput | OrderUpdateWithWhereUniqueWithoutServerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutServerInput | OrderUpdateManyWithWhereWithoutServerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type NodeCreateNestedOneWithoutStorageClustersInput = {
    create?: XOR<NodeCreateWithoutStorageClustersInput, NodeUncheckedCreateWithoutStorageClustersInput>
    connectOrCreate?: NodeCreateOrConnectWithoutStorageClustersInput
    connect?: NodeWhereUniqueInput
  }

  export type GameServerCreateNestedManyWithoutClusterInput = {
    create?: XOR<GameServerCreateWithoutClusterInput, GameServerUncheckedCreateWithoutClusterInput> | GameServerCreateWithoutClusterInput[] | GameServerUncheckedCreateWithoutClusterInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutClusterInput | GameServerCreateOrConnectWithoutClusterInput[]
    createMany?: GameServerCreateManyClusterInputEnvelope
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
  }

  export type GameServerUncheckedCreateNestedManyWithoutClusterInput = {
    create?: XOR<GameServerCreateWithoutClusterInput, GameServerUncheckedCreateWithoutClusterInput> | GameServerCreateWithoutClusterInput[] | GameServerUncheckedCreateWithoutClusterInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutClusterInput | GameServerCreateOrConnectWithoutClusterInput[]
    createMany?: GameServerCreateManyClusterInputEnvelope
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
  }

  export type NodeUpdateOneRequiredWithoutStorageClustersNestedInput = {
    create?: XOR<NodeCreateWithoutStorageClustersInput, NodeUncheckedCreateWithoutStorageClustersInput>
    connectOrCreate?: NodeCreateOrConnectWithoutStorageClustersInput
    upsert?: NodeUpsertWithoutStorageClustersInput
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutStorageClustersInput, NodeUpdateWithoutStorageClustersInput>, NodeUncheckedUpdateWithoutStorageClustersInput>
  }

  export type GameServerUpdateManyWithoutClusterNestedInput = {
    create?: XOR<GameServerCreateWithoutClusterInput, GameServerUncheckedCreateWithoutClusterInput> | GameServerCreateWithoutClusterInput[] | GameServerUncheckedCreateWithoutClusterInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutClusterInput | GameServerCreateOrConnectWithoutClusterInput[]
    upsert?: GameServerUpsertWithWhereUniqueWithoutClusterInput | GameServerUpsertWithWhereUniqueWithoutClusterInput[]
    createMany?: GameServerCreateManyClusterInputEnvelope
    set?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    disconnect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    delete?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    update?: GameServerUpdateWithWhereUniqueWithoutClusterInput | GameServerUpdateWithWhereUniqueWithoutClusterInput[]
    updateMany?: GameServerUpdateManyWithWhereWithoutClusterInput | GameServerUpdateManyWithWhereWithoutClusterInput[]
    deleteMany?: GameServerScalarWhereInput | GameServerScalarWhereInput[]
  }

  export type GameServerUncheckedUpdateManyWithoutClusterNestedInput = {
    create?: XOR<GameServerCreateWithoutClusterInput, GameServerUncheckedCreateWithoutClusterInput> | GameServerCreateWithoutClusterInput[] | GameServerUncheckedCreateWithoutClusterInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutClusterInput | GameServerCreateOrConnectWithoutClusterInput[]
    upsert?: GameServerUpsertWithWhereUniqueWithoutClusterInput | GameServerUpsertWithWhereUniqueWithoutClusterInput[]
    createMany?: GameServerCreateManyClusterInputEnvelope
    set?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    disconnect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    delete?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    update?: GameServerUpdateWithWhereUniqueWithoutClusterInput | GameServerUpdateWithWhereUniqueWithoutClusterInput[]
    updateMany?: GameServerUpdateManyWithWhereWithoutClusterInput | GameServerUpdateManyWithWhereWithoutClusterInput[]
    deleteMany?: GameServerScalarWhereInput | GameServerScalarWhereInput[]
  }

  export type GameServerCreateNestedOneWithoutBackupsInput = {
    create?: XOR<GameServerCreateWithoutBackupsInput, GameServerUncheckedCreateWithoutBackupsInput>
    connectOrCreate?: GameServerCreateOrConnectWithoutBackupsInput
    connect?: GameServerWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumBackupLocationFieldUpdateOperationsInput = {
    set?: $Enums.BackupLocation
  }

  export type GameServerUpdateOneRequiredWithoutBackupsNestedInput = {
    create?: XOR<GameServerCreateWithoutBackupsInput, GameServerUncheckedCreateWithoutBackupsInput>
    connectOrCreate?: GameServerCreateOrConnectWithoutBackupsInput
    upsert?: GameServerUpsertWithoutBackupsInput
    connect?: GameServerWhereUniqueInput
    update?: XOR<XOR<GameServerUpdateToOneWithWhereWithoutBackupsInput, GameServerUpdateWithoutBackupsInput>, GameServerUncheckedUpdateWithoutBackupsInput>
  }

  export type NodeCreateNestedOneWithoutMetricsInput = {
    create?: XOR<NodeCreateWithoutMetricsInput, NodeUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutMetricsInput
    connect?: NodeWhereUniqueInput
  }

  export type GameServerCreateNestedOneWithoutMetricsInput = {
    create?: XOR<GameServerCreateWithoutMetricsInput, GameServerUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: GameServerCreateOrConnectWithoutMetricsInput
    connect?: GameServerWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NodeUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<NodeCreateWithoutMetricsInput, NodeUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutMetricsInput
    upsert?: NodeUpsertWithoutMetricsInput
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutMetricsInput, NodeUpdateWithoutMetricsInput>, NodeUncheckedUpdateWithoutMetricsInput>
  }

  export type GameServerUpdateOneWithoutMetricsNestedInput = {
    create?: XOR<GameServerCreateWithoutMetricsInput, GameServerUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: GameServerCreateOrConnectWithoutMetricsInput
    upsert?: GameServerUpsertWithoutMetricsInput
    disconnect?: GameServerWhereInput | boolean
    delete?: GameServerWhereInput | boolean
    connect?: GameServerWhereUniqueInput
    update?: XOR<XOR<GameServerUpdateToOneWithWhereWithoutMetricsInput, GameServerUpdateWithoutMetricsInput>, GameServerUncheckedUpdateWithoutMetricsInput>
  }

  export type UserCreateNestedOneWithoutResolvedAlertsInput = {
    create?: XOR<UserCreateWithoutResolvedAlertsInput, UserUncheckedCreateWithoutResolvedAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type NodeCreateNestedOneWithoutAlertsInput = {
    create?: XOR<NodeCreateWithoutAlertsInput, NodeUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutAlertsInput
    connect?: NodeWhereUniqueInput
  }

  export type GameServerCreateNestedOneWithoutAlertsInput = {
    create?: XOR<GameServerCreateWithoutAlertsInput, GameServerUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: GameServerCreateOrConnectWithoutAlertsInput
    connect?: GameServerWhereUniqueInput
  }

  export type EnumAlertSeverityFieldUpdateOperationsInput = {
    set?: $Enums.AlertSeverity
  }

  export type EnumResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResourceType
  }

  export type UserUpdateOneWithoutResolvedAlertsNestedInput = {
    create?: XOR<UserCreateWithoutResolvedAlertsInput, UserUncheckedCreateWithoutResolvedAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedAlertsInput
    upsert?: UserUpsertWithoutResolvedAlertsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResolvedAlertsInput, UserUpdateWithoutResolvedAlertsInput>, UserUncheckedUpdateWithoutResolvedAlertsInput>
  }

  export type NodeUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<NodeCreateWithoutAlertsInput, NodeUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutAlertsInput
    upsert?: NodeUpsertWithoutAlertsInput
    disconnect?: NodeWhereInput | boolean
    delete?: NodeWhereInput | boolean
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutAlertsInput, NodeUpdateWithoutAlertsInput>, NodeUncheckedUpdateWithoutAlertsInput>
  }

  export type GameServerUpdateOneWithoutAlertsNestedInput = {
    create?: XOR<GameServerCreateWithoutAlertsInput, GameServerUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: GameServerCreateOrConnectWithoutAlertsInput
    upsert?: GameServerUpsertWithoutAlertsInput
    disconnect?: GameServerWhereInput | boolean
    delete?: GameServerWhereInput | boolean
    connect?: GameServerWhereUniqueInput
    update?: XOR<XOR<GameServerUpdateToOneWithWhereWithoutAlertsInput, GameServerUpdateWithoutAlertsInput>, GameServerUncheckedUpdateWithoutAlertsInput>
  }

  export type UserCreateNestedOneWithoutResourceQuotasInput = {
    create?: XOR<UserCreateWithoutResourceQuotasInput, UserUncheckedCreateWithoutResourceQuotasInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourceQuotasInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutResourceQuotasInput = {
    create?: XOR<TenantCreateWithoutResourceQuotasInput, TenantUncheckedCreateWithoutResourceQuotasInput>
    connectOrCreate?: TenantCreateOrConnectWithoutResourceQuotasInput
    connect?: TenantWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutResourceQuotasNestedInput = {
    create?: XOR<UserCreateWithoutResourceQuotasInput, UserUncheckedCreateWithoutResourceQuotasInput>
    connectOrCreate?: UserCreateOrConnectWithoutResourceQuotasInput
    upsert?: UserUpsertWithoutResourceQuotasInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResourceQuotasInput, UserUpdateWithoutResourceQuotasInput>, UserUncheckedUpdateWithoutResourceQuotasInput>
  }

  export type TenantUpdateOneWithoutResourceQuotasNestedInput = {
    create?: XOR<TenantCreateWithoutResourceQuotasInput, TenantUncheckedCreateWithoutResourceQuotasInput>
    connectOrCreate?: TenantCreateOrConnectWithoutResourceQuotasInput
    upsert?: TenantUpsertWithoutResourceQuotasInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutResourceQuotasInput, TenantUpdateWithoutResourceQuotasInput>, TenantUncheckedUpdateWithoutResourceQuotasInput>
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserCreateNestedOneWithoutAssignedIncidentsInput = {
    create?: XOR<UserCreateWithoutAssignedIncidentsInput, UserUncheckedCreateWithoutAssignedIncidentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedIncidentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumIncidentSeverityFieldUpdateOperationsInput = {
    set?: $Enums.IncidentSeverity
  }

  export type EnumIncidentStatusFieldUpdateOperationsInput = {
    set?: $Enums.IncidentStatus
  }

  export type UserUpdateOneWithoutAssignedIncidentsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedIncidentsInput, UserUncheckedCreateWithoutAssignedIncidentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedIncidentsInput
    upsert?: UserUpsertWithoutAssignedIncidentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedIncidentsInput, UserUpdateWithoutAssignedIncidentsInput>, UserUncheckedUpdateWithoutAssignedIncidentsInput>
  }

  export type GameServerCreateNestedManyWithoutPlanInput = {
    create?: XOR<GameServerCreateWithoutPlanInput, GameServerUncheckedCreateWithoutPlanInput> | GameServerCreateWithoutPlanInput[] | GameServerUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutPlanInput | GameServerCreateOrConnectWithoutPlanInput[]
    createMany?: GameServerCreateManyPlanInputEnvelope
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutPlanInput = {
    create?: XOR<OrderCreateWithoutPlanInput, OrderUncheckedCreateWithoutPlanInput> | OrderCreateWithoutPlanInput[] | OrderUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPlanInput | OrderCreateOrConnectWithoutPlanInput[]
    createMany?: OrderCreateManyPlanInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PromotionCreateNestedManyWithoutPlanInput = {
    create?: XOR<PromotionCreateWithoutPlanInput, PromotionUncheckedCreateWithoutPlanInput> | PromotionCreateWithoutPlanInput[] | PromotionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutPlanInput | PromotionCreateOrConnectWithoutPlanInput[]
    createMany?: PromotionCreateManyPlanInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type GameServerUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<GameServerCreateWithoutPlanInput, GameServerUncheckedCreateWithoutPlanInput> | GameServerCreateWithoutPlanInput[] | GameServerUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutPlanInput | GameServerCreateOrConnectWithoutPlanInput[]
    createMany?: GameServerCreateManyPlanInputEnvelope
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<OrderCreateWithoutPlanInput, OrderUncheckedCreateWithoutPlanInput> | OrderCreateWithoutPlanInput[] | OrderUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPlanInput | OrderCreateOrConnectWithoutPlanInput[]
    createMany?: OrderCreateManyPlanInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PromotionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PromotionCreateWithoutPlanInput, PromotionUncheckedCreateWithoutPlanInput> | PromotionCreateWithoutPlanInput[] | PromotionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutPlanInput | PromotionCreateOrConnectWithoutPlanInput[]
    createMany?: PromotionCreateManyPlanInputEnvelope
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
  }

  export type EnumPlanStatusFieldUpdateOperationsInput = {
    set?: $Enums.PlanStatus
  }

  export type GameServerUpdateManyWithoutPlanNestedInput = {
    create?: XOR<GameServerCreateWithoutPlanInput, GameServerUncheckedCreateWithoutPlanInput> | GameServerCreateWithoutPlanInput[] | GameServerUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutPlanInput | GameServerCreateOrConnectWithoutPlanInput[]
    upsert?: GameServerUpsertWithWhereUniqueWithoutPlanInput | GameServerUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: GameServerCreateManyPlanInputEnvelope
    set?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    disconnect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    delete?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    update?: GameServerUpdateWithWhereUniqueWithoutPlanInput | GameServerUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: GameServerUpdateManyWithWhereWithoutPlanInput | GameServerUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: GameServerScalarWhereInput | GameServerScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutPlanNestedInput = {
    create?: XOR<OrderCreateWithoutPlanInput, OrderUncheckedCreateWithoutPlanInput> | OrderCreateWithoutPlanInput[] | OrderUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPlanInput | OrderCreateOrConnectWithoutPlanInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPlanInput | OrderUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: OrderCreateManyPlanInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPlanInput | OrderUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPlanInput | OrderUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PromotionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PromotionCreateWithoutPlanInput, PromotionUncheckedCreateWithoutPlanInput> | PromotionCreateWithoutPlanInput[] | PromotionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutPlanInput | PromotionCreateOrConnectWithoutPlanInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutPlanInput | PromotionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PromotionCreateManyPlanInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutPlanInput | PromotionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutPlanInput | PromotionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type GameServerUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<GameServerCreateWithoutPlanInput, GameServerUncheckedCreateWithoutPlanInput> | GameServerCreateWithoutPlanInput[] | GameServerUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: GameServerCreateOrConnectWithoutPlanInput | GameServerCreateOrConnectWithoutPlanInput[]
    upsert?: GameServerUpsertWithWhereUniqueWithoutPlanInput | GameServerUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: GameServerCreateManyPlanInputEnvelope
    set?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    disconnect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    delete?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    connect?: GameServerWhereUniqueInput | GameServerWhereUniqueInput[]
    update?: GameServerUpdateWithWhereUniqueWithoutPlanInput | GameServerUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: GameServerUpdateManyWithWhereWithoutPlanInput | GameServerUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: GameServerScalarWhereInput | GameServerScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<OrderCreateWithoutPlanInput, OrderUncheckedCreateWithoutPlanInput> | OrderCreateWithoutPlanInput[] | OrderUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutPlanInput | OrderCreateOrConnectWithoutPlanInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutPlanInput | OrderUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: OrderCreateManyPlanInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutPlanInput | OrderUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutPlanInput | OrderUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PromotionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PromotionCreateWithoutPlanInput, PromotionUncheckedCreateWithoutPlanInput> | PromotionCreateWithoutPlanInput[] | PromotionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PromotionCreateOrConnectWithoutPlanInput | PromotionCreateOrConnectWithoutPlanInput[]
    upsert?: PromotionUpsertWithWhereUniqueWithoutPlanInput | PromotionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PromotionCreateManyPlanInputEnvelope
    set?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    disconnect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    delete?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    connect?: PromotionWhereUniqueInput | PromotionWhereUniqueInput[]
    update?: PromotionUpdateWithWhereUniqueWithoutPlanInput | PromotionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PromotionUpdateManyWithWhereWithoutPlanInput | PromotionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
  }

  export type PlanCreateNestedOneWithoutPromotionsInput = {
    create?: XOR<PlanCreateWithoutPromotionsInput, PlanUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutPromotionsInput
    connect?: PlanWhereUniqueInput
  }

  export type EnumPromotionScopeFieldUpdateOperationsInput = {
    set?: $Enums.PromotionScope
  }

  export type NullableEnumGameTypeFieldUpdateOperationsInput = {
    set?: $Enums.GameType | null
  }

  export type PlanUpdateOneWithoutPromotionsNestedInput = {
    create?: XOR<PlanCreateWithoutPromotionsInput, PlanUncheckedCreateWithoutPromotionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutPromotionsInput
    upsert?: PlanUpsertWithoutPromotionsInput
    disconnect?: PlanWhereInput | boolean
    delete?: PlanWhereInput | boolean
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutPromotionsInput, PlanUpdateWithoutPromotionsInput>, PlanUncheckedUpdateWithoutPromotionsInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutOrdersInput = {
    create?: XOR<PlanCreateWithoutOrdersInput, PlanUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PlanCreateOrConnectWithoutOrdersInput
    connect?: PlanWhereUniqueInput
  }

  export type GameServerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<GameServerCreateWithoutOrdersInput, GameServerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: GameServerCreateOrConnectWithoutOrdersInput
    connect?: GameServerWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type PlanUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<PlanCreateWithoutOrdersInput, PlanUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: PlanCreateOrConnectWithoutOrdersInput
    upsert?: PlanUpsertWithoutOrdersInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutOrdersInput, PlanUpdateWithoutOrdersInput>, PlanUncheckedUpdateWithoutOrdersInput>
  }

  export type GameServerUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<GameServerCreateWithoutOrdersInput, GameServerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: GameServerCreateOrConnectWithoutOrdersInput
    upsert?: GameServerUpsertWithoutOrdersInput
    disconnect?: GameServerWhereInput | boolean
    delete?: GameServerWhereInput | boolean
    connect?: GameServerWhereUniqueInput
    update?: XOR<XOR<GameServerUpdateToOneWithWhereWithoutOrdersInput, GameServerUpdateWithoutOrdersInput>, GameServerUncheckedUpdateWithoutOrdersInput>
  }

  export type EnumPaymentProviderFieldUpdateOperationsInput = {
    set?: $Enums.PaymentProvider
  }

  export type EnumPaymentEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentEventStatus
  }

  export type UserCreateNestedOneWithoutAssignedTicketsInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupportTicketsInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCommentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type EnumTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TicketPriority
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type UserUpdateOneWithoutAssignedTicketsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedTicketsInput
    upsert?: UserUpsertWithoutAssignedTicketsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedTicketsInput, UserUpdateWithoutAssignedTicketsInput>, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateOneRequiredWithoutSupportTicketsNestedInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    upsert?: UserUpsertWithoutSupportTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupportTicketsInput, UserUpdateWithoutSupportTicketsInput>, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type TicketCommentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type SupportTicketCreateNestedOneWithoutCommentsInput = {
    create?: XOR<SupportTicketCreateWithoutCommentsInput, SupportTicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutCommentsInput
    connect?: SupportTicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketCommentsInput = {
    create?: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type SupportTicketUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<SupportTicketCreateWithoutCommentsInput, SupportTicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutCommentsInput
    upsert?: SupportTicketUpsertWithoutCommentsInput
    connect?: SupportTicketWhereUniqueInput
    update?: XOR<XOR<SupportTicketUpdateToOneWithWhereWithoutCommentsInput, SupportTicketUpdateWithoutCommentsInput>, SupportTicketUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutTicketCommentsNestedInput = {
    create?: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentsInput
    upsert?: UserUpsertWithoutTicketCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketCommentsInput, UserUpdateWithoutTicketCommentsInput>, UserUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type KnowledgeBaseCategoryCreateNestedOneWithoutArticlesInput = {
    create?: XOR<KnowledgeBaseCategoryCreateWithoutArticlesInput, KnowledgeBaseCategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: KnowledgeBaseCategoryCreateOrConnectWithoutArticlesInput
    connect?: KnowledgeBaseCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutKnowledgeBaseArticlesInput = {
    create?: XOR<UserCreateWithoutKnowledgeBaseArticlesInput, UserUncheckedCreateWithoutKnowledgeBaseArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutKnowledgeBaseArticlesInput
    connect?: UserWhereUniqueInput
  }

  export type ArticleVersionCreateNestedManyWithoutArticleInput = {
    create?: XOR<ArticleVersionCreateWithoutArticleInput, ArticleVersionUncheckedCreateWithoutArticleInput> | ArticleVersionCreateWithoutArticleInput[] | ArticleVersionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleVersionCreateOrConnectWithoutArticleInput | ArticleVersionCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleVersionCreateManyArticleInputEnvelope
    connect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
  }

  export type ArticleVersionUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<ArticleVersionCreateWithoutArticleInput, ArticleVersionUncheckedCreateWithoutArticleInput> | ArticleVersionCreateWithoutArticleInput[] | ArticleVersionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleVersionCreateOrConnectWithoutArticleInput | ArticleVersionCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleVersionCreateManyArticleInputEnvelope
    connect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
  }

  export type KnowledgeBaseCategoryUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<KnowledgeBaseCategoryCreateWithoutArticlesInput, KnowledgeBaseCategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: KnowledgeBaseCategoryCreateOrConnectWithoutArticlesInput
    upsert?: KnowledgeBaseCategoryUpsertWithoutArticlesInput
    connect?: KnowledgeBaseCategoryWhereUniqueInput
    update?: XOR<XOR<KnowledgeBaseCategoryUpdateToOneWithWhereWithoutArticlesInput, KnowledgeBaseCategoryUpdateWithoutArticlesInput>, KnowledgeBaseCategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type UserUpdateOneRequiredWithoutKnowledgeBaseArticlesNestedInput = {
    create?: XOR<UserCreateWithoutKnowledgeBaseArticlesInput, UserUncheckedCreateWithoutKnowledgeBaseArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutKnowledgeBaseArticlesInput
    upsert?: UserUpsertWithoutKnowledgeBaseArticlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKnowledgeBaseArticlesInput, UserUpdateWithoutKnowledgeBaseArticlesInput>, UserUncheckedUpdateWithoutKnowledgeBaseArticlesInput>
  }

  export type ArticleVersionUpdateManyWithoutArticleNestedInput = {
    create?: XOR<ArticleVersionCreateWithoutArticleInput, ArticleVersionUncheckedCreateWithoutArticleInput> | ArticleVersionCreateWithoutArticleInput[] | ArticleVersionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleVersionCreateOrConnectWithoutArticleInput | ArticleVersionCreateOrConnectWithoutArticleInput[]
    upsert?: ArticleVersionUpsertWithWhereUniqueWithoutArticleInput | ArticleVersionUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleVersionCreateManyArticleInputEnvelope
    set?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    disconnect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    delete?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    connect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    update?: ArticleVersionUpdateWithWhereUniqueWithoutArticleInput | ArticleVersionUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: ArticleVersionUpdateManyWithWhereWithoutArticleInput | ArticleVersionUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleVersionScalarWhereInput | ArticleVersionScalarWhereInput[]
  }

  export type ArticleVersionUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<ArticleVersionCreateWithoutArticleInput, ArticleVersionUncheckedCreateWithoutArticleInput> | ArticleVersionCreateWithoutArticleInput[] | ArticleVersionUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleVersionCreateOrConnectWithoutArticleInput | ArticleVersionCreateOrConnectWithoutArticleInput[]
    upsert?: ArticleVersionUpsertWithWhereUniqueWithoutArticleInput | ArticleVersionUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleVersionCreateManyArticleInputEnvelope
    set?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    disconnect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    delete?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    connect?: ArticleVersionWhereUniqueInput | ArticleVersionWhereUniqueInput[]
    update?: ArticleVersionUpdateWithWhereUniqueWithoutArticleInput | ArticleVersionUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: ArticleVersionUpdateManyWithWhereWithoutArticleInput | ArticleVersionUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleVersionScalarWhereInput | ArticleVersionScalarWhereInput[]
  }

  export type KnowledgeBaseCategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<KnowledgeBaseCategoryCreateWithoutChildrenInput, KnowledgeBaseCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: KnowledgeBaseCategoryCreateOrConnectWithoutChildrenInput
    connect?: KnowledgeBaseCategoryWhereUniqueInput
  }

  export type KnowledgeBaseCategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<KnowledgeBaseCategoryCreateWithoutParentInput, KnowledgeBaseCategoryUncheckedCreateWithoutParentInput> | KnowledgeBaseCategoryCreateWithoutParentInput[] | KnowledgeBaseCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: KnowledgeBaseCategoryCreateOrConnectWithoutParentInput | KnowledgeBaseCategoryCreateOrConnectWithoutParentInput[]
    createMany?: KnowledgeBaseCategoryCreateManyParentInputEnvelope
    connect?: KnowledgeBaseCategoryWhereUniqueInput | KnowledgeBaseCategoryWhereUniqueInput[]
  }

  export type KnowledgeBaseArticleCreateNestedManyWithoutCategoryInput = {
    create?: XOR<KnowledgeBaseArticleCreateWithoutCategoryInput, KnowledgeBaseArticleUncheckedCreateWithoutCategoryInput> | KnowledgeBaseArticleCreateWithoutCategoryInput[] | KnowledgeBaseArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KnowledgeBaseArticleCreateOrConnectWithoutCategoryInput | KnowledgeBaseArticleCreateOrConnectWithoutCategoryInput[]
    createMany?: KnowledgeBaseArticleCreateManyCategoryInputEnvelope
    connect?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
  }

  export type KnowledgeBaseCategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<KnowledgeBaseCategoryCreateWithoutParentInput, KnowledgeBaseCategoryUncheckedCreateWithoutParentInput> | KnowledgeBaseCategoryCreateWithoutParentInput[] | KnowledgeBaseCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: KnowledgeBaseCategoryCreateOrConnectWithoutParentInput | KnowledgeBaseCategoryCreateOrConnectWithoutParentInput[]
    createMany?: KnowledgeBaseCategoryCreateManyParentInputEnvelope
    connect?: KnowledgeBaseCategoryWhereUniqueInput | KnowledgeBaseCategoryWhereUniqueInput[]
  }

  export type KnowledgeBaseArticleUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<KnowledgeBaseArticleCreateWithoutCategoryInput, KnowledgeBaseArticleUncheckedCreateWithoutCategoryInput> | KnowledgeBaseArticleCreateWithoutCategoryInput[] | KnowledgeBaseArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KnowledgeBaseArticleCreateOrConnectWithoutCategoryInput | KnowledgeBaseArticleCreateOrConnectWithoutCategoryInput[]
    createMany?: KnowledgeBaseArticleCreateManyCategoryInputEnvelope
    connect?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
  }

  export type KnowledgeBaseCategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<KnowledgeBaseCategoryCreateWithoutChildrenInput, KnowledgeBaseCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: KnowledgeBaseCategoryCreateOrConnectWithoutChildrenInput
    upsert?: KnowledgeBaseCategoryUpsertWithoutChildrenInput
    disconnect?: KnowledgeBaseCategoryWhereInput | boolean
    delete?: KnowledgeBaseCategoryWhereInput | boolean
    connect?: KnowledgeBaseCategoryWhereUniqueInput
    update?: XOR<XOR<KnowledgeBaseCategoryUpdateToOneWithWhereWithoutChildrenInput, KnowledgeBaseCategoryUpdateWithoutChildrenInput>, KnowledgeBaseCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type KnowledgeBaseCategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<KnowledgeBaseCategoryCreateWithoutParentInput, KnowledgeBaseCategoryUncheckedCreateWithoutParentInput> | KnowledgeBaseCategoryCreateWithoutParentInput[] | KnowledgeBaseCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: KnowledgeBaseCategoryCreateOrConnectWithoutParentInput | KnowledgeBaseCategoryCreateOrConnectWithoutParentInput[]
    upsert?: KnowledgeBaseCategoryUpsertWithWhereUniqueWithoutParentInput | KnowledgeBaseCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: KnowledgeBaseCategoryCreateManyParentInputEnvelope
    set?: KnowledgeBaseCategoryWhereUniqueInput | KnowledgeBaseCategoryWhereUniqueInput[]
    disconnect?: KnowledgeBaseCategoryWhereUniqueInput | KnowledgeBaseCategoryWhereUniqueInput[]
    delete?: KnowledgeBaseCategoryWhereUniqueInput | KnowledgeBaseCategoryWhereUniqueInput[]
    connect?: KnowledgeBaseCategoryWhereUniqueInput | KnowledgeBaseCategoryWhereUniqueInput[]
    update?: KnowledgeBaseCategoryUpdateWithWhereUniqueWithoutParentInput | KnowledgeBaseCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: KnowledgeBaseCategoryUpdateManyWithWhereWithoutParentInput | KnowledgeBaseCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: KnowledgeBaseCategoryScalarWhereInput | KnowledgeBaseCategoryScalarWhereInput[]
  }

  export type KnowledgeBaseArticleUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<KnowledgeBaseArticleCreateWithoutCategoryInput, KnowledgeBaseArticleUncheckedCreateWithoutCategoryInput> | KnowledgeBaseArticleCreateWithoutCategoryInput[] | KnowledgeBaseArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KnowledgeBaseArticleCreateOrConnectWithoutCategoryInput | KnowledgeBaseArticleCreateOrConnectWithoutCategoryInput[]
    upsert?: KnowledgeBaseArticleUpsertWithWhereUniqueWithoutCategoryInput | KnowledgeBaseArticleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: KnowledgeBaseArticleCreateManyCategoryInputEnvelope
    set?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    disconnect?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    delete?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    connect?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    update?: KnowledgeBaseArticleUpdateWithWhereUniqueWithoutCategoryInput | KnowledgeBaseArticleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: KnowledgeBaseArticleUpdateManyWithWhereWithoutCategoryInput | KnowledgeBaseArticleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: KnowledgeBaseArticleScalarWhereInput | KnowledgeBaseArticleScalarWhereInput[]
  }

  export type KnowledgeBaseCategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<KnowledgeBaseCategoryCreateWithoutParentInput, KnowledgeBaseCategoryUncheckedCreateWithoutParentInput> | KnowledgeBaseCategoryCreateWithoutParentInput[] | KnowledgeBaseCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: KnowledgeBaseCategoryCreateOrConnectWithoutParentInput | KnowledgeBaseCategoryCreateOrConnectWithoutParentInput[]
    upsert?: KnowledgeBaseCategoryUpsertWithWhereUniqueWithoutParentInput | KnowledgeBaseCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: KnowledgeBaseCategoryCreateManyParentInputEnvelope
    set?: KnowledgeBaseCategoryWhereUniqueInput | KnowledgeBaseCategoryWhereUniqueInput[]
    disconnect?: KnowledgeBaseCategoryWhereUniqueInput | KnowledgeBaseCategoryWhereUniqueInput[]
    delete?: KnowledgeBaseCategoryWhereUniqueInput | KnowledgeBaseCategoryWhereUniqueInput[]
    connect?: KnowledgeBaseCategoryWhereUniqueInput | KnowledgeBaseCategoryWhereUniqueInput[]
    update?: KnowledgeBaseCategoryUpdateWithWhereUniqueWithoutParentInput | KnowledgeBaseCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: KnowledgeBaseCategoryUpdateManyWithWhereWithoutParentInput | KnowledgeBaseCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: KnowledgeBaseCategoryScalarWhereInput | KnowledgeBaseCategoryScalarWhereInput[]
  }

  export type KnowledgeBaseArticleUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<KnowledgeBaseArticleCreateWithoutCategoryInput, KnowledgeBaseArticleUncheckedCreateWithoutCategoryInput> | KnowledgeBaseArticleCreateWithoutCategoryInput[] | KnowledgeBaseArticleUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KnowledgeBaseArticleCreateOrConnectWithoutCategoryInput | KnowledgeBaseArticleCreateOrConnectWithoutCategoryInput[]
    upsert?: KnowledgeBaseArticleUpsertWithWhereUniqueWithoutCategoryInput | KnowledgeBaseArticleUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: KnowledgeBaseArticleCreateManyCategoryInputEnvelope
    set?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    disconnect?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    delete?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    connect?: KnowledgeBaseArticleWhereUniqueInput | KnowledgeBaseArticleWhereUniqueInput[]
    update?: KnowledgeBaseArticleUpdateWithWhereUniqueWithoutCategoryInput | KnowledgeBaseArticleUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: KnowledgeBaseArticleUpdateManyWithWhereWithoutCategoryInput | KnowledgeBaseArticleUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: KnowledgeBaseArticleScalarWhereInput | KnowledgeBaseArticleScalarWhereInput[]
  }

  export type KnowledgeBaseArticleCreateNestedOneWithoutVersionsInput = {
    create?: XOR<KnowledgeBaseArticleCreateWithoutVersionsInput, KnowledgeBaseArticleUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: KnowledgeBaseArticleCreateOrConnectWithoutVersionsInput
    connect?: KnowledgeBaseArticleWhereUniqueInput
  }

  export type KnowledgeBaseArticleUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<KnowledgeBaseArticleCreateWithoutVersionsInput, KnowledgeBaseArticleUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: KnowledgeBaseArticleCreateOrConnectWithoutVersionsInput
    upsert?: KnowledgeBaseArticleUpsertWithoutVersionsInput
    connect?: KnowledgeBaseArticleWhereUniqueInput
    update?: XOR<XOR<KnowledgeBaseArticleUpdateToOneWithWhereWithoutVersionsInput, KnowledgeBaseArticleUpdateWithoutVersionsInput>, KnowledgeBaseArticleUncheckedUpdateWithoutVersionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumLicenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseStatus[]
    notIn?: $Enums.LicenseStatus[]
    not?: NestedEnumLicenseStatusFilter<$PrismaModel> | $Enums.LicenseStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumLicenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LicenseStatus | EnumLicenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LicenseStatus[]
    notIn?: $Enums.LicenseStatus[]
    not?: NestedEnumLicenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LicenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLicenseStatusFilter<$PrismaModel>
    _max?: NestedEnumLicenseStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumDiskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiskType | EnumDiskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiskType[]
    notIn?: $Enums.DiskType[]
    not?: NestedEnumDiskTypeFilter<$PrismaModel> | $Enums.DiskType
  }

  export type NestedEnumNodeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeStatus | EnumNodeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NodeStatus[]
    notIn?: $Enums.NodeStatus[]
    not?: NestedEnumNodeStatusFilter<$PrismaModel> | $Enums.NodeStatus
  }

  export type NestedEnumDiskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiskType | EnumDiskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiskType[]
    notIn?: $Enums.DiskType[]
    not?: NestedEnumDiskTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiskTypeFilter<$PrismaModel>
    _max?: NestedEnumDiskTypeFilter<$PrismaModel>
  }

  export type NestedEnumNodeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeStatus | EnumNodeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NodeStatus[]
    notIn?: $Enums.NodeStatus[]
    not?: NestedEnumNodeStatusWithAggregatesFilter<$PrismaModel> | $Enums.NodeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNodeStatusFilter<$PrismaModel>
    _max?: NestedEnumNodeStatusFilter<$PrismaModel>
  }

  export type NestedEnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[]
    notIn?: $Enums.TaskType[]
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[]
    notIn?: $Enums.TaskStatus[]
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[]
    notIn?: $Enums.TaskType[]
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[]
    notIn?: $Enums.TaskStatus[]
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumProtocolFilter<$PrismaModel = never> = {
    equals?: $Enums.Protocol | EnumProtocolFieldRefInput<$PrismaModel>
    in?: $Enums.Protocol[]
    notIn?: $Enums.Protocol[]
    not?: NestedEnumProtocolFilter<$PrismaModel> | $Enums.Protocol
  }

  export type NestedEnumPortTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PortType | EnumPortTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PortType[]
    notIn?: $Enums.PortType[]
    not?: NestedEnumPortTypeFilter<$PrismaModel> | $Enums.PortType
  }

  export type NestedEnumProtocolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Protocol | EnumProtocolFieldRefInput<$PrismaModel>
    in?: $Enums.Protocol[]
    notIn?: $Enums.Protocol[]
    not?: NestedEnumProtocolWithAggregatesFilter<$PrismaModel> | $Enums.Protocol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProtocolFilter<$PrismaModel>
    _max?: NestedEnumProtocolFilter<$PrismaModel>
  }

  export type NestedEnumPortTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PortType | EnumPortTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PortType[]
    notIn?: $Enums.PortType[]
    not?: NestedEnumPortTypeWithAggregatesFilter<$PrismaModel> | $Enums.PortType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPortTypeFilter<$PrismaModel>
    _max?: NestedEnumPortTypeFilter<$PrismaModel>
  }

  export type NestedEnumGameTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameType[]
    notIn?: $Enums.GameType[]
    not?: NestedEnumGameTypeFilter<$PrismaModel> | $Enums.GameType
  }

  export type NestedEnumServerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServerStatus | EnumServerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServerStatus[]
    notIn?: $Enums.ServerStatus[]
    not?: NestedEnumServerStatusFilter<$PrismaModel> | $Enums.ServerStatus
  }

  export type NestedEnumGameTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GameType[]
    notIn?: $Enums.GameType[]
    not?: NestedEnumGameTypeWithAggregatesFilter<$PrismaModel> | $Enums.GameType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameTypeFilter<$PrismaModel>
    _max?: NestedEnumGameTypeFilter<$PrismaModel>
  }

  export type NestedEnumServerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServerStatus | EnumServerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServerStatus[]
    notIn?: $Enums.ServerStatus[]
    not?: NestedEnumServerStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServerStatusFilter<$PrismaModel>
    _max?: NestedEnumServerStatusFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumBackupLocationFilter<$PrismaModel = never> = {
    equals?: $Enums.BackupLocation | EnumBackupLocationFieldRefInput<$PrismaModel>
    in?: $Enums.BackupLocation[]
    notIn?: $Enums.BackupLocation[]
    not?: NestedEnumBackupLocationFilter<$PrismaModel> | $Enums.BackupLocation
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumBackupLocationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BackupLocation | EnumBackupLocationFieldRefInput<$PrismaModel>
    in?: $Enums.BackupLocation[]
    notIn?: $Enums.BackupLocation[]
    not?: NestedEnumBackupLocationWithAggregatesFilter<$PrismaModel> | $Enums.BackupLocation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBackupLocationFilter<$PrismaModel>
    _max?: NestedEnumBackupLocationFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAlertSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[]
    notIn?: $Enums.AlertSeverity[]
    not?: NestedEnumAlertSeverityFilter<$PrismaModel> | $Enums.AlertSeverity
  }

  export type NestedEnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[]
    notIn?: $Enums.ResourceType[]
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertSeverity | EnumAlertSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.AlertSeverity[]
    notIn?: $Enums.AlertSeverity[]
    not?: NestedEnumAlertSeverityWithAggregatesFilter<$PrismaModel> | $Enums.AlertSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertSeverityFilter<$PrismaModel>
    _max?: NestedEnumAlertSeverityFilter<$PrismaModel>
  }

  export type NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[]
    notIn?: $Enums.ResourceType[]
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type NestedEnumIncidentSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[]
    notIn?: $Enums.IncidentSeverity[]
    not?: NestedEnumIncidentSeverityFilter<$PrismaModel> | $Enums.IncidentSeverity
  }

  export type NestedEnumIncidentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[]
    notIn?: $Enums.IncidentStatus[]
    not?: NestedEnumIncidentStatusFilter<$PrismaModel> | $Enums.IncidentStatus
  }

  export type NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentSeverity | EnumIncidentSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentSeverity[]
    notIn?: $Enums.IncidentSeverity[]
    not?: NestedEnumIncidentSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IncidentSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentSeverityFilter<$PrismaModel>
    _max?: NestedEnumIncidentSeverityFilter<$PrismaModel>
  }

  export type NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncidentStatus | EnumIncidentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IncidentStatus[]
    notIn?: $Enums.IncidentStatus[]
    not?: NestedEnumIncidentStatusWithAggregatesFilter<$PrismaModel> | $Enums.IncidentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncidentStatusFilter<$PrismaModel>
    _max?: NestedEnumIncidentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPlanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanStatus | EnumPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlanStatus[]
    notIn?: $Enums.PlanStatus[]
    not?: NestedEnumPlanStatusFilter<$PrismaModel> | $Enums.PlanStatus
  }

  export type NestedEnumPlanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanStatus | EnumPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlanStatus[]
    notIn?: $Enums.PlanStatus[]
    not?: NestedEnumPlanStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanStatusFilter<$PrismaModel>
    _max?: NestedEnumPlanStatusFilter<$PrismaModel>
  }

  export type NestedEnumPromotionScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromotionScope | EnumPromotionScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PromotionScope[]
    notIn?: $Enums.PromotionScope[]
    not?: NestedEnumPromotionScopeFilter<$PrismaModel> | $Enums.PromotionScope
  }

  export type NestedEnumGameTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.GameType[] | null
    notIn?: $Enums.GameType[] | null
    not?: NestedEnumGameTypeNullableFilter<$PrismaModel> | $Enums.GameType | null
  }

  export type NestedEnumPromotionScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromotionScope | EnumPromotionScopeFieldRefInput<$PrismaModel>
    in?: $Enums.PromotionScope[]
    notIn?: $Enums.PromotionScope[]
    not?: NestedEnumPromotionScopeWithAggregatesFilter<$PrismaModel> | $Enums.PromotionScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromotionScopeFilter<$PrismaModel>
    _max?: NestedEnumPromotionScopeFilter<$PrismaModel>
  }

  export type NestedEnumGameTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameType | EnumGameTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.GameType[] | null
    notIn?: $Enums.GameType[] | null
    not?: NestedEnumGameTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.GameType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGameTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumGameTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[]
    notIn?: $Enums.PaymentProvider[]
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type NestedEnumPaymentEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentEventStatus | EnumPaymentEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentEventStatus[]
    notIn?: $Enums.PaymentEventStatus[]
    not?: NestedEnumPaymentEventStatusFilter<$PrismaModel> | $Enums.PaymentEventStatus
  }

  export type NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[]
    notIn?: $Enums.PaymentProvider[]
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type NestedEnumPaymentEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentEventStatus | EnumPaymentEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentEventStatus[]
    notIn?: $Enums.PaymentEventStatus[]
    not?: NestedEnumPaymentEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentEventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentEventStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentEventStatusFilter<$PrismaModel>
  }

  export type NestedEnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[]
    notIn?: $Enums.TicketPriority[]
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[]
    notIn?: $Enums.TicketStatus[]
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[]
    notIn?: $Enums.TicketPriority[]
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[]
    notIn?: $Enums.TicketStatus[]
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentCreateNestedManyWithoutAssignedToInput
    orders?: OrderCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerUncheckedCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertUncheckedCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentUncheckedCreateNestedManyWithoutAssignedToInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ResourceQuotaCreateWithoutTenantInput = {
    id?: string
    maxServers: number
    maxRam: number
    maxDisk: number
    maxCpu: number
    currentUsage: JsonNullValueInput | InputJsonValue
    enforced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResourceQuotasInput
  }

  export type ResourceQuotaUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    maxServers: number
    maxRam: number
    maxDisk: number
    maxCpu: number
    currentUsage: JsonNullValueInput | InputJsonValue
    enforced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceQuotaCreateOrConnectWithoutTenantInput = {
    where: ResourceQuotaWhereUniqueInput
    create: XOR<ResourceQuotaCreateWithoutTenantInput, ResourceQuotaUncheckedCreateWithoutTenantInput>
  }

  export type ResourceQuotaCreateManyTenantInputEnvelope = {
    data: ResourceQuotaCreateManyTenantInput | ResourceQuotaCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorMethod?: StringNullableFilter<"User"> | string | null
    twoFactorBackupCodes?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    balance?: FloatFilter<"User"> | number
    tenantId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ResourceQuotaUpsertWithWhereUniqueWithoutTenantInput = {
    where: ResourceQuotaWhereUniqueInput
    update: XOR<ResourceQuotaUpdateWithoutTenantInput, ResourceQuotaUncheckedUpdateWithoutTenantInput>
    create: XOR<ResourceQuotaCreateWithoutTenantInput, ResourceQuotaUncheckedCreateWithoutTenantInput>
  }

  export type ResourceQuotaUpdateWithWhereUniqueWithoutTenantInput = {
    where: ResourceQuotaWhereUniqueInput
    data: XOR<ResourceQuotaUpdateWithoutTenantInput, ResourceQuotaUncheckedUpdateWithoutTenantInput>
  }

  export type ResourceQuotaUpdateManyWithWhereWithoutTenantInput = {
    where: ResourceQuotaScalarWhereInput
    data: XOR<ResourceQuotaUpdateManyMutationInput, ResourceQuotaUncheckedUpdateManyWithoutTenantInput>
  }

  export type ResourceQuotaScalarWhereInput = {
    AND?: ResourceQuotaScalarWhereInput | ResourceQuotaScalarWhereInput[]
    OR?: ResourceQuotaScalarWhereInput[]
    NOT?: ResourceQuotaScalarWhereInput | ResourceQuotaScalarWhereInput[]
    id?: StringFilter<"ResourceQuota"> | string
    userId?: StringFilter<"ResourceQuota"> | string
    tenantId?: StringNullableFilter<"ResourceQuota"> | string | null
    maxServers?: IntFilter<"ResourceQuota"> | number
    maxRam?: IntFilter<"ResourceQuota"> | number
    maxDisk?: IntFilter<"ResourceQuota"> | number
    maxCpu?: IntFilter<"ResourceQuota"> | number
    currentUsage?: JsonFilter<"ResourceQuota">
    enforced?: BoolFilter<"ResourceQuota"> | boolean
    createdAt?: DateTimeFilter<"ResourceQuota"> | Date | string
    updatedAt?: DateTimeFilter<"ResourceQuota"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    domain: string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    domain: string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type GameServerCreateWithoutOwnerInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutServersInput
    plan?: PlanCreateNestedOneWithoutServersInput
    cluster?: GameClusterCreateNestedOneWithoutServersInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutServerInput
    subdomains?: SubdomainCreateNestedManyWithoutServerInput
    backups?: BackupCreateNestedManyWithoutServerInput
    metrics?: MetricCreateNestedManyWithoutServerInput
    alerts?: AlertCreateNestedManyWithoutServerInput
    orders?: OrderCreateNestedManyWithoutServerInput
  }

  export type GameServerUncheckedCreateWithoutOwnerInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutServerInput
    subdomains?: SubdomainUncheckedCreateNestedManyWithoutServerInput
    backups?: BackupUncheckedCreateNestedManyWithoutServerInput
    metrics?: MetricUncheckedCreateNestedManyWithoutServerInput
    alerts?: AlertUncheckedCreateNestedManyWithoutServerInput
    orders?: OrderUncheckedCreateNestedManyWithoutServerInput
  }

  export type GameServerCreateOrConnectWithoutOwnerInput = {
    where: GameServerWhereUniqueInput
    create: XOR<GameServerCreateWithoutOwnerInput, GameServerUncheckedCreateWithoutOwnerInput>
  }

  export type GameServerCreateManyOwnerInputEnvelope = {
    data: GameServerCreateManyOwnerInput | GameServerCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resourceId: string
    ipAddress: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resourceId: string
    ipAddress: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutResolvedByInput = {
    id?: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved?: boolean
    resolvedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    node?: NodeCreateNestedOneWithoutAlertsInput
    server?: GameServerCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutResolvedByInput = {
    id?: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved?: boolean
    resolvedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeId?: string | null
    serverUuid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertCreateOrConnectWithoutResolvedByInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutResolvedByInput, AlertUncheckedCreateWithoutResolvedByInput>
  }

  export type AlertCreateManyResolvedByInputEnvelope = {
    data: AlertCreateManyResolvedByInput | AlertCreateManyResolvedByInput[]
    skipDuplicates?: boolean
  }

  export type ResourceQuotaCreateWithoutUserInput = {
    id?: string
    maxServers: number
    maxRam: number
    maxDisk: number
    maxCpu: number
    currentUsage: JsonNullValueInput | InputJsonValue
    enforced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutResourceQuotasInput
  }

  export type ResourceQuotaUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId?: string | null
    maxServers: number
    maxRam: number
    maxDisk: number
    maxCpu: number
    currentUsage: JsonNullValueInput | InputJsonValue
    enforced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceQuotaCreateOrConnectWithoutUserInput = {
    where: ResourceQuotaWhereUniqueInput
    create: XOR<ResourceQuotaCreateWithoutUserInput, ResourceQuotaUncheckedCreateWithoutUserInput>
  }

  export type ResourceQuotaCreateManyUserInputEnvelope = {
    data: ResourceQuotaCreateManyUserInput | ResourceQuotaCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutUserInput = {
    id?: string
    keyHash: string
    name: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutUserInput = {
    id?: string
    keyHash: string
    name: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyCreateManyUserInputEnvelope = {
    data: ApiKeyCreateManyUserInput | ApiKeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IncidentCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    resolvedAt?: Date | string | null
    rootCause?: string | null
    resolution?: string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentUncheckedCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description: string
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    resolvedAt?: Date | string | null
    rootCause?: string | null
    resolution?: string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateOrConnectWithoutAssignedToInput = {
    where: IncidentWhereUniqueInput
    create: XOR<IncidentCreateWithoutAssignedToInput, IncidentUncheckedCreateWithoutAssignedToInput>
  }

  export type IncidentCreateManyAssignedToInputEnvelope = {
    data: IncidentCreateManyAssignedToInput | IncidentCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    status?: $Enums.OrderStatus
    priceSnapshot: JsonNullValueInput | InputJsonValue
    totalAmount: number
    currency?: string
    paymentMethod?: string | null
    paymentId?: string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutOrdersInput
    server?: GameServerCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    planId: string
    status?: $Enums.OrderStatus
    priceSnapshot: JsonNullValueInput | InputJsonValue
    totalAmount: number
    currency?: string
    paymentMethod?: string | null
    paymentId?: string | null
    paidAt?: Date | string | null
    serverId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutUserInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    priority?: $Enums.TicketPriority
    category?: string | null
    status?: $Enums.TicketStatus
    assignedAt?: Date | string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    firstResponseAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutUserInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    priority?: $Enums.TicketPriority
    category?: string | null
    status?: $Enums.TicketStatus
    assignedToId?: string | null
    assignedAt?: Date | string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    firstResponseAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketCreateManyUserInputEnvelope = {
    data: SupportTicketCreateManyUserInput | SupportTicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketCommentCreateWithoutAuthorInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: SupportTicketCreateNestedOneWithoutCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    ticketId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentCreateOrConnectWithoutAuthorInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput>
  }

  export type TicketCommentCreateManyAuthorInputEnvelope = {
    data: TicketCommentCreateManyAuthorInput | TicketCommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutAssignedToInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    priority?: $Enums.TicketPriority
    category?: string | null
    status?: $Enums.TicketStatus
    assignedAt?: Date | string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    firstResponseAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSupportTicketsInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutAssignedToInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    priority?: $Enums.TicketPriority
    category?: string | null
    status?: $Enums.TicketStatus
    assignedAt?: Date | string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    firstResponseAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutAssignedToInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput>
  }

  export type SupportTicketCreateManyAssignedToInputEnvelope = {
    data: SupportTicketCreateManyAssignedToInput | SupportTicketCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeBaseArticleCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    published?: boolean
    views?: number
    helpful?: number
    notHelpful?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    category: KnowledgeBaseCategoryCreateNestedOneWithoutArticlesInput
    versions?: ArticleVersionCreateNestedManyWithoutArticleInput
  }

  export type KnowledgeBaseArticleUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    categoryId: string
    tags?: JsonNullValueInput | InputJsonValue
    published?: boolean
    views?: number
    helpful?: number
    notHelpful?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    versions?: ArticleVersionUncheckedCreateNestedManyWithoutArticleInput
  }

  export type KnowledgeBaseArticleCreateOrConnectWithoutAuthorInput = {
    where: KnowledgeBaseArticleWhereUniqueInput
    create: XOR<KnowledgeBaseArticleCreateWithoutAuthorInput, KnowledgeBaseArticleUncheckedCreateWithoutAuthorInput>
  }

  export type KnowledgeBaseArticleCreateManyAuthorInputEnvelope = {
    data: KnowledgeBaseArticleCreateManyAuthorInput | KnowledgeBaseArticleCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resourceQuotas?: ResourceQuotaUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type GameServerUpsertWithWhereUniqueWithoutOwnerInput = {
    where: GameServerWhereUniqueInput
    update: XOR<GameServerUpdateWithoutOwnerInput, GameServerUncheckedUpdateWithoutOwnerInput>
    create: XOR<GameServerCreateWithoutOwnerInput, GameServerUncheckedCreateWithoutOwnerInput>
  }

  export type GameServerUpdateWithWhereUniqueWithoutOwnerInput = {
    where: GameServerWhereUniqueInput
    data: XOR<GameServerUpdateWithoutOwnerInput, GameServerUncheckedUpdateWithoutOwnerInput>
  }

  export type GameServerUpdateManyWithWhereWithoutOwnerInput = {
    where: GameServerScalarWhereInput
    data: XOR<GameServerUpdateManyMutationInput, GameServerUncheckedUpdateManyWithoutOwnerInput>
  }

  export type GameServerScalarWhereInput = {
    AND?: GameServerScalarWhereInput | GameServerScalarWhereInput[]
    OR?: GameServerScalarWhereInput[]
    NOT?: GameServerScalarWhereInput | GameServerScalarWhereInput[]
    id?: StringFilter<"GameServer"> | string
    uuid?: StringFilter<"GameServer"> | string
    gameType?: EnumGameTypeFilter<"GameServer"> | $Enums.GameType
    status?: EnumServerStatusFilter<"GameServer"> | $Enums.ServerStatus
    nodeId?: StringFilter<"GameServer"> | string
    ownerId?: StringFilter<"GameServer"> | string
    planId?: StringNullableFilter<"GameServer"> | string | null
    startupPriority?: IntFilter<"GameServer"> | number
    resources?: JsonFilter<"GameServer">
    envVars?: JsonFilter<"GameServer">
    clusterId?: StringNullableFilter<"GameServer"> | string | null
    createdAt?: DateTimeFilter<"GameServer"> | Date | string
    updatedAt?: DateTimeFilter<"GameServer"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resourceId?: StringFilter<"AuditLog"> | string
    ipAddress?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AlertUpsertWithWhereUniqueWithoutResolvedByInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutResolvedByInput, AlertUncheckedUpdateWithoutResolvedByInput>
    create: XOR<AlertCreateWithoutResolvedByInput, AlertUncheckedCreateWithoutResolvedByInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutResolvedByInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutResolvedByInput, AlertUncheckedUpdateWithoutResolvedByInput>
  }

  export type AlertUpdateManyWithWhereWithoutResolvedByInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutResolvedByInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    severity?: EnumAlertSeverityFilter<"Alert"> | $Enums.AlertSeverity
    type?: StringFilter<"Alert"> | string
    message?: StringFilter<"Alert"> | string
    resourceId?: StringFilter<"Alert"> | string
    resourceType?: EnumResourceTypeFilter<"Alert"> | $Enums.ResourceType
    resolved?: BoolFilter<"Alert"> | boolean
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    resolvedById?: StringNullableFilter<"Alert"> | string | null
    metadata?: JsonNullableFilter<"Alert">
    nodeId?: StringNullableFilter<"Alert"> | string | null
    serverUuid?: StringNullableFilter<"Alert"> | string | null
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
  }

  export type ResourceQuotaUpsertWithWhereUniqueWithoutUserInput = {
    where: ResourceQuotaWhereUniqueInput
    update: XOR<ResourceQuotaUpdateWithoutUserInput, ResourceQuotaUncheckedUpdateWithoutUserInput>
    create: XOR<ResourceQuotaCreateWithoutUserInput, ResourceQuotaUncheckedCreateWithoutUserInput>
  }

  export type ResourceQuotaUpdateWithWhereUniqueWithoutUserInput = {
    where: ResourceQuotaWhereUniqueInput
    data: XOR<ResourceQuotaUpdateWithoutUserInput, ResourceQuotaUncheckedUpdateWithoutUserInput>
  }

  export type ResourceQuotaUpdateManyWithWhereWithoutUserInput = {
    where: ResourceQuotaScalarWhereInput
    data: XOR<ResourceQuotaUpdateManyMutationInput, ResourceQuotaUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    permissions?: JsonNullableFilter<"ApiKey">
    rateLimit?: IntFilter<"ApiKey"> | number
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type IncidentUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: IncidentWhereUniqueInput
    update: XOR<IncidentUpdateWithoutAssignedToInput, IncidentUncheckedUpdateWithoutAssignedToInput>
    create: XOR<IncidentCreateWithoutAssignedToInput, IncidentUncheckedCreateWithoutAssignedToInput>
  }

  export type IncidentUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: IncidentWhereUniqueInput
    data: XOR<IncidentUpdateWithoutAssignedToInput, IncidentUncheckedUpdateWithoutAssignedToInput>
  }

  export type IncidentUpdateManyWithWhereWithoutAssignedToInput = {
    where: IncidentScalarWhereInput
    data: XOR<IncidentUpdateManyMutationInput, IncidentUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type IncidentScalarWhereInput = {
    AND?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    OR?: IncidentScalarWhereInput[]
    NOT?: IncidentScalarWhereInput | IncidentScalarWhereInput[]
    id?: StringFilter<"Incident"> | string
    title?: StringFilter<"Incident"> | string
    description?: StringFilter<"Incident"> | string
    severity?: EnumIncidentSeverityFilter<"Incident"> | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFilter<"Incident"> | $Enums.IncidentStatus
    assignedToId?: StringNullableFilter<"Incident"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Incident"> | Date | string | null
    rootCause?: StringNullableFilter<"Incident"> | string | null
    resolution?: StringNullableFilter<"Incident"> | string | null
    affectedResources?: JsonNullableFilter<"Incident">
    createdAt?: DateTimeFilter<"Incident"> | Date | string
    updatedAt?: DateTimeFilter<"Incident"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    userId?: StringFilter<"Order"> | string
    planId?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    priceSnapshot?: JsonFilter<"Order">
    totalAmount?: IntFilter<"Order"> | number
    currency?: StringFilter<"Order"> | string
    paymentMethod?: StringNullableFilter<"Order"> | string | null
    paymentId?: StringNullableFilter<"Order"> | string | null
    paidAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    serverId?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutUserInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutUserInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: StringFilter<"SupportTicket"> | string
    ticketNumber?: StringFilter<"SupportTicket"> | string
    subject?: StringFilter<"SupportTicket"> | string
    description?: StringFilter<"SupportTicket"> | string
    priority?: EnumTicketPriorityFilter<"SupportTicket"> | $Enums.TicketPriority
    category?: StringNullableFilter<"SupportTicket"> | string | null
    status?: EnumTicketStatusFilter<"SupportTicket"> | $Enums.TicketStatus
    assignedToId?: StringNullableFilter<"SupportTicket"> | string | null
    assignedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    slaResponseDeadline?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    slaResolveDeadline?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    firstResponseAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    userId?: StringFilter<"SupportTicket"> | string
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    closedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutAuthorInput, TicketCommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<TicketCommentCreateWithoutAuthorInput, TicketCommentUncheckedCreateWithoutAuthorInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutAuthorInput, TicketCommentUncheckedUpdateWithoutAuthorInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutAuthorInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type TicketCommentScalarWhereInput = {
    AND?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    OR?: TicketCommentScalarWhereInput[]
    NOT?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    id?: StringFilter<"TicketComment"> | string
    ticketId?: StringFilter<"TicketComment"> | string
    authorId?: StringFilter<"TicketComment"> | string
    message?: StringFilter<"TicketComment"> | string
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeFilter<"TicketComment"> | Date | string
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutAssignedToInput, SupportTicketUncheckedUpdateWithoutAssignedToInput>
    create: XOR<SupportTicketCreateWithoutAssignedToInput, SupportTicketUncheckedCreateWithoutAssignedToInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutAssignedToInput, SupportTicketUncheckedUpdateWithoutAssignedToInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutAssignedToInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type KnowledgeBaseArticleUpsertWithWhereUniqueWithoutAuthorInput = {
    where: KnowledgeBaseArticleWhereUniqueInput
    update: XOR<KnowledgeBaseArticleUpdateWithoutAuthorInput, KnowledgeBaseArticleUncheckedUpdateWithoutAuthorInput>
    create: XOR<KnowledgeBaseArticleCreateWithoutAuthorInput, KnowledgeBaseArticleUncheckedCreateWithoutAuthorInput>
  }

  export type KnowledgeBaseArticleUpdateWithWhereUniqueWithoutAuthorInput = {
    where: KnowledgeBaseArticleWhereUniqueInput
    data: XOR<KnowledgeBaseArticleUpdateWithoutAuthorInput, KnowledgeBaseArticleUncheckedUpdateWithoutAuthorInput>
  }

  export type KnowledgeBaseArticleUpdateManyWithWhereWithoutAuthorInput = {
    where: KnowledgeBaseArticleScalarWhereInput
    data: XOR<KnowledgeBaseArticleUpdateManyMutationInput, KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorInput>
  }

  export type KnowledgeBaseArticleScalarWhereInput = {
    AND?: KnowledgeBaseArticleScalarWhereInput | KnowledgeBaseArticleScalarWhereInput[]
    OR?: KnowledgeBaseArticleScalarWhereInput[]
    NOT?: KnowledgeBaseArticleScalarWhereInput | KnowledgeBaseArticleScalarWhereInput[]
    id?: StringFilter<"KnowledgeBaseArticle"> | string
    title?: StringFilter<"KnowledgeBaseArticle"> | string
    slug?: StringFilter<"KnowledgeBaseArticle"> | string
    content?: StringFilter<"KnowledgeBaseArticle"> | string
    excerpt?: StringNullableFilter<"KnowledgeBaseArticle"> | string | null
    categoryId?: StringFilter<"KnowledgeBaseArticle"> | string
    authorId?: StringFilter<"KnowledgeBaseArticle"> | string
    tags?: JsonFilter<"KnowledgeBaseArticle">
    published?: BoolFilter<"KnowledgeBaseArticle"> | boolean
    views?: IntFilter<"KnowledgeBaseArticle"> | number
    helpful?: IntFilter<"KnowledgeBaseArticle"> | number
    notHelpful?: IntFilter<"KnowledgeBaseArticle"> | number
    createdAt?: DateTimeFilter<"KnowledgeBaseArticle"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBaseArticle"> | Date | string
    publishedAt?: DateTimeNullableFilter<"KnowledgeBaseArticle"> | Date | string | null
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    ownedServers?: GameServerCreateNestedManyWithoutOwnerInput
    resolvedAlerts?: AlertCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentCreateNestedManyWithoutAssignedToInput
    orders?: OrderCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerUncheckedCreateNestedManyWithoutOwnerInput
    resolvedAlerts?: AlertUncheckedCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentUncheckedCreateNestedManyWithoutAssignedToInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    ownedServers?: GameServerUpdateManyWithoutOwnerNestedInput
    resolvedAlerts?: AlertUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUncheckedUpdateManyWithoutOwnerNestedInput
    resolvedAlerts?: AlertUncheckedUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUncheckedUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type GameServerCreateWithoutNodeInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutOwnedServersInput
    plan?: PlanCreateNestedOneWithoutServersInput
    cluster?: GameClusterCreateNestedOneWithoutServersInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutServerInput
    subdomains?: SubdomainCreateNestedManyWithoutServerInput
    backups?: BackupCreateNestedManyWithoutServerInput
    metrics?: MetricCreateNestedManyWithoutServerInput
    alerts?: AlertCreateNestedManyWithoutServerInput
    orders?: OrderCreateNestedManyWithoutServerInput
  }

  export type GameServerUncheckedCreateWithoutNodeInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    ownerId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutServerInput
    subdomains?: SubdomainUncheckedCreateNestedManyWithoutServerInput
    backups?: BackupUncheckedCreateNestedManyWithoutServerInput
    metrics?: MetricUncheckedCreateNestedManyWithoutServerInput
    alerts?: AlertUncheckedCreateNestedManyWithoutServerInput
    orders?: OrderUncheckedCreateNestedManyWithoutServerInput
  }

  export type GameServerCreateOrConnectWithoutNodeInput = {
    where: GameServerWhereUniqueInput
    create: XOR<GameServerCreateWithoutNodeInput, GameServerUncheckedCreateWithoutNodeInput>
  }

  export type GameServerCreateManyNodeInputEnvelope = {
    data: GameServerCreateManyNodeInput | GameServerCreateManyNodeInput[]
    skipDuplicates?: boolean
  }

  export type NetworkAllocationCreateWithoutNodeInput = {
    id?: string
    port: number
    protocol: $Enums.Protocol
    type: $Enums.PortType
    createdAt?: Date | string
    updatedAt?: Date | string
    server?: GameServerCreateNestedOneWithoutNetworkAllocationsInput
  }

  export type NetworkAllocationUncheckedCreateWithoutNodeInput = {
    id?: string
    port: number
    protocol: $Enums.Protocol
    type: $Enums.PortType
    serverUuid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkAllocationCreateOrConnectWithoutNodeInput = {
    where: NetworkAllocationWhereUniqueInput
    create: XOR<NetworkAllocationCreateWithoutNodeInput, NetworkAllocationUncheckedCreateWithoutNodeInput>
  }

  export type NetworkAllocationCreateManyNodeInputEnvelope = {
    data: NetworkAllocationCreateManyNodeInput | NetworkAllocationCreateManyNodeInput[]
    skipDuplicates?: boolean
  }

  export type MetricCreateWithoutNodeInput = {
    id?: string
    timestamp?: Date | string
    cpuUsage: number
    ramUsage: number
    ramUsagePercent: number
    diskUsage: number
    diskUsagePercent: number
    networkIn: bigint | number
    networkOut: bigint | number
    uptime?: number | null
    server?: GameServerCreateNestedOneWithoutMetricsInput
  }

  export type MetricUncheckedCreateWithoutNodeInput = {
    id?: string
    serverUuid?: string | null
    timestamp?: Date | string
    cpuUsage: number
    ramUsage: number
    ramUsagePercent: number
    diskUsage: number
    diskUsagePercent: number
    networkIn: bigint | number
    networkOut: bigint | number
    uptime?: number | null
  }

  export type MetricCreateOrConnectWithoutNodeInput = {
    where: MetricWhereUniqueInput
    create: XOR<MetricCreateWithoutNodeInput, MetricUncheckedCreateWithoutNodeInput>
  }

  export type MetricCreateManyNodeInputEnvelope = {
    data: MetricCreateManyNodeInput | MetricCreateManyNodeInput[]
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutNodeInput = {
    id?: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved?: boolean
    resolvedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedBy?: UserCreateNestedOneWithoutResolvedAlertsInput
    server?: GameServerCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutNodeInput = {
    id?: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    serverUuid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertCreateOrConnectWithoutNodeInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutNodeInput, AlertUncheckedCreateWithoutNodeInput>
  }

  export type AlertCreateManyNodeInputEnvelope = {
    data: AlertCreateManyNodeInput | AlertCreateManyNodeInput[]
    skipDuplicates?: boolean
  }

  export type GameClusterCreateWithoutStorageNodeInput = {
    id?: string
    gameType: $Enums.GameType
    sharedSecret: string
    mountPath: string
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerCreateNestedManyWithoutClusterInput
  }

  export type GameClusterUncheckedCreateWithoutStorageNodeInput = {
    id?: string
    gameType: $Enums.GameType
    sharedSecret: string
    mountPath: string
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerUncheckedCreateNestedManyWithoutClusterInput
  }

  export type GameClusterCreateOrConnectWithoutStorageNodeInput = {
    where: GameClusterWhereUniqueInput
    create: XOR<GameClusterCreateWithoutStorageNodeInput, GameClusterUncheckedCreateWithoutStorageNodeInput>
  }

  export type GameClusterCreateManyStorageNodeInputEnvelope = {
    data: GameClusterCreateManyStorageNodeInput | GameClusterCreateManyStorageNodeInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutNodeInput = {
    id?: string
    type: $Enums.TaskType
    status?: $Enums.TaskStatus
    data: JsonNullValueInput | InputJsonValue
    error?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUncheckedCreateWithoutNodeInput = {
    id?: string
    type: $Enums.TaskType
    status?: $Enums.TaskStatus
    data: JsonNullValueInput | InputJsonValue
    error?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutNodeInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutNodeInput, TaskUncheckedCreateWithoutNodeInput>
  }

  export type TaskCreateManyNodeInputEnvelope = {
    data: TaskCreateManyNodeInput | TaskCreateManyNodeInput[]
    skipDuplicates?: boolean
  }

  export type GameServerUpsertWithWhereUniqueWithoutNodeInput = {
    where: GameServerWhereUniqueInput
    update: XOR<GameServerUpdateWithoutNodeInput, GameServerUncheckedUpdateWithoutNodeInput>
    create: XOR<GameServerCreateWithoutNodeInput, GameServerUncheckedCreateWithoutNodeInput>
  }

  export type GameServerUpdateWithWhereUniqueWithoutNodeInput = {
    where: GameServerWhereUniqueInput
    data: XOR<GameServerUpdateWithoutNodeInput, GameServerUncheckedUpdateWithoutNodeInput>
  }

  export type GameServerUpdateManyWithWhereWithoutNodeInput = {
    where: GameServerScalarWhereInput
    data: XOR<GameServerUpdateManyMutationInput, GameServerUncheckedUpdateManyWithoutNodeInput>
  }

  export type NetworkAllocationUpsertWithWhereUniqueWithoutNodeInput = {
    where: NetworkAllocationWhereUniqueInput
    update: XOR<NetworkAllocationUpdateWithoutNodeInput, NetworkAllocationUncheckedUpdateWithoutNodeInput>
    create: XOR<NetworkAllocationCreateWithoutNodeInput, NetworkAllocationUncheckedCreateWithoutNodeInput>
  }

  export type NetworkAllocationUpdateWithWhereUniqueWithoutNodeInput = {
    where: NetworkAllocationWhereUniqueInput
    data: XOR<NetworkAllocationUpdateWithoutNodeInput, NetworkAllocationUncheckedUpdateWithoutNodeInput>
  }

  export type NetworkAllocationUpdateManyWithWhereWithoutNodeInput = {
    where: NetworkAllocationScalarWhereInput
    data: XOR<NetworkAllocationUpdateManyMutationInput, NetworkAllocationUncheckedUpdateManyWithoutNodeInput>
  }

  export type NetworkAllocationScalarWhereInput = {
    AND?: NetworkAllocationScalarWhereInput | NetworkAllocationScalarWhereInput[]
    OR?: NetworkAllocationScalarWhereInput[]
    NOT?: NetworkAllocationScalarWhereInput | NetworkAllocationScalarWhereInput[]
    id?: StringFilter<"NetworkAllocation"> | string
    nodeId?: StringFilter<"NetworkAllocation"> | string
    port?: IntFilter<"NetworkAllocation"> | number
    protocol?: EnumProtocolFilter<"NetworkAllocation"> | $Enums.Protocol
    type?: EnumPortTypeFilter<"NetworkAllocation"> | $Enums.PortType
    serverUuid?: StringNullableFilter<"NetworkAllocation"> | string | null
    createdAt?: DateTimeFilter<"NetworkAllocation"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkAllocation"> | Date | string
  }

  export type MetricUpsertWithWhereUniqueWithoutNodeInput = {
    where: MetricWhereUniqueInput
    update: XOR<MetricUpdateWithoutNodeInput, MetricUncheckedUpdateWithoutNodeInput>
    create: XOR<MetricCreateWithoutNodeInput, MetricUncheckedCreateWithoutNodeInput>
  }

  export type MetricUpdateWithWhereUniqueWithoutNodeInput = {
    where: MetricWhereUniqueInput
    data: XOR<MetricUpdateWithoutNodeInput, MetricUncheckedUpdateWithoutNodeInput>
  }

  export type MetricUpdateManyWithWhereWithoutNodeInput = {
    where: MetricScalarWhereInput
    data: XOR<MetricUpdateManyMutationInput, MetricUncheckedUpdateManyWithoutNodeInput>
  }

  export type MetricScalarWhereInput = {
    AND?: MetricScalarWhereInput | MetricScalarWhereInput[]
    OR?: MetricScalarWhereInput[]
    NOT?: MetricScalarWhereInput | MetricScalarWhereInput[]
    id?: StringFilter<"Metric"> | string
    nodeId?: StringFilter<"Metric"> | string
    serverUuid?: StringNullableFilter<"Metric"> | string | null
    timestamp?: DateTimeFilter<"Metric"> | Date | string
    cpuUsage?: FloatFilter<"Metric"> | number
    ramUsage?: FloatFilter<"Metric"> | number
    ramUsagePercent?: FloatFilter<"Metric"> | number
    diskUsage?: FloatFilter<"Metric"> | number
    diskUsagePercent?: FloatFilter<"Metric"> | number
    networkIn?: BigIntFilter<"Metric"> | bigint | number
    networkOut?: BigIntFilter<"Metric"> | bigint | number
    uptime?: IntNullableFilter<"Metric"> | number | null
  }

  export type AlertUpsertWithWhereUniqueWithoutNodeInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutNodeInput, AlertUncheckedUpdateWithoutNodeInput>
    create: XOR<AlertCreateWithoutNodeInput, AlertUncheckedCreateWithoutNodeInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutNodeInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutNodeInput, AlertUncheckedUpdateWithoutNodeInput>
  }

  export type AlertUpdateManyWithWhereWithoutNodeInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutNodeInput>
  }

  export type GameClusterUpsertWithWhereUniqueWithoutStorageNodeInput = {
    where: GameClusterWhereUniqueInput
    update: XOR<GameClusterUpdateWithoutStorageNodeInput, GameClusterUncheckedUpdateWithoutStorageNodeInput>
    create: XOR<GameClusterCreateWithoutStorageNodeInput, GameClusterUncheckedCreateWithoutStorageNodeInput>
  }

  export type GameClusterUpdateWithWhereUniqueWithoutStorageNodeInput = {
    where: GameClusterWhereUniqueInput
    data: XOR<GameClusterUpdateWithoutStorageNodeInput, GameClusterUncheckedUpdateWithoutStorageNodeInput>
  }

  export type GameClusterUpdateManyWithWhereWithoutStorageNodeInput = {
    where: GameClusterScalarWhereInput
    data: XOR<GameClusterUpdateManyMutationInput, GameClusterUncheckedUpdateManyWithoutStorageNodeInput>
  }

  export type GameClusterScalarWhereInput = {
    AND?: GameClusterScalarWhereInput | GameClusterScalarWhereInput[]
    OR?: GameClusterScalarWhereInput[]
    NOT?: GameClusterScalarWhereInput | GameClusterScalarWhereInput[]
    id?: StringFilter<"GameCluster"> | string
    gameType?: EnumGameTypeFilter<"GameCluster"> | $Enums.GameType
    sharedSecret?: StringFilter<"GameCluster"> | string
    storageNodeId?: StringFilter<"GameCluster"> | string
    mountPath?: StringFilter<"GameCluster"> | string
    createdAt?: DateTimeFilter<"GameCluster"> | Date | string
    updatedAt?: DateTimeFilter<"GameCluster"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutNodeInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutNodeInput, TaskUncheckedUpdateWithoutNodeInput>
    create: XOR<TaskCreateWithoutNodeInput, TaskUncheckedCreateWithoutNodeInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutNodeInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutNodeInput, TaskUncheckedUpdateWithoutNodeInput>
  }

  export type TaskUpdateManyWithWhereWithoutNodeInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutNodeInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    nodeId?: StringFilter<"Task"> | string
    type?: EnumTaskTypeFilter<"Task"> | $Enums.TaskType
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    data?: JsonFilter<"Task">
    error?: StringNullableFilter<"Task"> | string | null
    completedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type NodeCreateWithoutTasksInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerCreateNestedManyWithoutNodeInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutNodeInput
    metrics?: MetricCreateNestedManyWithoutNodeInput
    alerts?: AlertCreateNestedManyWithoutNodeInput
    storageClusters?: GameClusterCreateNestedManyWithoutStorageNodeInput
  }

  export type NodeUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerUncheckedCreateNestedManyWithoutNodeInput
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutNodeInput
    metrics?: MetricUncheckedCreateNestedManyWithoutNodeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutNodeInput
    storageClusters?: GameClusterUncheckedCreateNestedManyWithoutStorageNodeInput
  }

  export type NodeCreateOrConnectWithoutTasksInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutTasksInput, NodeUncheckedCreateWithoutTasksInput>
  }

  export type NodeUpsertWithoutTasksInput = {
    update: XOR<NodeUpdateWithoutTasksInput, NodeUncheckedUpdateWithoutTasksInput>
    create: XOR<NodeCreateWithoutTasksInput, NodeUncheckedCreateWithoutTasksInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutTasksInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutTasksInput, NodeUncheckedUpdateWithoutTasksInput>
  }

  export type NodeUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUpdateManyWithoutNodeNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutNodeNestedInput
    metrics?: MetricUpdateManyWithoutNodeNestedInput
    alerts?: AlertUpdateManyWithoutNodeNestedInput
    storageClusters?: GameClusterUpdateManyWithoutStorageNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUncheckedUpdateManyWithoutNodeNestedInput
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutNodeNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutNodeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutNodeNestedInput
    storageClusters?: GameClusterUncheckedUpdateManyWithoutStorageNodeNestedInput
  }

  export type NodeCreateWithoutNetworkAllocationsInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerCreateNestedManyWithoutNodeInput
    metrics?: MetricCreateNestedManyWithoutNodeInput
    alerts?: AlertCreateNestedManyWithoutNodeInput
    storageClusters?: GameClusterCreateNestedManyWithoutStorageNodeInput
    tasks?: TaskCreateNestedManyWithoutNodeInput
  }

  export type NodeUncheckedCreateWithoutNetworkAllocationsInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerUncheckedCreateNestedManyWithoutNodeInput
    metrics?: MetricUncheckedCreateNestedManyWithoutNodeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutNodeInput
    storageClusters?: GameClusterUncheckedCreateNestedManyWithoutStorageNodeInput
    tasks?: TaskUncheckedCreateNestedManyWithoutNodeInput
  }

  export type NodeCreateOrConnectWithoutNetworkAllocationsInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutNetworkAllocationsInput, NodeUncheckedCreateWithoutNetworkAllocationsInput>
  }

  export type GameServerCreateWithoutNetworkAllocationsInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutServersInput
    owner: UserCreateNestedOneWithoutOwnedServersInput
    plan?: PlanCreateNestedOneWithoutServersInput
    cluster?: GameClusterCreateNestedOneWithoutServersInput
    subdomains?: SubdomainCreateNestedManyWithoutServerInput
    backups?: BackupCreateNestedManyWithoutServerInput
    metrics?: MetricCreateNestedManyWithoutServerInput
    alerts?: AlertCreateNestedManyWithoutServerInput
    orders?: OrderCreateNestedManyWithoutServerInput
  }

  export type GameServerUncheckedCreateWithoutNetworkAllocationsInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subdomains?: SubdomainUncheckedCreateNestedManyWithoutServerInput
    backups?: BackupUncheckedCreateNestedManyWithoutServerInput
    metrics?: MetricUncheckedCreateNestedManyWithoutServerInput
    alerts?: AlertUncheckedCreateNestedManyWithoutServerInput
    orders?: OrderUncheckedCreateNestedManyWithoutServerInput
  }

  export type GameServerCreateOrConnectWithoutNetworkAllocationsInput = {
    where: GameServerWhereUniqueInput
    create: XOR<GameServerCreateWithoutNetworkAllocationsInput, GameServerUncheckedCreateWithoutNetworkAllocationsInput>
  }

  export type NodeUpsertWithoutNetworkAllocationsInput = {
    update: XOR<NodeUpdateWithoutNetworkAllocationsInput, NodeUncheckedUpdateWithoutNetworkAllocationsInput>
    create: XOR<NodeCreateWithoutNetworkAllocationsInput, NodeUncheckedCreateWithoutNetworkAllocationsInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutNetworkAllocationsInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutNetworkAllocationsInput, NodeUncheckedUpdateWithoutNetworkAllocationsInput>
  }

  export type NodeUpdateWithoutNetworkAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUpdateManyWithoutNodeNestedInput
    metrics?: MetricUpdateManyWithoutNodeNestedInput
    alerts?: AlertUpdateManyWithoutNodeNestedInput
    storageClusters?: GameClusterUpdateManyWithoutStorageNodeNestedInput
    tasks?: TaskUpdateManyWithoutNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutNetworkAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUncheckedUpdateManyWithoutNodeNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutNodeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutNodeNestedInput
    storageClusters?: GameClusterUncheckedUpdateManyWithoutStorageNodeNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type GameServerUpsertWithoutNetworkAllocationsInput = {
    update: XOR<GameServerUpdateWithoutNetworkAllocationsInput, GameServerUncheckedUpdateWithoutNetworkAllocationsInput>
    create: XOR<GameServerCreateWithoutNetworkAllocationsInput, GameServerUncheckedCreateWithoutNetworkAllocationsInput>
    where?: GameServerWhereInput
  }

  export type GameServerUpdateToOneWithWhereWithoutNetworkAllocationsInput = {
    where?: GameServerWhereInput
    data: XOR<GameServerUpdateWithoutNetworkAllocationsInput, GameServerUncheckedUpdateWithoutNetworkAllocationsInput>
  }

  export type GameServerUpdateWithoutNetworkAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutServersNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedServersNestedInput
    plan?: PlanUpdateOneWithoutServersNestedInput
    cluster?: GameClusterUpdateOneWithoutServersNestedInput
    subdomains?: SubdomainUpdateManyWithoutServerNestedInput
    backups?: BackupUpdateManyWithoutServerNestedInput
    metrics?: MetricUpdateManyWithoutServerNestedInput
    alerts?: AlertUpdateManyWithoutServerNestedInput
    orders?: OrderUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateWithoutNetworkAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subdomains?: SubdomainUncheckedUpdateManyWithoutServerNestedInput
    backups?: BackupUncheckedUpdateManyWithoutServerNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutServerNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutServerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutServerNestedInput
  }

  export type GameServerCreateWithoutSubdomainsInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutServersInput
    owner: UserCreateNestedOneWithoutOwnedServersInput
    plan?: PlanCreateNestedOneWithoutServersInput
    cluster?: GameClusterCreateNestedOneWithoutServersInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutServerInput
    backups?: BackupCreateNestedManyWithoutServerInput
    metrics?: MetricCreateNestedManyWithoutServerInput
    alerts?: AlertCreateNestedManyWithoutServerInput
    orders?: OrderCreateNestedManyWithoutServerInput
  }

  export type GameServerUncheckedCreateWithoutSubdomainsInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutServerInput
    backups?: BackupUncheckedCreateNestedManyWithoutServerInput
    metrics?: MetricUncheckedCreateNestedManyWithoutServerInput
    alerts?: AlertUncheckedCreateNestedManyWithoutServerInput
    orders?: OrderUncheckedCreateNestedManyWithoutServerInput
  }

  export type GameServerCreateOrConnectWithoutSubdomainsInput = {
    where: GameServerWhereUniqueInput
    create: XOR<GameServerCreateWithoutSubdomainsInput, GameServerUncheckedCreateWithoutSubdomainsInput>
  }

  export type GameServerUpsertWithoutSubdomainsInput = {
    update: XOR<GameServerUpdateWithoutSubdomainsInput, GameServerUncheckedUpdateWithoutSubdomainsInput>
    create: XOR<GameServerCreateWithoutSubdomainsInput, GameServerUncheckedCreateWithoutSubdomainsInput>
    where?: GameServerWhereInput
  }

  export type GameServerUpdateToOneWithWhereWithoutSubdomainsInput = {
    where?: GameServerWhereInput
    data: XOR<GameServerUpdateWithoutSubdomainsInput, GameServerUncheckedUpdateWithoutSubdomainsInput>
  }

  export type GameServerUpdateWithoutSubdomainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutServersNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedServersNestedInput
    plan?: PlanUpdateOneWithoutServersNestedInput
    cluster?: GameClusterUpdateOneWithoutServersNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutServerNestedInput
    backups?: BackupUpdateManyWithoutServerNestedInput
    metrics?: MetricUpdateManyWithoutServerNestedInput
    alerts?: AlertUpdateManyWithoutServerNestedInput
    orders?: OrderUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateWithoutSubdomainsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutServerNestedInput
    backups?: BackupUncheckedUpdateManyWithoutServerNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutServerNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutServerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutServerNestedInput
  }

  export type NodeCreateWithoutServersInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutNodeInput
    metrics?: MetricCreateNestedManyWithoutNodeInput
    alerts?: AlertCreateNestedManyWithoutNodeInput
    storageClusters?: GameClusterCreateNestedManyWithoutStorageNodeInput
    tasks?: TaskCreateNestedManyWithoutNodeInput
  }

  export type NodeUncheckedCreateWithoutServersInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutNodeInput
    metrics?: MetricUncheckedCreateNestedManyWithoutNodeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutNodeInput
    storageClusters?: GameClusterUncheckedCreateNestedManyWithoutStorageNodeInput
    tasks?: TaskUncheckedCreateNestedManyWithoutNodeInput
  }

  export type NodeCreateOrConnectWithoutServersInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutServersInput, NodeUncheckedCreateWithoutServersInput>
  }

  export type UserCreateWithoutOwnedServersInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentCreateNestedManyWithoutAssignedToInput
    orders?: OrderCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutOwnedServersInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertUncheckedCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentUncheckedCreateNestedManyWithoutAssignedToInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutOwnedServersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedServersInput, UserUncheckedCreateWithoutOwnedServersInput>
  }

  export type PlanCreateWithoutServersInput = {
    id?: string
    name: string
    slug: string
    gameType: $Enums.GameType
    status?: $Enums.PlanStatus
    ramMb: number
    cpuCores: number
    diskGb: number
    maxSlots?: number | null
    monthlyPrice: number
    hourlyPrice?: number | null
    setupFee?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    isPopular?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutPlanInput
    promotions?: PromotionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutServersInput = {
    id?: string
    name: string
    slug: string
    gameType: $Enums.GameType
    status?: $Enums.PlanStatus
    ramMb: number
    cpuCores: number
    diskGb: number
    maxSlots?: number | null
    monthlyPrice: number
    hourlyPrice?: number | null
    setupFee?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    isPopular?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutPlanInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutServersInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutServersInput, PlanUncheckedCreateWithoutServersInput>
  }

  export type GameClusterCreateWithoutServersInput = {
    id?: string
    gameType: $Enums.GameType
    sharedSecret: string
    mountPath: string
    createdAt?: Date | string
    updatedAt?: Date | string
    storageNode: NodeCreateNestedOneWithoutStorageClustersInput
  }

  export type GameClusterUncheckedCreateWithoutServersInput = {
    id?: string
    gameType: $Enums.GameType
    sharedSecret: string
    storageNodeId: string
    mountPath: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameClusterCreateOrConnectWithoutServersInput = {
    where: GameClusterWhereUniqueInput
    create: XOR<GameClusterCreateWithoutServersInput, GameClusterUncheckedCreateWithoutServersInput>
  }

  export type NetworkAllocationCreateWithoutServerInput = {
    id?: string
    port: number
    protocol: $Enums.Protocol
    type: $Enums.PortType
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutNetworkAllocationsInput
  }

  export type NetworkAllocationUncheckedCreateWithoutServerInput = {
    id?: string
    nodeId: string
    port: number
    protocol: $Enums.Protocol
    type: $Enums.PortType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkAllocationCreateOrConnectWithoutServerInput = {
    where: NetworkAllocationWhereUniqueInput
    create: XOR<NetworkAllocationCreateWithoutServerInput, NetworkAllocationUncheckedCreateWithoutServerInput>
  }

  export type NetworkAllocationCreateManyServerInputEnvelope = {
    data: NetworkAllocationCreateManyServerInput | NetworkAllocationCreateManyServerInput[]
    skipDuplicates?: boolean
  }

  export type SubdomainCreateWithoutServerInput = {
    id?: string
    subdomain: string
    domain: string
    cloudflareId: string
    targetIP: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubdomainUncheckedCreateWithoutServerInput = {
    id?: string
    subdomain: string
    domain: string
    cloudflareId: string
    targetIP: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubdomainCreateOrConnectWithoutServerInput = {
    where: SubdomainWhereUniqueInput
    create: XOR<SubdomainCreateWithoutServerInput, SubdomainUncheckedCreateWithoutServerInput>
  }

  export type SubdomainCreateManyServerInputEnvelope = {
    data: SubdomainCreateManyServerInput | SubdomainCreateManyServerInput[]
    skipDuplicates?: boolean
  }

  export type BackupCreateWithoutServerInput = {
    id?: string
    snapshotId: string
    sizeBytes: bigint | number
    location: $Enums.BackupLocation
    lastRestoredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackupUncheckedCreateWithoutServerInput = {
    id?: string
    snapshotId: string
    sizeBytes: bigint | number
    location: $Enums.BackupLocation
    lastRestoredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackupCreateOrConnectWithoutServerInput = {
    where: BackupWhereUniqueInput
    create: XOR<BackupCreateWithoutServerInput, BackupUncheckedCreateWithoutServerInput>
  }

  export type BackupCreateManyServerInputEnvelope = {
    data: BackupCreateManyServerInput | BackupCreateManyServerInput[]
    skipDuplicates?: boolean
  }

  export type MetricCreateWithoutServerInput = {
    id?: string
    timestamp?: Date | string
    cpuUsage: number
    ramUsage: number
    ramUsagePercent: number
    diskUsage: number
    diskUsagePercent: number
    networkIn: bigint | number
    networkOut: bigint | number
    uptime?: number | null
    node: NodeCreateNestedOneWithoutMetricsInput
  }

  export type MetricUncheckedCreateWithoutServerInput = {
    id?: string
    nodeId: string
    timestamp?: Date | string
    cpuUsage: number
    ramUsage: number
    ramUsagePercent: number
    diskUsage: number
    diskUsagePercent: number
    networkIn: bigint | number
    networkOut: bigint | number
    uptime?: number | null
  }

  export type MetricCreateOrConnectWithoutServerInput = {
    where: MetricWhereUniqueInput
    create: XOR<MetricCreateWithoutServerInput, MetricUncheckedCreateWithoutServerInput>
  }

  export type MetricCreateManyServerInputEnvelope = {
    data: MetricCreateManyServerInput | MetricCreateManyServerInput[]
    skipDuplicates?: boolean
  }

  export type AlertCreateWithoutServerInput = {
    id?: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved?: boolean
    resolvedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedBy?: UserCreateNestedOneWithoutResolvedAlertsInput
    node?: NodeCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutServerInput = {
    id?: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertCreateOrConnectWithoutServerInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutServerInput, AlertUncheckedCreateWithoutServerInput>
  }

  export type AlertCreateManyServerInputEnvelope = {
    data: AlertCreateManyServerInput | AlertCreateManyServerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutServerInput = {
    id?: string
    status?: $Enums.OrderStatus
    priceSnapshot: JsonNullValueInput | InputJsonValue
    totalAmount: number
    currency?: string
    paymentMethod?: string | null
    paymentId?: string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    plan: PlanCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutServerInput = {
    id?: string
    userId: string
    planId: string
    status?: $Enums.OrderStatus
    priceSnapshot: JsonNullValueInput | InputJsonValue
    totalAmount: number
    currency?: string
    paymentMethod?: string | null
    paymentId?: string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutServerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutServerInput, OrderUncheckedCreateWithoutServerInput>
  }

  export type OrderCreateManyServerInputEnvelope = {
    data: OrderCreateManyServerInput | OrderCreateManyServerInput[]
    skipDuplicates?: boolean
  }

  export type NodeUpsertWithoutServersInput = {
    update: XOR<NodeUpdateWithoutServersInput, NodeUncheckedUpdateWithoutServersInput>
    create: XOR<NodeCreateWithoutServersInput, NodeUncheckedCreateWithoutServersInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutServersInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutServersInput, NodeUncheckedUpdateWithoutServersInput>
  }

  export type NodeUpdateWithoutServersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkAllocations?: NetworkAllocationUpdateManyWithoutNodeNestedInput
    metrics?: MetricUpdateManyWithoutNodeNestedInput
    alerts?: AlertUpdateManyWithoutNodeNestedInput
    storageClusters?: GameClusterUpdateManyWithoutStorageNodeNestedInput
    tasks?: TaskUpdateManyWithoutNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutServersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutNodeNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutNodeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutNodeNestedInput
    storageClusters?: GameClusterUncheckedUpdateManyWithoutStorageNodeNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type UserUpsertWithoutOwnedServersInput = {
    update: XOR<UserUpdateWithoutOwnedServersInput, UserUncheckedUpdateWithoutOwnedServersInput>
    create: XOR<UserCreateWithoutOwnedServersInput, UserUncheckedCreateWithoutOwnedServersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedServersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedServersInput, UserUncheckedUpdateWithoutOwnedServersInput>
  }

  export type UserUpdateWithoutOwnedServersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedServersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUncheckedUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUncheckedUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type PlanUpsertWithoutServersInput = {
    update: XOR<PlanUpdateWithoutServersInput, PlanUncheckedUpdateWithoutServersInput>
    create: XOR<PlanCreateWithoutServersInput, PlanUncheckedCreateWithoutServersInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutServersInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutServersInput, PlanUncheckedUpdateWithoutServersInput>
  }

  export type PlanUpdateWithoutServersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumPlanStatusFieldUpdateOperationsInput | $Enums.PlanStatus
    ramMb?: IntFieldUpdateOperationsInput | number
    cpuCores?: IntFieldUpdateOperationsInput | number
    diskGb?: IntFieldUpdateOperationsInput | number
    maxSlots?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    hourlyPrice?: NullableIntFieldUpdateOperationsInput | number | null
    setupFee?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutPlanNestedInput
    promotions?: PromotionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutServersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumPlanStatusFieldUpdateOperationsInput | $Enums.PlanStatus
    ramMb?: IntFieldUpdateOperationsInput | number
    cpuCores?: IntFieldUpdateOperationsInput | number
    diskGb?: IntFieldUpdateOperationsInput | number
    maxSlots?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    hourlyPrice?: NullableIntFieldUpdateOperationsInput | number | null
    setupFee?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutPlanNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type GameClusterUpsertWithoutServersInput = {
    update: XOR<GameClusterUpdateWithoutServersInput, GameClusterUncheckedUpdateWithoutServersInput>
    create: XOR<GameClusterCreateWithoutServersInput, GameClusterUncheckedCreateWithoutServersInput>
    where?: GameClusterWhereInput
  }

  export type GameClusterUpdateToOneWithWhereWithoutServersInput = {
    where?: GameClusterWhereInput
    data: XOR<GameClusterUpdateWithoutServersInput, GameClusterUncheckedUpdateWithoutServersInput>
  }

  export type GameClusterUpdateWithoutServersInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    sharedSecret?: StringFieldUpdateOperationsInput | string
    mountPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storageNode?: NodeUpdateOneRequiredWithoutStorageClustersNestedInput
  }

  export type GameClusterUncheckedUpdateWithoutServersInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    sharedSecret?: StringFieldUpdateOperationsInput | string
    storageNodeId?: StringFieldUpdateOperationsInput | string
    mountPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkAllocationUpsertWithWhereUniqueWithoutServerInput = {
    where: NetworkAllocationWhereUniqueInput
    update: XOR<NetworkAllocationUpdateWithoutServerInput, NetworkAllocationUncheckedUpdateWithoutServerInput>
    create: XOR<NetworkAllocationCreateWithoutServerInput, NetworkAllocationUncheckedCreateWithoutServerInput>
  }

  export type NetworkAllocationUpdateWithWhereUniqueWithoutServerInput = {
    where: NetworkAllocationWhereUniqueInput
    data: XOR<NetworkAllocationUpdateWithoutServerInput, NetworkAllocationUncheckedUpdateWithoutServerInput>
  }

  export type NetworkAllocationUpdateManyWithWhereWithoutServerInput = {
    where: NetworkAllocationScalarWhereInput
    data: XOR<NetworkAllocationUpdateManyMutationInput, NetworkAllocationUncheckedUpdateManyWithoutServerInput>
  }

  export type SubdomainUpsertWithWhereUniqueWithoutServerInput = {
    where: SubdomainWhereUniqueInput
    update: XOR<SubdomainUpdateWithoutServerInput, SubdomainUncheckedUpdateWithoutServerInput>
    create: XOR<SubdomainCreateWithoutServerInput, SubdomainUncheckedCreateWithoutServerInput>
  }

  export type SubdomainUpdateWithWhereUniqueWithoutServerInput = {
    where: SubdomainWhereUniqueInput
    data: XOR<SubdomainUpdateWithoutServerInput, SubdomainUncheckedUpdateWithoutServerInput>
  }

  export type SubdomainUpdateManyWithWhereWithoutServerInput = {
    where: SubdomainScalarWhereInput
    data: XOR<SubdomainUpdateManyMutationInput, SubdomainUncheckedUpdateManyWithoutServerInput>
  }

  export type SubdomainScalarWhereInput = {
    AND?: SubdomainScalarWhereInput | SubdomainScalarWhereInput[]
    OR?: SubdomainScalarWhereInput[]
    NOT?: SubdomainScalarWhereInput | SubdomainScalarWhereInput[]
    id?: StringFilter<"Subdomain"> | string
    subdomain?: StringFilter<"Subdomain"> | string
    domain?: StringFilter<"Subdomain"> | string
    serverUuid?: StringFilter<"Subdomain"> | string
    cloudflareId?: StringFilter<"Subdomain"> | string
    targetIP?: StringFilter<"Subdomain"> | string
    createdAt?: DateTimeFilter<"Subdomain"> | Date | string
    updatedAt?: DateTimeFilter<"Subdomain"> | Date | string
  }

  export type BackupUpsertWithWhereUniqueWithoutServerInput = {
    where: BackupWhereUniqueInput
    update: XOR<BackupUpdateWithoutServerInput, BackupUncheckedUpdateWithoutServerInput>
    create: XOR<BackupCreateWithoutServerInput, BackupUncheckedCreateWithoutServerInput>
  }

  export type BackupUpdateWithWhereUniqueWithoutServerInput = {
    where: BackupWhereUniqueInput
    data: XOR<BackupUpdateWithoutServerInput, BackupUncheckedUpdateWithoutServerInput>
  }

  export type BackupUpdateManyWithWhereWithoutServerInput = {
    where: BackupScalarWhereInput
    data: XOR<BackupUpdateManyMutationInput, BackupUncheckedUpdateManyWithoutServerInput>
  }

  export type BackupScalarWhereInput = {
    AND?: BackupScalarWhereInput | BackupScalarWhereInput[]
    OR?: BackupScalarWhereInput[]
    NOT?: BackupScalarWhereInput | BackupScalarWhereInput[]
    id?: StringFilter<"Backup"> | string
    serverUuid?: StringFilter<"Backup"> | string
    snapshotId?: StringFilter<"Backup"> | string
    sizeBytes?: BigIntFilter<"Backup"> | bigint | number
    location?: EnumBackupLocationFilter<"Backup"> | $Enums.BackupLocation
    lastRestoredAt?: DateTimeNullableFilter<"Backup"> | Date | string | null
    createdAt?: DateTimeFilter<"Backup"> | Date | string
    updatedAt?: DateTimeFilter<"Backup"> | Date | string
  }

  export type MetricUpsertWithWhereUniqueWithoutServerInput = {
    where: MetricWhereUniqueInput
    update: XOR<MetricUpdateWithoutServerInput, MetricUncheckedUpdateWithoutServerInput>
    create: XOR<MetricCreateWithoutServerInput, MetricUncheckedCreateWithoutServerInput>
  }

  export type MetricUpdateWithWhereUniqueWithoutServerInput = {
    where: MetricWhereUniqueInput
    data: XOR<MetricUpdateWithoutServerInput, MetricUncheckedUpdateWithoutServerInput>
  }

  export type MetricUpdateManyWithWhereWithoutServerInput = {
    where: MetricScalarWhereInput
    data: XOR<MetricUpdateManyMutationInput, MetricUncheckedUpdateManyWithoutServerInput>
  }

  export type AlertUpsertWithWhereUniqueWithoutServerInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutServerInput, AlertUncheckedUpdateWithoutServerInput>
    create: XOR<AlertCreateWithoutServerInput, AlertUncheckedCreateWithoutServerInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutServerInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutServerInput, AlertUncheckedUpdateWithoutServerInput>
  }

  export type AlertUpdateManyWithWhereWithoutServerInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutServerInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutServerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutServerInput, OrderUncheckedUpdateWithoutServerInput>
    create: XOR<OrderCreateWithoutServerInput, OrderUncheckedCreateWithoutServerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutServerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutServerInput, OrderUncheckedUpdateWithoutServerInput>
  }

  export type OrderUpdateManyWithWhereWithoutServerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutServerInput>
  }

  export type NodeCreateWithoutStorageClustersInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerCreateNestedManyWithoutNodeInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutNodeInput
    metrics?: MetricCreateNestedManyWithoutNodeInput
    alerts?: AlertCreateNestedManyWithoutNodeInput
    tasks?: TaskCreateNestedManyWithoutNodeInput
  }

  export type NodeUncheckedCreateWithoutStorageClustersInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerUncheckedCreateNestedManyWithoutNodeInput
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutNodeInput
    metrics?: MetricUncheckedCreateNestedManyWithoutNodeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutNodeInput
    tasks?: TaskUncheckedCreateNestedManyWithoutNodeInput
  }

  export type NodeCreateOrConnectWithoutStorageClustersInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutStorageClustersInput, NodeUncheckedCreateWithoutStorageClustersInput>
  }

  export type GameServerCreateWithoutClusterInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutServersInput
    owner: UserCreateNestedOneWithoutOwnedServersInput
    plan?: PlanCreateNestedOneWithoutServersInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutServerInput
    subdomains?: SubdomainCreateNestedManyWithoutServerInput
    backups?: BackupCreateNestedManyWithoutServerInput
    metrics?: MetricCreateNestedManyWithoutServerInput
    alerts?: AlertCreateNestedManyWithoutServerInput
    orders?: OrderCreateNestedManyWithoutServerInput
  }

  export type GameServerUncheckedCreateWithoutClusterInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutServerInput
    subdomains?: SubdomainUncheckedCreateNestedManyWithoutServerInput
    backups?: BackupUncheckedCreateNestedManyWithoutServerInput
    metrics?: MetricUncheckedCreateNestedManyWithoutServerInput
    alerts?: AlertUncheckedCreateNestedManyWithoutServerInput
    orders?: OrderUncheckedCreateNestedManyWithoutServerInput
  }

  export type GameServerCreateOrConnectWithoutClusterInput = {
    where: GameServerWhereUniqueInput
    create: XOR<GameServerCreateWithoutClusterInput, GameServerUncheckedCreateWithoutClusterInput>
  }

  export type GameServerCreateManyClusterInputEnvelope = {
    data: GameServerCreateManyClusterInput | GameServerCreateManyClusterInput[]
    skipDuplicates?: boolean
  }

  export type NodeUpsertWithoutStorageClustersInput = {
    update: XOR<NodeUpdateWithoutStorageClustersInput, NodeUncheckedUpdateWithoutStorageClustersInput>
    create: XOR<NodeCreateWithoutStorageClustersInput, NodeUncheckedCreateWithoutStorageClustersInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutStorageClustersInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutStorageClustersInput, NodeUncheckedUpdateWithoutStorageClustersInput>
  }

  export type NodeUpdateWithoutStorageClustersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUpdateManyWithoutNodeNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutNodeNestedInput
    metrics?: MetricUpdateManyWithoutNodeNestedInput
    alerts?: AlertUpdateManyWithoutNodeNestedInput
    tasks?: TaskUpdateManyWithoutNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutStorageClustersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUncheckedUpdateManyWithoutNodeNestedInput
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutNodeNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutNodeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutNodeNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type GameServerUpsertWithWhereUniqueWithoutClusterInput = {
    where: GameServerWhereUniqueInput
    update: XOR<GameServerUpdateWithoutClusterInput, GameServerUncheckedUpdateWithoutClusterInput>
    create: XOR<GameServerCreateWithoutClusterInput, GameServerUncheckedCreateWithoutClusterInput>
  }

  export type GameServerUpdateWithWhereUniqueWithoutClusterInput = {
    where: GameServerWhereUniqueInput
    data: XOR<GameServerUpdateWithoutClusterInput, GameServerUncheckedUpdateWithoutClusterInput>
  }

  export type GameServerUpdateManyWithWhereWithoutClusterInput = {
    where: GameServerScalarWhereInput
    data: XOR<GameServerUpdateManyMutationInput, GameServerUncheckedUpdateManyWithoutClusterInput>
  }

  export type GameServerCreateWithoutBackupsInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutServersInput
    owner: UserCreateNestedOneWithoutOwnedServersInput
    plan?: PlanCreateNestedOneWithoutServersInput
    cluster?: GameClusterCreateNestedOneWithoutServersInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutServerInput
    subdomains?: SubdomainCreateNestedManyWithoutServerInput
    metrics?: MetricCreateNestedManyWithoutServerInput
    alerts?: AlertCreateNestedManyWithoutServerInput
    orders?: OrderCreateNestedManyWithoutServerInput
  }

  export type GameServerUncheckedCreateWithoutBackupsInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutServerInput
    subdomains?: SubdomainUncheckedCreateNestedManyWithoutServerInput
    metrics?: MetricUncheckedCreateNestedManyWithoutServerInput
    alerts?: AlertUncheckedCreateNestedManyWithoutServerInput
    orders?: OrderUncheckedCreateNestedManyWithoutServerInput
  }

  export type GameServerCreateOrConnectWithoutBackupsInput = {
    where: GameServerWhereUniqueInput
    create: XOR<GameServerCreateWithoutBackupsInput, GameServerUncheckedCreateWithoutBackupsInput>
  }

  export type GameServerUpsertWithoutBackupsInput = {
    update: XOR<GameServerUpdateWithoutBackupsInput, GameServerUncheckedUpdateWithoutBackupsInput>
    create: XOR<GameServerCreateWithoutBackupsInput, GameServerUncheckedCreateWithoutBackupsInput>
    where?: GameServerWhereInput
  }

  export type GameServerUpdateToOneWithWhereWithoutBackupsInput = {
    where?: GameServerWhereInput
    data: XOR<GameServerUpdateWithoutBackupsInput, GameServerUncheckedUpdateWithoutBackupsInput>
  }

  export type GameServerUpdateWithoutBackupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutServersNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedServersNestedInput
    plan?: PlanUpdateOneWithoutServersNestedInput
    cluster?: GameClusterUpdateOneWithoutServersNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUpdateManyWithoutServerNestedInput
    metrics?: MetricUpdateManyWithoutServerNestedInput
    alerts?: AlertUpdateManyWithoutServerNestedInput
    orders?: OrderUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateWithoutBackupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUncheckedUpdateManyWithoutServerNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutServerNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutServerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutServerNestedInput
  }

  export type NodeCreateWithoutMetricsInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerCreateNestedManyWithoutNodeInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutNodeInput
    alerts?: AlertCreateNestedManyWithoutNodeInput
    storageClusters?: GameClusterCreateNestedManyWithoutStorageNodeInput
    tasks?: TaskCreateNestedManyWithoutNodeInput
  }

  export type NodeUncheckedCreateWithoutMetricsInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerUncheckedCreateNestedManyWithoutNodeInput
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutNodeInput
    alerts?: AlertUncheckedCreateNestedManyWithoutNodeInput
    storageClusters?: GameClusterUncheckedCreateNestedManyWithoutStorageNodeInput
    tasks?: TaskUncheckedCreateNestedManyWithoutNodeInput
  }

  export type NodeCreateOrConnectWithoutMetricsInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutMetricsInput, NodeUncheckedCreateWithoutMetricsInput>
  }

  export type GameServerCreateWithoutMetricsInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutServersInput
    owner: UserCreateNestedOneWithoutOwnedServersInput
    plan?: PlanCreateNestedOneWithoutServersInput
    cluster?: GameClusterCreateNestedOneWithoutServersInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutServerInput
    subdomains?: SubdomainCreateNestedManyWithoutServerInput
    backups?: BackupCreateNestedManyWithoutServerInput
    alerts?: AlertCreateNestedManyWithoutServerInput
    orders?: OrderCreateNestedManyWithoutServerInput
  }

  export type GameServerUncheckedCreateWithoutMetricsInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutServerInput
    subdomains?: SubdomainUncheckedCreateNestedManyWithoutServerInput
    backups?: BackupUncheckedCreateNestedManyWithoutServerInput
    alerts?: AlertUncheckedCreateNestedManyWithoutServerInput
    orders?: OrderUncheckedCreateNestedManyWithoutServerInput
  }

  export type GameServerCreateOrConnectWithoutMetricsInput = {
    where: GameServerWhereUniqueInput
    create: XOR<GameServerCreateWithoutMetricsInput, GameServerUncheckedCreateWithoutMetricsInput>
  }

  export type NodeUpsertWithoutMetricsInput = {
    update: XOR<NodeUpdateWithoutMetricsInput, NodeUncheckedUpdateWithoutMetricsInput>
    create: XOR<NodeCreateWithoutMetricsInput, NodeUncheckedCreateWithoutMetricsInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutMetricsInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutMetricsInput, NodeUncheckedUpdateWithoutMetricsInput>
  }

  export type NodeUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUpdateManyWithoutNodeNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutNodeNestedInput
    alerts?: AlertUpdateManyWithoutNodeNestedInput
    storageClusters?: GameClusterUpdateManyWithoutStorageNodeNestedInput
    tasks?: TaskUpdateManyWithoutNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUncheckedUpdateManyWithoutNodeNestedInput
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutNodeNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutNodeNestedInput
    storageClusters?: GameClusterUncheckedUpdateManyWithoutStorageNodeNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type GameServerUpsertWithoutMetricsInput = {
    update: XOR<GameServerUpdateWithoutMetricsInput, GameServerUncheckedUpdateWithoutMetricsInput>
    create: XOR<GameServerCreateWithoutMetricsInput, GameServerUncheckedCreateWithoutMetricsInput>
    where?: GameServerWhereInput
  }

  export type GameServerUpdateToOneWithWhereWithoutMetricsInput = {
    where?: GameServerWhereInput
    data: XOR<GameServerUpdateWithoutMetricsInput, GameServerUncheckedUpdateWithoutMetricsInput>
  }

  export type GameServerUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutServersNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedServersNestedInput
    plan?: PlanUpdateOneWithoutServersNestedInput
    cluster?: GameClusterUpdateOneWithoutServersNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUpdateManyWithoutServerNestedInput
    backups?: BackupUpdateManyWithoutServerNestedInput
    alerts?: AlertUpdateManyWithoutServerNestedInput
    orders?: OrderUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUncheckedUpdateManyWithoutServerNestedInput
    backups?: BackupUncheckedUpdateManyWithoutServerNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutServerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutServerNestedInput
  }

  export type UserCreateWithoutResolvedAlertsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    ownedServers?: GameServerCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentCreateNestedManyWithoutAssignedToInput
    orders?: OrderCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutResolvedAlertsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerUncheckedCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentUncheckedCreateNestedManyWithoutAssignedToInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutResolvedAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResolvedAlertsInput, UserUncheckedCreateWithoutResolvedAlertsInput>
  }

  export type NodeCreateWithoutAlertsInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerCreateNestedManyWithoutNodeInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutNodeInput
    metrics?: MetricCreateNestedManyWithoutNodeInput
    storageClusters?: GameClusterCreateNestedManyWithoutStorageNodeInput
    tasks?: TaskCreateNestedManyWithoutNodeInput
  }

  export type NodeUncheckedCreateWithoutAlertsInput = {
    id?: string
    name: string
    apiKey: string
    ipAddress: string
    publicFqdn?: string | null
    totalRam: number
    totalCpu: number
    diskType: $Enums.DiskType
    isClusterStorage?: boolean
    maintenanceMode?: boolean
    maxConcurrentUpdates?: number
    status?: $Enums.NodeStatus
    lastHeartbeat?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerUncheckedCreateNestedManyWithoutNodeInput
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutNodeInput
    metrics?: MetricUncheckedCreateNestedManyWithoutNodeInput
    storageClusters?: GameClusterUncheckedCreateNestedManyWithoutStorageNodeInput
    tasks?: TaskUncheckedCreateNestedManyWithoutNodeInput
  }

  export type NodeCreateOrConnectWithoutAlertsInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutAlertsInput, NodeUncheckedCreateWithoutAlertsInput>
  }

  export type GameServerCreateWithoutAlertsInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutServersInput
    owner: UserCreateNestedOneWithoutOwnedServersInput
    plan?: PlanCreateNestedOneWithoutServersInput
    cluster?: GameClusterCreateNestedOneWithoutServersInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutServerInput
    subdomains?: SubdomainCreateNestedManyWithoutServerInput
    backups?: BackupCreateNestedManyWithoutServerInput
    metrics?: MetricCreateNestedManyWithoutServerInput
    orders?: OrderCreateNestedManyWithoutServerInput
  }

  export type GameServerUncheckedCreateWithoutAlertsInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutServerInput
    subdomains?: SubdomainUncheckedCreateNestedManyWithoutServerInput
    backups?: BackupUncheckedCreateNestedManyWithoutServerInput
    metrics?: MetricUncheckedCreateNestedManyWithoutServerInput
    orders?: OrderUncheckedCreateNestedManyWithoutServerInput
  }

  export type GameServerCreateOrConnectWithoutAlertsInput = {
    where: GameServerWhereUniqueInput
    create: XOR<GameServerCreateWithoutAlertsInput, GameServerUncheckedCreateWithoutAlertsInput>
  }

  export type UserUpsertWithoutResolvedAlertsInput = {
    update: XOR<UserUpdateWithoutResolvedAlertsInput, UserUncheckedUpdateWithoutResolvedAlertsInput>
    create: XOR<UserCreateWithoutResolvedAlertsInput, UserUncheckedCreateWithoutResolvedAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResolvedAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResolvedAlertsInput, UserUncheckedUpdateWithoutResolvedAlertsInput>
  }

  export type UserUpdateWithoutResolvedAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    ownedServers?: GameServerUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutResolvedAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUncheckedUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUncheckedUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type NodeUpsertWithoutAlertsInput = {
    update: XOR<NodeUpdateWithoutAlertsInput, NodeUncheckedUpdateWithoutAlertsInput>
    create: XOR<NodeCreateWithoutAlertsInput, NodeUncheckedCreateWithoutAlertsInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutAlertsInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutAlertsInput, NodeUncheckedUpdateWithoutAlertsInput>
  }

  export type NodeUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUpdateManyWithoutNodeNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutNodeNestedInput
    metrics?: MetricUpdateManyWithoutNodeNestedInput
    storageClusters?: GameClusterUpdateManyWithoutStorageNodeNestedInput
    tasks?: TaskUpdateManyWithoutNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    publicFqdn?: NullableStringFieldUpdateOperationsInput | string | null
    totalRam?: IntFieldUpdateOperationsInput | number
    totalCpu?: IntFieldUpdateOperationsInput | number
    diskType?: EnumDiskTypeFieldUpdateOperationsInput | $Enums.DiskType
    isClusterStorage?: BoolFieldUpdateOperationsInput | boolean
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    maxConcurrentUpdates?: IntFieldUpdateOperationsInput | number
    status?: EnumNodeStatusFieldUpdateOperationsInput | $Enums.NodeStatus
    lastHeartbeat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUncheckedUpdateManyWithoutNodeNestedInput
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutNodeNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutNodeNestedInput
    storageClusters?: GameClusterUncheckedUpdateManyWithoutStorageNodeNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutNodeNestedInput
  }

  export type GameServerUpsertWithoutAlertsInput = {
    update: XOR<GameServerUpdateWithoutAlertsInput, GameServerUncheckedUpdateWithoutAlertsInput>
    create: XOR<GameServerCreateWithoutAlertsInput, GameServerUncheckedCreateWithoutAlertsInput>
    where?: GameServerWhereInput
  }

  export type GameServerUpdateToOneWithWhereWithoutAlertsInput = {
    where?: GameServerWhereInput
    data: XOR<GameServerUpdateWithoutAlertsInput, GameServerUncheckedUpdateWithoutAlertsInput>
  }

  export type GameServerUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutServersNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedServersNestedInput
    plan?: PlanUpdateOneWithoutServersNestedInput
    cluster?: GameClusterUpdateOneWithoutServersNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUpdateManyWithoutServerNestedInput
    backups?: BackupUpdateManyWithoutServerNestedInput
    metrics?: MetricUpdateManyWithoutServerNestedInput
    orders?: OrderUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUncheckedUpdateManyWithoutServerNestedInput
    backups?: BackupUncheckedUpdateManyWithoutServerNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutServerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutServerNestedInput
  }

  export type UserCreateWithoutResourceQuotasInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    ownedServers?: GameServerCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertCreateNestedManyWithoutResolvedByInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentCreateNestedManyWithoutAssignedToInput
    orders?: OrderCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutResourceQuotasInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerUncheckedCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertUncheckedCreateNestedManyWithoutResolvedByInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentUncheckedCreateNestedManyWithoutAssignedToInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutResourceQuotasInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResourceQuotasInput, UserUncheckedCreateWithoutResourceQuotasInput>
  }

  export type TenantCreateWithoutResourceQuotasInput = {
    id?: string
    name: string
    domain: string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutResourceQuotasInput = {
    id?: string
    name: string
    domain: string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutResourceQuotasInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutResourceQuotasInput, TenantUncheckedCreateWithoutResourceQuotasInput>
  }

  export type UserUpsertWithoutResourceQuotasInput = {
    update: XOR<UserUpdateWithoutResourceQuotasInput, UserUncheckedUpdateWithoutResourceQuotasInput>
    create: XOR<UserCreateWithoutResourceQuotasInput, UserUncheckedCreateWithoutResourceQuotasInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResourceQuotasInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResourceQuotasInput, UserUncheckedUpdateWithoutResourceQuotasInput>
  }

  export type UserUpdateWithoutResourceQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    ownedServers?: GameServerUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUpdateManyWithoutResolvedByNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutResourceQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUncheckedUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUncheckedUpdateManyWithoutResolvedByNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUncheckedUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type TenantUpsertWithoutResourceQuotasInput = {
    update: XOR<TenantUpdateWithoutResourceQuotasInput, TenantUncheckedUpdateWithoutResourceQuotasInput>
    create: XOR<TenantCreateWithoutResourceQuotasInput, TenantUncheckedCreateWithoutResourceQuotasInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutResourceQuotasInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutResourceQuotasInput, TenantUncheckedUpdateWithoutResourceQuotasInput>
  }

  export type TenantUpdateWithoutResourceQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutResourceQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    themeConfig?: NullableJsonNullValueInput | InputJsonValue
    smtpConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserCreateWithoutApiKeysInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    ownedServers?: GameServerCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentCreateNestedManyWithoutAssignedToInput
    orders?: OrderCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerUncheckedCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertUncheckedCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentUncheckedCreateNestedManyWithoutAssignedToInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    ownedServers?: GameServerUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUncheckedUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUncheckedUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUncheckedUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutAssignedIncidentsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    ownedServers?: GameServerCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAssignedIncidentsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerUncheckedCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertUncheckedCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAssignedIncidentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedIncidentsInput, UserUncheckedCreateWithoutAssignedIncidentsInput>
  }

  export type UserUpsertWithoutAssignedIncidentsInput = {
    update: XOR<UserUpdateWithoutAssignedIncidentsInput, UserUncheckedUpdateWithoutAssignedIncidentsInput>
    create: XOR<UserCreateWithoutAssignedIncidentsInput, UserUncheckedCreateWithoutAssignedIncidentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedIncidentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedIncidentsInput, UserUncheckedUpdateWithoutAssignedIncidentsInput>
  }

  export type UserUpdateWithoutAssignedIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    ownedServers?: GameServerUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedIncidentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUncheckedUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUncheckedUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type GameServerCreateWithoutPlanInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutServersInput
    owner: UserCreateNestedOneWithoutOwnedServersInput
    cluster?: GameClusterCreateNestedOneWithoutServersInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutServerInput
    subdomains?: SubdomainCreateNestedManyWithoutServerInput
    backups?: BackupCreateNestedManyWithoutServerInput
    metrics?: MetricCreateNestedManyWithoutServerInput
    alerts?: AlertCreateNestedManyWithoutServerInput
    orders?: OrderCreateNestedManyWithoutServerInput
  }

  export type GameServerUncheckedCreateWithoutPlanInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutServerInput
    subdomains?: SubdomainUncheckedCreateNestedManyWithoutServerInput
    backups?: BackupUncheckedCreateNestedManyWithoutServerInput
    metrics?: MetricUncheckedCreateNestedManyWithoutServerInput
    alerts?: AlertUncheckedCreateNestedManyWithoutServerInput
    orders?: OrderUncheckedCreateNestedManyWithoutServerInput
  }

  export type GameServerCreateOrConnectWithoutPlanInput = {
    where: GameServerWhereUniqueInput
    create: XOR<GameServerCreateWithoutPlanInput, GameServerUncheckedCreateWithoutPlanInput>
  }

  export type GameServerCreateManyPlanInputEnvelope = {
    data: GameServerCreateManyPlanInput | GameServerCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutPlanInput = {
    id?: string
    status?: $Enums.OrderStatus
    priceSnapshot: JsonNullValueInput | InputJsonValue
    totalAmount: number
    currency?: string
    paymentMethod?: string | null
    paymentId?: string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
    server?: GameServerCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutPlanInput = {
    id?: string
    userId: string
    status?: $Enums.OrderStatus
    priceSnapshot: JsonNullValueInput | InputJsonValue
    totalAmount: number
    currency?: string
    paymentMethod?: string | null
    paymentId?: string | null
    paidAt?: Date | string | null
    serverId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutPlanInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPlanInput, OrderUncheckedCreateWithoutPlanInput>
  }

  export type OrderCreateManyPlanInputEnvelope = {
    data: OrderCreateManyPlanInput | OrderCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PromotionCreateWithoutPlanInput = {
    id?: string
    name: string
    description?: string | null
    scope: $Enums.PromotionScope
    discountPercent: number
    gameType?: $Enums.GameType | null
    startDate: Date | string
    endDate?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUncheckedCreateWithoutPlanInput = {
    id?: string
    name: string
    description?: string | null
    scope: $Enums.PromotionScope
    discountPercent: number
    gameType?: $Enums.GameType | null
    startDate: Date | string
    endDate?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionCreateOrConnectWithoutPlanInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutPlanInput, PromotionUncheckedCreateWithoutPlanInput>
  }

  export type PromotionCreateManyPlanInputEnvelope = {
    data: PromotionCreateManyPlanInput | PromotionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type GameServerUpsertWithWhereUniqueWithoutPlanInput = {
    where: GameServerWhereUniqueInput
    update: XOR<GameServerUpdateWithoutPlanInput, GameServerUncheckedUpdateWithoutPlanInput>
    create: XOR<GameServerCreateWithoutPlanInput, GameServerUncheckedCreateWithoutPlanInput>
  }

  export type GameServerUpdateWithWhereUniqueWithoutPlanInput = {
    where: GameServerWhereUniqueInput
    data: XOR<GameServerUpdateWithoutPlanInput, GameServerUncheckedUpdateWithoutPlanInput>
  }

  export type GameServerUpdateManyWithWhereWithoutPlanInput = {
    where: GameServerScalarWhereInput
    data: XOR<GameServerUpdateManyMutationInput, GameServerUncheckedUpdateManyWithoutPlanInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutPlanInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutPlanInput, OrderUncheckedUpdateWithoutPlanInput>
    create: XOR<OrderCreateWithoutPlanInput, OrderUncheckedCreateWithoutPlanInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutPlanInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutPlanInput, OrderUncheckedUpdateWithoutPlanInput>
  }

  export type OrderUpdateManyWithWhereWithoutPlanInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutPlanInput>
  }

  export type PromotionUpsertWithWhereUniqueWithoutPlanInput = {
    where: PromotionWhereUniqueInput
    update: XOR<PromotionUpdateWithoutPlanInput, PromotionUncheckedUpdateWithoutPlanInput>
    create: XOR<PromotionCreateWithoutPlanInput, PromotionUncheckedCreateWithoutPlanInput>
  }

  export type PromotionUpdateWithWhereUniqueWithoutPlanInput = {
    where: PromotionWhereUniqueInput
    data: XOR<PromotionUpdateWithoutPlanInput, PromotionUncheckedUpdateWithoutPlanInput>
  }

  export type PromotionUpdateManyWithWhereWithoutPlanInput = {
    where: PromotionScalarWhereInput
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyWithoutPlanInput>
  }

  export type PromotionScalarWhereInput = {
    AND?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    OR?: PromotionScalarWhereInput[]
    NOT?: PromotionScalarWhereInput | PromotionScalarWhereInput[]
    id?: StringFilter<"Promotion"> | string
    name?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    scope?: EnumPromotionScopeFilter<"Promotion"> | $Enums.PromotionScope
    discountPercent?: IntFilter<"Promotion"> | number
    gameType?: EnumGameTypeNullableFilter<"Promotion"> | $Enums.GameType | null
    planId?: StringNullableFilter<"Promotion"> | string | null
    startDate?: DateTimeFilter<"Promotion"> | Date | string
    endDate?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    active?: BoolFilter<"Promotion"> | boolean
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
  }

  export type PlanCreateWithoutPromotionsInput = {
    id?: string
    name: string
    slug: string
    gameType: $Enums.GameType
    status?: $Enums.PlanStatus
    ramMb: number
    cpuCores: number
    diskGb: number
    maxSlots?: number | null
    monthlyPrice: number
    hourlyPrice?: number | null
    setupFee?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    isPopular?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerCreateNestedManyWithoutPlanInput
    orders?: OrderCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutPromotionsInput = {
    id?: string
    name: string
    slug: string
    gameType: $Enums.GameType
    status?: $Enums.PlanStatus
    ramMb: number
    cpuCores: number
    diskGb: number
    maxSlots?: number | null
    monthlyPrice: number
    hourlyPrice?: number | null
    setupFee?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    isPopular?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerUncheckedCreateNestedManyWithoutPlanInput
    orders?: OrderUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutPromotionsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutPromotionsInput, PlanUncheckedCreateWithoutPromotionsInput>
  }

  export type PlanUpsertWithoutPromotionsInput = {
    update: XOR<PlanUpdateWithoutPromotionsInput, PlanUncheckedUpdateWithoutPromotionsInput>
    create: XOR<PlanCreateWithoutPromotionsInput, PlanUncheckedCreateWithoutPromotionsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutPromotionsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutPromotionsInput, PlanUncheckedUpdateWithoutPromotionsInput>
  }

  export type PlanUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumPlanStatusFieldUpdateOperationsInput | $Enums.PlanStatus
    ramMb?: IntFieldUpdateOperationsInput | number
    cpuCores?: IntFieldUpdateOperationsInput | number
    diskGb?: IntFieldUpdateOperationsInput | number
    maxSlots?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    hourlyPrice?: NullableIntFieldUpdateOperationsInput | number | null
    setupFee?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUpdateManyWithoutPlanNestedInput
    orders?: OrderUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutPromotionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumPlanStatusFieldUpdateOperationsInput | $Enums.PlanStatus
    ramMb?: IntFieldUpdateOperationsInput | number
    cpuCores?: IntFieldUpdateOperationsInput | number
    diskGb?: IntFieldUpdateOperationsInput | number
    maxSlots?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    hourlyPrice?: NullableIntFieldUpdateOperationsInput | number | null
    setupFee?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUncheckedUpdateManyWithoutPlanNestedInput
    orders?: OrderUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    ownedServers?: GameServerCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentCreateNestedManyWithoutAssignedToInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerUncheckedCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertUncheckedCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentUncheckedCreateNestedManyWithoutAssignedToInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type PlanCreateWithoutOrdersInput = {
    id?: string
    name: string
    slug: string
    gameType: $Enums.GameType
    status?: $Enums.PlanStatus
    ramMb: number
    cpuCores: number
    diskGb: number
    maxSlots?: number | null
    monthlyPrice: number
    hourlyPrice?: number | null
    setupFee?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    isPopular?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerCreateNestedManyWithoutPlanInput
    promotions?: PromotionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    slug: string
    gameType: $Enums.GameType
    status?: $Enums.PlanStatus
    ramMb: number
    cpuCores: number
    diskGb: number
    maxSlots?: number | null
    monthlyPrice: number
    hourlyPrice?: number | null
    setupFee?: number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    isPopular?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    servers?: GameServerUncheckedCreateNestedManyWithoutPlanInput
    promotions?: PromotionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutOrdersInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutOrdersInput, PlanUncheckedCreateWithoutOrdersInput>
  }

  export type GameServerCreateWithoutOrdersInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutServersInput
    owner: UserCreateNestedOneWithoutOwnedServersInput
    plan?: PlanCreateNestedOneWithoutServersInput
    cluster?: GameClusterCreateNestedOneWithoutServersInput
    networkAllocations?: NetworkAllocationCreateNestedManyWithoutServerInput
    subdomains?: SubdomainCreateNestedManyWithoutServerInput
    backups?: BackupCreateNestedManyWithoutServerInput
    metrics?: MetricCreateNestedManyWithoutServerInput
    alerts?: AlertCreateNestedManyWithoutServerInput
  }

  export type GameServerUncheckedCreateWithoutOrdersInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    networkAllocations?: NetworkAllocationUncheckedCreateNestedManyWithoutServerInput
    subdomains?: SubdomainUncheckedCreateNestedManyWithoutServerInput
    backups?: BackupUncheckedCreateNestedManyWithoutServerInput
    metrics?: MetricUncheckedCreateNestedManyWithoutServerInput
    alerts?: AlertUncheckedCreateNestedManyWithoutServerInput
  }

  export type GameServerCreateOrConnectWithoutOrdersInput = {
    where: GameServerWhereUniqueInput
    create: XOR<GameServerCreateWithoutOrdersInput, GameServerUncheckedCreateWithoutOrdersInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    ownedServers?: GameServerUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUpdateManyWithoutAssignedToNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUncheckedUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUncheckedUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUncheckedUpdateManyWithoutAssignedToNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type PlanUpsertWithoutOrdersInput = {
    update: XOR<PlanUpdateWithoutOrdersInput, PlanUncheckedUpdateWithoutOrdersInput>
    create: XOR<PlanCreateWithoutOrdersInput, PlanUncheckedCreateWithoutOrdersInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutOrdersInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutOrdersInput, PlanUncheckedUpdateWithoutOrdersInput>
  }

  export type PlanUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumPlanStatusFieldUpdateOperationsInput | $Enums.PlanStatus
    ramMb?: IntFieldUpdateOperationsInput | number
    cpuCores?: IntFieldUpdateOperationsInput | number
    diskGb?: IntFieldUpdateOperationsInput | number
    maxSlots?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    hourlyPrice?: NullableIntFieldUpdateOperationsInput | number | null
    setupFee?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUpdateManyWithoutPlanNestedInput
    promotions?: PromotionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumPlanStatusFieldUpdateOperationsInput | $Enums.PlanStatus
    ramMb?: IntFieldUpdateOperationsInput | number
    cpuCores?: IntFieldUpdateOperationsInput | number
    diskGb?: IntFieldUpdateOperationsInput | number
    maxSlots?: NullableIntFieldUpdateOperationsInput | number | null
    monthlyPrice?: IntFieldUpdateOperationsInput | number
    hourlyPrice?: NullableIntFieldUpdateOperationsInput | number | null
    setupFee?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUncheckedUpdateManyWithoutPlanNestedInput
    promotions?: PromotionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type GameServerUpsertWithoutOrdersInput = {
    update: XOR<GameServerUpdateWithoutOrdersInput, GameServerUncheckedUpdateWithoutOrdersInput>
    create: XOR<GameServerCreateWithoutOrdersInput, GameServerUncheckedCreateWithoutOrdersInput>
    where?: GameServerWhereInput
  }

  export type GameServerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: GameServerWhereInput
    data: XOR<GameServerUpdateWithoutOrdersInput, GameServerUncheckedUpdateWithoutOrdersInput>
  }

  export type GameServerUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutServersNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedServersNestedInput
    plan?: PlanUpdateOneWithoutServersNestedInput
    cluster?: GameClusterUpdateOneWithoutServersNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUpdateManyWithoutServerNestedInput
    backups?: BackupUpdateManyWithoutServerNestedInput
    metrics?: MetricUpdateManyWithoutServerNestedInput
    alerts?: AlertUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUncheckedUpdateManyWithoutServerNestedInput
    backups?: BackupUncheckedUpdateManyWithoutServerNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutServerNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutServerNestedInput
  }

  export type UserCreateWithoutAssignedTicketsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    ownedServers?: GameServerCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentCreateNestedManyWithoutAssignedToInput
    orders?: OrderCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    knowledgeBaseArticles?: KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAssignedTicketsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerUncheckedCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertUncheckedCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentUncheckedCreateNestedManyWithoutAssignedToInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAssignedTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
  }

  export type UserCreateWithoutSupportTicketsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    ownedServers?: GameServerCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentCreateNestedManyWithoutAssignedToInput
    orders?: OrderCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutSupportTicketsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerUncheckedCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertUncheckedCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentUncheckedCreateNestedManyWithoutAssignedToInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutSupportTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
  }

  export type TicketCommentCreateWithoutTicketInput = {
    id?: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutTicketInput = {
    id?: string
    authorId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentCreateOrConnectWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentCreateManyTicketInputEnvelope = {
    data: TicketCommentCreateManyTicketInput | TicketCommentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAssignedTicketsInput = {
    update: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
    create: XOR<UserCreateWithoutAssignedTicketsInput, UserUncheckedCreateWithoutAssignedTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedTicketsInput, UserUncheckedUpdateWithoutAssignedTicketsInput>
  }

  export type UserUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    ownedServers?: GameServerUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUncheckedUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUncheckedUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUncheckedUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUpsertWithoutSupportTicketsInput = {
    update: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupportTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type UserUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    ownedServers?: GameServerUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutSupportTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUncheckedUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUncheckedUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUncheckedUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutTicketInput>
  }

  export type SupportTicketCreateWithoutCommentsInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    priority?: $Enums.TicketPriority
    category?: string | null
    status?: $Enums.TicketStatus
    assignedAt?: Date | string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    firstResponseAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
    assignedTo?: UserCreateNestedOneWithoutAssignedTicketsInput
    user: UserCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutCommentsInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    priority?: $Enums.TicketPriority
    category?: string | null
    status?: $Enums.TicketStatus
    assignedToId?: string | null
    assignedAt?: Date | string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    firstResponseAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type SupportTicketCreateOrConnectWithoutCommentsInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutCommentsInput, SupportTicketUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutTicketCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    ownedServers?: GameServerCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentCreateNestedManyWithoutAssignedToInput
    orders?: OrderCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutTicketCommentsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerUncheckedCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertUncheckedCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentUncheckedCreateNestedManyWithoutAssignedToInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutTicketCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
  }

  export type SupportTicketUpsertWithoutCommentsInput = {
    update: XOR<SupportTicketUpdateWithoutCommentsInput, SupportTicketUncheckedUpdateWithoutCommentsInput>
    create: XOR<SupportTicketCreateWithoutCommentsInput, SupportTicketUncheckedCreateWithoutCommentsInput>
    where?: SupportTicketWhereInput
  }

  export type SupportTicketUpdateToOneWithWhereWithoutCommentsInput = {
    where?: SupportTicketWhereInput
    data: XOR<SupportTicketUpdateWithoutCommentsInput, SupportTicketUncheckedUpdateWithoutCommentsInput>
  }

  export type SupportTicketUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    user?: UserUpdateOneRequiredWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutTicketCommentsInput = {
    update: XOR<UserUpdateWithoutTicketCommentsInput, UserUncheckedUpdateWithoutTicketCommentsInput>
    create: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketCommentsInput, UserUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type UserUpdateWithoutTicketCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    ownedServers?: GameServerUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUncheckedUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUncheckedUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUncheckedUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type KnowledgeBaseCategoryCreateWithoutArticlesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: KnowledgeBaseCategoryCreateNestedOneWithoutChildrenInput
    children?: KnowledgeBaseCategoryCreateNestedManyWithoutParentInput
  }

  export type KnowledgeBaseCategoryUncheckedCreateWithoutArticlesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: KnowledgeBaseCategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type KnowledgeBaseCategoryCreateOrConnectWithoutArticlesInput = {
    where: KnowledgeBaseCategoryWhereUniqueInput
    create: XOR<KnowledgeBaseCategoryCreateWithoutArticlesInput, KnowledgeBaseCategoryUncheckedCreateWithoutArticlesInput>
  }

  export type UserCreateWithoutKnowledgeBaseArticlesInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    ownedServers?: GameServerCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentCreateNestedManyWithoutAssignedToInput
    orders?: OrderCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketCreateNestedManyWithoutAssignedToInput
  }

  export type UserUncheckedCreateWithoutKnowledgeBaseArticlesInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownedServers?: GameServerUncheckedCreateNestedManyWithoutOwnerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    resolvedAlerts?: AlertUncheckedCreateNestedManyWithoutResolvedByInput
    resourceQuotas?: ResourceQuotaUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    assignedIncidents?: IncidentUncheckedCreateNestedManyWithoutAssignedToInput
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutAuthorInput
    assignedTickets?: SupportTicketUncheckedCreateNestedManyWithoutAssignedToInput
  }

  export type UserCreateOrConnectWithoutKnowledgeBaseArticlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKnowledgeBaseArticlesInput, UserUncheckedCreateWithoutKnowledgeBaseArticlesInput>
  }

  export type ArticleVersionCreateWithoutArticleInput = {
    id?: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ArticleVersionUncheckedCreateWithoutArticleInput = {
    id?: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ArticleVersionCreateOrConnectWithoutArticleInput = {
    where: ArticleVersionWhereUniqueInput
    create: XOR<ArticleVersionCreateWithoutArticleInput, ArticleVersionUncheckedCreateWithoutArticleInput>
  }

  export type ArticleVersionCreateManyArticleInputEnvelope = {
    data: ArticleVersionCreateManyArticleInput | ArticleVersionCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeBaseCategoryUpsertWithoutArticlesInput = {
    update: XOR<KnowledgeBaseCategoryUpdateWithoutArticlesInput, KnowledgeBaseCategoryUncheckedUpdateWithoutArticlesInput>
    create: XOR<KnowledgeBaseCategoryCreateWithoutArticlesInput, KnowledgeBaseCategoryUncheckedCreateWithoutArticlesInput>
    where?: KnowledgeBaseCategoryWhereInput
  }

  export type KnowledgeBaseCategoryUpdateToOneWithWhereWithoutArticlesInput = {
    where?: KnowledgeBaseCategoryWhereInput
    data: XOR<KnowledgeBaseCategoryUpdateWithoutArticlesInput, KnowledgeBaseCategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type KnowledgeBaseCategoryUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: KnowledgeBaseCategoryUpdateOneWithoutChildrenNestedInput
    children?: KnowledgeBaseCategoryUpdateManyWithoutParentNestedInput
  }

  export type KnowledgeBaseCategoryUncheckedUpdateWithoutArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: KnowledgeBaseCategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserUpsertWithoutKnowledgeBaseArticlesInput = {
    update: XOR<UserUpdateWithoutKnowledgeBaseArticlesInput, UserUncheckedUpdateWithoutKnowledgeBaseArticlesInput>
    create: XOR<UserCreateWithoutKnowledgeBaseArticlesInput, UserUncheckedCreateWithoutKnowledgeBaseArticlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKnowledgeBaseArticlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKnowledgeBaseArticlesInput, UserUncheckedUpdateWithoutKnowledgeBaseArticlesInput>
  }

  export type UserUpdateWithoutKnowledgeBaseArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    ownedServers?: GameServerUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
  }

  export type UserUncheckedUpdateWithoutKnowledgeBaseArticlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUncheckedUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUncheckedUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUncheckedUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
  }

  export type ArticleVersionUpsertWithWhereUniqueWithoutArticleInput = {
    where: ArticleVersionWhereUniqueInput
    update: XOR<ArticleVersionUpdateWithoutArticleInput, ArticleVersionUncheckedUpdateWithoutArticleInput>
    create: XOR<ArticleVersionCreateWithoutArticleInput, ArticleVersionUncheckedCreateWithoutArticleInput>
  }

  export type ArticleVersionUpdateWithWhereUniqueWithoutArticleInput = {
    where: ArticleVersionWhereUniqueInput
    data: XOR<ArticleVersionUpdateWithoutArticleInput, ArticleVersionUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleVersionUpdateManyWithWhereWithoutArticleInput = {
    where: ArticleVersionScalarWhereInput
    data: XOR<ArticleVersionUpdateManyMutationInput, ArticleVersionUncheckedUpdateManyWithoutArticleInput>
  }

  export type ArticleVersionScalarWhereInput = {
    AND?: ArticleVersionScalarWhereInput | ArticleVersionScalarWhereInput[]
    OR?: ArticleVersionScalarWhereInput[]
    NOT?: ArticleVersionScalarWhereInput | ArticleVersionScalarWhereInput[]
    id?: StringFilter<"ArticleVersion"> | string
    articleId?: StringFilter<"ArticleVersion"> | string
    version?: IntFilter<"ArticleVersion"> | number
    title?: StringFilter<"ArticleVersion"> | string
    content?: StringFilter<"ArticleVersion"> | string
    excerpt?: StringNullableFilter<"ArticleVersion"> | string | null
    createdBy?: StringFilter<"ArticleVersion"> | string
    createdAt?: DateTimeFilter<"ArticleVersion"> | Date | string
  }

  export type KnowledgeBaseCategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: KnowledgeBaseCategoryCreateNestedOneWithoutChildrenInput
    articles?: KnowledgeBaseArticleCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeBaseCategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeBaseCategoryCreateOrConnectWithoutChildrenInput = {
    where: KnowledgeBaseCategoryWhereUniqueInput
    create: XOR<KnowledgeBaseCategoryCreateWithoutChildrenInput, KnowledgeBaseCategoryUncheckedCreateWithoutChildrenInput>
  }

  export type KnowledgeBaseCategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: KnowledgeBaseCategoryCreateNestedManyWithoutParentInput
    articles?: KnowledgeBaseArticleCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeBaseCategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: KnowledgeBaseCategoryUncheckedCreateNestedManyWithoutParentInput
    articles?: KnowledgeBaseArticleUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type KnowledgeBaseCategoryCreateOrConnectWithoutParentInput = {
    where: KnowledgeBaseCategoryWhereUniqueInput
    create: XOR<KnowledgeBaseCategoryCreateWithoutParentInput, KnowledgeBaseCategoryUncheckedCreateWithoutParentInput>
  }

  export type KnowledgeBaseCategoryCreateManyParentInputEnvelope = {
    data: KnowledgeBaseCategoryCreateManyParentInput | KnowledgeBaseCategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeBaseArticleCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    published?: boolean
    views?: number
    helpful?: number
    notHelpful?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    author: UserCreateNestedOneWithoutKnowledgeBaseArticlesInput
    versions?: ArticleVersionCreateNestedManyWithoutArticleInput
  }

  export type KnowledgeBaseArticleUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    authorId: string
    tags?: JsonNullValueInput | InputJsonValue
    published?: boolean
    views?: number
    helpful?: number
    notHelpful?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    versions?: ArticleVersionUncheckedCreateNestedManyWithoutArticleInput
  }

  export type KnowledgeBaseArticleCreateOrConnectWithoutCategoryInput = {
    where: KnowledgeBaseArticleWhereUniqueInput
    create: XOR<KnowledgeBaseArticleCreateWithoutCategoryInput, KnowledgeBaseArticleUncheckedCreateWithoutCategoryInput>
  }

  export type KnowledgeBaseArticleCreateManyCategoryInputEnvelope = {
    data: KnowledgeBaseArticleCreateManyCategoryInput | KnowledgeBaseArticleCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeBaseCategoryUpsertWithoutChildrenInput = {
    update: XOR<KnowledgeBaseCategoryUpdateWithoutChildrenInput, KnowledgeBaseCategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<KnowledgeBaseCategoryCreateWithoutChildrenInput, KnowledgeBaseCategoryUncheckedCreateWithoutChildrenInput>
    where?: KnowledgeBaseCategoryWhereInput
  }

  export type KnowledgeBaseCategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: KnowledgeBaseCategoryWhereInput
    data: XOR<KnowledgeBaseCategoryUpdateWithoutChildrenInput, KnowledgeBaseCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type KnowledgeBaseCategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: KnowledgeBaseCategoryUpdateOneWithoutChildrenNestedInput
    articles?: KnowledgeBaseArticleUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeBaseCategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeBaseCategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: KnowledgeBaseCategoryWhereUniqueInput
    update: XOR<KnowledgeBaseCategoryUpdateWithoutParentInput, KnowledgeBaseCategoryUncheckedUpdateWithoutParentInput>
    create: XOR<KnowledgeBaseCategoryCreateWithoutParentInput, KnowledgeBaseCategoryUncheckedCreateWithoutParentInput>
  }

  export type KnowledgeBaseCategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: KnowledgeBaseCategoryWhereUniqueInput
    data: XOR<KnowledgeBaseCategoryUpdateWithoutParentInput, KnowledgeBaseCategoryUncheckedUpdateWithoutParentInput>
  }

  export type KnowledgeBaseCategoryUpdateManyWithWhereWithoutParentInput = {
    where: KnowledgeBaseCategoryScalarWhereInput
    data: XOR<KnowledgeBaseCategoryUpdateManyMutationInput, KnowledgeBaseCategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type KnowledgeBaseCategoryScalarWhereInput = {
    AND?: KnowledgeBaseCategoryScalarWhereInput | KnowledgeBaseCategoryScalarWhereInput[]
    OR?: KnowledgeBaseCategoryScalarWhereInput[]
    NOT?: KnowledgeBaseCategoryScalarWhereInput | KnowledgeBaseCategoryScalarWhereInput[]
    id?: StringFilter<"KnowledgeBaseCategory"> | string
    name?: StringFilter<"KnowledgeBaseCategory"> | string
    slug?: StringFilter<"KnowledgeBaseCategory"> | string
    description?: StringNullableFilter<"KnowledgeBaseCategory"> | string | null
    icon?: StringNullableFilter<"KnowledgeBaseCategory"> | string | null
    order?: IntFilter<"KnowledgeBaseCategory"> | number
    parentId?: StringNullableFilter<"KnowledgeBaseCategory"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeBaseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeBaseCategory"> | Date | string
  }

  export type KnowledgeBaseArticleUpsertWithWhereUniqueWithoutCategoryInput = {
    where: KnowledgeBaseArticleWhereUniqueInput
    update: XOR<KnowledgeBaseArticleUpdateWithoutCategoryInput, KnowledgeBaseArticleUncheckedUpdateWithoutCategoryInput>
    create: XOR<KnowledgeBaseArticleCreateWithoutCategoryInput, KnowledgeBaseArticleUncheckedCreateWithoutCategoryInput>
  }

  export type KnowledgeBaseArticleUpdateWithWhereUniqueWithoutCategoryInput = {
    where: KnowledgeBaseArticleWhereUniqueInput
    data: XOR<KnowledgeBaseArticleUpdateWithoutCategoryInput, KnowledgeBaseArticleUncheckedUpdateWithoutCategoryInput>
  }

  export type KnowledgeBaseArticleUpdateManyWithWhereWithoutCategoryInput = {
    where: KnowledgeBaseArticleScalarWhereInput
    data: XOR<KnowledgeBaseArticleUpdateManyMutationInput, KnowledgeBaseArticleUncheckedUpdateManyWithoutCategoryInput>
  }

  export type KnowledgeBaseArticleCreateWithoutVersionsInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    published?: boolean
    views?: number
    helpful?: number
    notHelpful?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    category: KnowledgeBaseCategoryCreateNestedOneWithoutArticlesInput
    author: UserCreateNestedOneWithoutKnowledgeBaseArticlesInput
  }

  export type KnowledgeBaseArticleUncheckedCreateWithoutVersionsInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    categoryId: string
    authorId: string
    tags?: JsonNullValueInput | InputJsonValue
    published?: boolean
    views?: number
    helpful?: number
    notHelpful?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type KnowledgeBaseArticleCreateOrConnectWithoutVersionsInput = {
    where: KnowledgeBaseArticleWhereUniqueInput
    create: XOR<KnowledgeBaseArticleCreateWithoutVersionsInput, KnowledgeBaseArticleUncheckedCreateWithoutVersionsInput>
  }

  export type KnowledgeBaseArticleUpsertWithoutVersionsInput = {
    update: XOR<KnowledgeBaseArticleUpdateWithoutVersionsInput, KnowledgeBaseArticleUncheckedUpdateWithoutVersionsInput>
    create: XOR<KnowledgeBaseArticleCreateWithoutVersionsInput, KnowledgeBaseArticleUncheckedCreateWithoutVersionsInput>
    where?: KnowledgeBaseArticleWhereInput
  }

  export type KnowledgeBaseArticleUpdateToOneWithWhereWithoutVersionsInput = {
    where?: KnowledgeBaseArticleWhereInput
    data: XOR<KnowledgeBaseArticleUpdateWithoutVersionsInput, KnowledgeBaseArticleUncheckedUpdateWithoutVersionsInput>
  }

  export type KnowledgeBaseArticleUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    helpful?: IntFieldUpdateOperationsInput | number
    notHelpful?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: KnowledgeBaseCategoryUpdateOneRequiredWithoutArticlesNestedInput
    author?: UserUpdateOneRequiredWithoutKnowledgeBaseArticlesNestedInput
  }

  export type KnowledgeBaseArticleUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    helpful?: IntFieldUpdateOperationsInput | number
    notHelpful?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    twoFactorSecret?: string | null
    twoFactorEnabled?: boolean
    twoFactorMethod?: string | null
    twoFactorBackupCodes?: string | null
    resetToken?: string | null
    resetTokenExpires?: Date | string | null
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceQuotaCreateManyTenantInput = {
    id?: string
    userId: string
    maxServers: number
    maxRam: number
    maxDisk: number
    maxCpu: number
    currentUsage: JsonNullValueInput | InputJsonValue
    enforced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedServers?: GameServerUncheckedUpdateManyWithoutOwnerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    resolvedAlerts?: AlertUncheckedUpdateManyWithoutResolvedByNestedInput
    resourceQuotas?: ResourceQuotaUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    assignedIncidents?: IncidentUncheckedUpdateManyWithoutAssignedToNestedInput
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTickets?: SupportTicketUncheckedUpdateManyWithoutAssignedToNestedInput
    knowledgeBaseArticles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorMethod?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorBackupCodes?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceQuotaUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxServers?: IntFieldUpdateOperationsInput | number
    maxRam?: IntFieldUpdateOperationsInput | number
    maxDisk?: IntFieldUpdateOperationsInput | number
    maxCpu?: IntFieldUpdateOperationsInput | number
    currentUsage?: JsonNullValueInput | InputJsonValue
    enforced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResourceQuotasNestedInput
  }

  export type ResourceQuotaUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    maxServers?: IntFieldUpdateOperationsInput | number
    maxRam?: IntFieldUpdateOperationsInput | number
    maxDisk?: IntFieldUpdateOperationsInput | number
    maxCpu?: IntFieldUpdateOperationsInput | number
    currentUsage?: JsonNullValueInput | InputJsonValue
    enforced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceQuotaUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    maxServers?: IntFieldUpdateOperationsInput | number
    maxRam?: IntFieldUpdateOperationsInput | number
    maxDisk?: IntFieldUpdateOperationsInput | number
    maxCpu?: IntFieldUpdateOperationsInput | number
    currentUsage?: JsonNullValueInput | InputJsonValue
    enforced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameServerCreateManyOwnerInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    resourceId: string
    ipAddress: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AlertCreateManyResolvedByInput = {
    id?: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved?: boolean
    resolvedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeId?: string | null
    serverUuid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceQuotaCreateManyUserInput = {
    id?: string
    tenantId?: string | null
    maxServers: number
    maxRam: number
    maxDisk: number
    maxCpu: number
    currentUsage: JsonNullValueInput | InputJsonValue
    enforced?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateManyUserInput = {
    id?: string
    keyHash: string
    name: string
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncidentCreateManyAssignedToInput = {
    id?: string
    title: string
    description: string
    severity: $Enums.IncidentSeverity
    status?: $Enums.IncidentStatus
    resolvedAt?: Date | string | null
    rootCause?: string | null
    resolution?: string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    planId: string
    status?: $Enums.OrderStatus
    priceSnapshot: JsonNullValueInput | InputJsonValue
    totalAmount: number
    currency?: string
    paymentMethod?: string | null
    paymentId?: string | null
    paidAt?: Date | string | null
    serverId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateManyUserInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    priority?: $Enums.TicketPriority
    category?: string | null
    status?: $Enums.TicketStatus
    assignedToId?: string | null
    assignedAt?: Date | string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    firstResponseAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type TicketCommentCreateManyAuthorInput = {
    id?: string
    ticketId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupportTicketCreateManyAssignedToInput = {
    id?: string
    ticketNumber: string
    subject: string
    description: string
    priority?: $Enums.TicketPriority
    category?: string | null
    status?: $Enums.TicketStatus
    assignedAt?: Date | string | null
    slaResponseDeadline?: Date | string | null
    slaResolveDeadline?: Date | string | null
    firstResponseAt?: Date | string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    closedAt?: Date | string | null
  }

  export type KnowledgeBaseArticleCreateManyAuthorInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    categoryId: string
    tags?: JsonNullValueInput | InputJsonValue
    published?: boolean
    views?: number
    helpful?: number
    notHelpful?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type GameServerUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutServersNestedInput
    plan?: PlanUpdateOneWithoutServersNestedInput
    cluster?: GameClusterUpdateOneWithoutServersNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUpdateManyWithoutServerNestedInput
    backups?: BackupUpdateManyWithoutServerNestedInput
    metrics?: MetricUpdateManyWithoutServerNestedInput
    alerts?: AlertUpdateManyWithoutServerNestedInput
    orders?: OrderUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUncheckedUpdateManyWithoutServerNestedInput
    backups?: BackupUncheckedUpdateManyWithoutServerNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutServerNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutServerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUpdateWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneWithoutAlertsNestedInput
    server?: GameServerUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceQuotaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxServers?: IntFieldUpdateOperationsInput | number
    maxRam?: IntFieldUpdateOperationsInput | number
    maxDisk?: IntFieldUpdateOperationsInput | number
    maxCpu?: IntFieldUpdateOperationsInput | number
    currentUsage?: JsonNullValueInput | InputJsonValue
    enforced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutResourceQuotasNestedInput
  }

  export type ResourceQuotaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    maxServers?: IntFieldUpdateOperationsInput | number
    maxRam?: IntFieldUpdateOperationsInput | number
    maxDisk?: IntFieldUpdateOperationsInput | number
    maxCpu?: IntFieldUpdateOperationsInput | number
    currentUsage?: JsonNullValueInput | InputJsonValue
    enforced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceQuotaUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    maxServers?: IntFieldUpdateOperationsInput | number
    maxRam?: IntFieldUpdateOperationsInput | number
    maxDisk?: IntFieldUpdateOperationsInput | number
    maxCpu?: IntFieldUpdateOperationsInput | number
    currentUsage?: JsonNullValueInput | InputJsonValue
    enforced?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: NullableJsonNullValueInput | InputJsonValue
    rateLimit?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncidentUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: EnumIncidentSeverityFieldUpdateOperationsInput | $Enums.IncidentSeverity
    status?: EnumIncidentStatusFieldUpdateOperationsInput | $Enums.IncidentStatus
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootCause?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    affectedResources?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutOrdersNestedInput
    server?: GameServerUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: UserUpdateOneWithoutAssignedTicketsNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedToId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketCommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportTicketUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSupportTicketsNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    category?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResponseDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slaResolveDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstResponseAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KnowledgeBaseArticleUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    helpful?: IntFieldUpdateOperationsInput | number
    notHelpful?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: KnowledgeBaseCategoryUpdateOneRequiredWithoutArticlesNestedInput
    versions?: ArticleVersionUpdateManyWithoutArticleNestedInput
  }

  export type KnowledgeBaseArticleUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    helpful?: IntFieldUpdateOperationsInput | number
    notHelpful?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versions?: ArticleVersionUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type KnowledgeBaseArticleUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    helpful?: IntFieldUpdateOperationsInput | number
    notHelpful?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GameServerCreateManyNodeInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    ownerId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkAllocationCreateManyNodeInput = {
    id?: string
    port: number
    protocol: $Enums.Protocol
    type: $Enums.PortType
    serverUuid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetricCreateManyNodeInput = {
    id?: string
    serverUuid?: string | null
    timestamp?: Date | string
    cpuUsage: number
    ramUsage: number
    ramUsagePercent: number
    diskUsage: number
    diskUsagePercent: number
    networkIn: bigint | number
    networkOut: bigint | number
    uptime?: number | null
  }

  export type AlertCreateManyNodeInput = {
    id?: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    serverUuid?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameClusterCreateManyStorageNodeInput = {
    id?: string
    gameType: $Enums.GameType
    sharedSecret: string
    mountPath: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyNodeInput = {
    id?: string
    type: $Enums.TaskType
    status?: $Enums.TaskStatus
    data: JsonNullValueInput | InputJsonValue
    error?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameServerUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedServersNestedInput
    plan?: PlanUpdateOneWithoutServersNestedInput
    cluster?: GameClusterUpdateOneWithoutServersNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUpdateManyWithoutServerNestedInput
    backups?: BackupUpdateManyWithoutServerNestedInput
    metrics?: MetricUpdateManyWithoutServerNestedInput
    alerts?: AlertUpdateManyWithoutServerNestedInput
    orders?: OrderUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    ownerId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUncheckedUpdateManyWithoutServerNestedInput
    backups?: BackupUncheckedUpdateManyWithoutServerNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutServerNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutServerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateManyWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    ownerId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkAllocationUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    type?: EnumPortTypeFieldUpdateOperationsInput | $Enums.PortType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    server?: GameServerUpdateOneWithoutNetworkAllocationsNestedInput
  }

  export type NetworkAllocationUncheckedUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    type?: EnumPortTypeFieldUpdateOperationsInput | $Enums.PortType
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkAllocationUncheckedUpdateManyWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    type?: EnumPortTypeFieldUpdateOperationsInput | $Enums.PortType
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    ramUsage?: FloatFieldUpdateOperationsInput | number
    ramUsagePercent?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    diskUsagePercent?: FloatFieldUpdateOperationsInput | number
    networkIn?: BigIntFieldUpdateOperationsInput | bigint | number
    networkOut?: BigIntFieldUpdateOperationsInput | bigint | number
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
    server?: GameServerUpdateOneWithoutMetricsNestedInput
  }

  export type MetricUncheckedUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    ramUsage?: FloatFieldUpdateOperationsInput | number
    ramUsagePercent?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    diskUsagePercent?: FloatFieldUpdateOperationsInput | number
    networkIn?: BigIntFieldUpdateOperationsInput | bigint | number
    networkOut?: BigIntFieldUpdateOperationsInput | bigint | number
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MetricUncheckedUpdateManyWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    ramUsage?: FloatFieldUpdateOperationsInput | number
    ramUsagePercent?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    diskUsagePercent?: FloatFieldUpdateOperationsInput | number
    networkIn?: BigIntFieldUpdateOperationsInput | bigint | number
    networkOut?: BigIntFieldUpdateOperationsInput | bigint | number
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AlertUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: UserUpdateOneWithoutResolvedAlertsNestedInput
    server?: GameServerUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    serverUuid?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameClusterUpdateWithoutStorageNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    sharedSecret?: StringFieldUpdateOperationsInput | string
    mountPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUpdateManyWithoutClusterNestedInput
  }

  export type GameClusterUncheckedUpdateWithoutStorageNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    sharedSecret?: StringFieldUpdateOperationsInput | string
    mountPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servers?: GameServerUncheckedUpdateManyWithoutClusterNestedInput
  }

  export type GameClusterUncheckedUpdateManyWithoutStorageNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    sharedSecret?: StringFieldUpdateOperationsInput | string
    mountPath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    data?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    data?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    data?: JsonNullValueInput | InputJsonValue
    error?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkAllocationCreateManyServerInput = {
    id?: string
    nodeId: string
    port: number
    protocol: $Enums.Protocol
    type: $Enums.PortType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubdomainCreateManyServerInput = {
    id?: string
    subdomain: string
    domain: string
    cloudflareId: string
    targetIP: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BackupCreateManyServerInput = {
    id?: string
    snapshotId: string
    sizeBytes: bigint | number
    location: $Enums.BackupLocation
    lastRestoredAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetricCreateManyServerInput = {
    id?: string
    nodeId: string
    timestamp?: Date | string
    cpuUsage: number
    ramUsage: number
    ramUsagePercent: number
    diskUsage: number
    diskUsagePercent: number
    networkIn: bigint | number
    networkOut: bigint | number
    uptime?: number | null
  }

  export type AlertCreateManyServerInput = {
    id?: string
    severity: $Enums.AlertSeverity
    type: string
    message: string
    resourceId: string
    resourceType: $Enums.ResourceType
    resolved?: boolean
    resolvedAt?: Date | string | null
    resolvedById?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyServerInput = {
    id?: string
    userId: string
    planId: string
    status?: $Enums.OrderStatus
    priceSnapshot: JsonNullValueInput | InputJsonValue
    totalAmount: number
    currency?: string
    paymentMethod?: string | null
    paymentId?: string | null
    paidAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NetworkAllocationUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    type?: EnumPortTypeFieldUpdateOperationsInput | $Enums.PortType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutNetworkAllocationsNestedInput
  }

  export type NetworkAllocationUncheckedUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    type?: EnumPortTypeFieldUpdateOperationsInput | $Enums.PortType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkAllocationUncheckedUpdateManyWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    protocol?: EnumProtocolFieldUpdateOperationsInput | $Enums.Protocol
    type?: EnumPortTypeFieldUpdateOperationsInput | $Enums.PortType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdomainUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    cloudflareId?: StringFieldUpdateOperationsInput | string
    targetIP?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdomainUncheckedUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    cloudflareId?: StringFieldUpdateOperationsInput | string
    targetIP?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdomainUncheckedUpdateManyWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    cloudflareId?: StringFieldUpdateOperationsInput | string
    targetIP?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotId?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: EnumBackupLocationFieldUpdateOperationsInput | $Enums.BackupLocation
    lastRestoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupUncheckedUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotId?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: EnumBackupLocationFieldUpdateOperationsInput | $Enums.BackupLocation
    lastRestoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BackupUncheckedUpdateManyWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    snapshotId?: StringFieldUpdateOperationsInput | string
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: EnumBackupLocationFieldUpdateOperationsInput | $Enums.BackupLocation
    lastRestoredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetricUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    ramUsage?: FloatFieldUpdateOperationsInput | number
    ramUsagePercent?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    diskUsagePercent?: FloatFieldUpdateOperationsInput | number
    networkIn?: BigIntFieldUpdateOperationsInput | bigint | number
    networkOut?: BigIntFieldUpdateOperationsInput | bigint | number
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
    node?: NodeUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type MetricUncheckedUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    ramUsage?: FloatFieldUpdateOperationsInput | number
    ramUsagePercent?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    diskUsagePercent?: FloatFieldUpdateOperationsInput | number
    networkIn?: BigIntFieldUpdateOperationsInput | bigint | number
    networkOut?: BigIntFieldUpdateOperationsInput | bigint | number
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MetricUncheckedUpdateManyWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    ramUsage?: FloatFieldUpdateOperationsInput | number
    ramUsagePercent?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    diskUsagePercent?: FloatFieldUpdateOperationsInput | number
    networkIn?: BigIntFieldUpdateOperationsInput | bigint | number
    networkOut?: BigIntFieldUpdateOperationsInput | bigint | number
    uptime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AlertUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedBy?: UserUpdateOneWithoutResolvedAlertsNestedInput
    node?: NodeUpdateOneWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertUncheckedUpdateManyWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    severity?: EnumAlertSeverityFieldUpdateOperationsInput | $Enums.AlertSeverity
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    resourceId?: StringFieldUpdateOperationsInput | string
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    plan?: PlanUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutServerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameServerCreateManyClusterInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    planId?: string | null
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameServerUpdateWithoutClusterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutServersNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedServersNestedInput
    plan?: PlanUpdateOneWithoutServersNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUpdateManyWithoutServerNestedInput
    backups?: BackupUpdateManyWithoutServerNestedInput
    metrics?: MetricUpdateManyWithoutServerNestedInput
    alerts?: AlertUpdateManyWithoutServerNestedInput
    orders?: OrderUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateWithoutClusterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUncheckedUpdateManyWithoutServerNestedInput
    backups?: BackupUncheckedUpdateManyWithoutServerNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutServerNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutServerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateManyWithoutClusterInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GameServerCreateManyPlanInput = {
    id?: string
    uuid: string
    gameType: $Enums.GameType
    status?: $Enums.ServerStatus
    nodeId: string
    ownerId: string
    startupPriority?: number
    resources: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyPlanInput = {
    id?: string
    userId: string
    status?: $Enums.OrderStatus
    priceSnapshot: JsonNullValueInput | InputJsonValue
    totalAmount: number
    currency?: string
    paymentMethod?: string | null
    paymentId?: string | null
    paidAt?: Date | string | null
    serverId?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionCreateManyPlanInput = {
    id?: string
    name: string
    description?: string | null
    scope: $Enums.PromotionScope
    discountPercent: number
    gameType?: $Enums.GameType | null
    startDate: Date | string
    endDate?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GameServerUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutServersNestedInput
    owner?: UserUpdateOneRequiredWithoutOwnedServersNestedInput
    cluster?: GameClusterUpdateOneWithoutServersNestedInput
    networkAllocations?: NetworkAllocationUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUpdateManyWithoutServerNestedInput
    backups?: BackupUpdateManyWithoutServerNestedInput
    metrics?: MetricUpdateManyWithoutServerNestedInput
    alerts?: AlertUpdateManyWithoutServerNestedInput
    orders?: OrderUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    networkAllocations?: NetworkAllocationUncheckedUpdateManyWithoutServerNestedInput
    subdomains?: SubdomainUncheckedUpdateManyWithoutServerNestedInput
    backups?: BackupUncheckedUpdateManyWithoutServerNestedInput
    metrics?: MetricUncheckedUpdateManyWithoutServerNestedInput
    alerts?: AlertUncheckedUpdateManyWithoutServerNestedInput
    orders?: OrderUncheckedUpdateManyWithoutServerNestedInput
  }

  export type GameServerUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    uuid?: StringFieldUpdateOperationsInput | string
    gameType?: EnumGameTypeFieldUpdateOperationsInput | $Enums.GameType
    status?: EnumServerStatusFieldUpdateOperationsInput | $Enums.ServerStatus
    nodeId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startupPriority?: IntFieldUpdateOperationsInput | number
    resources?: JsonNullValueInput | InputJsonValue
    envVars?: JsonNullValueInput | InputJsonValue
    clusterId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
    server?: GameServerUpdateOneWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    priceSnapshot?: JsonNullValueInput | InputJsonValue
    totalAmount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serverId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: EnumPromotionScopeFieldUpdateOperationsInput | $Enums.PromotionScope
    discountPercent?: IntFieldUpdateOperationsInput | number
    gameType?: NullableEnumGameTypeFieldUpdateOperationsInput | $Enums.GameType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: EnumPromotionScopeFieldUpdateOperationsInput | $Enums.PromotionScope
    discountPercent?: IntFieldUpdateOperationsInput | number
    gameType?: NullableEnumGameTypeFieldUpdateOperationsInput | $Enums.GameType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: EnumPromotionScopeFieldUpdateOperationsInput | $Enums.PromotionScope
    discountPercent?: IntFieldUpdateOperationsInput | number
    gameType?: NullableEnumGameTypeFieldUpdateOperationsInput | $Enums.GameType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentCreateManyTicketInput = {
    id?: string
    authorId: string
    message: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleVersionCreateManyArticleInput = {
    id?: string
    version: number
    title: string
    content: string
    excerpt?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ArticleVersionUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleVersionUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleVersionUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseCategoryCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeBaseArticleCreateManyCategoryInput = {
    id?: string
    title: string
    slug: string
    content: string
    excerpt?: string | null
    authorId: string
    tags?: JsonNullValueInput | InputJsonValue
    published?: boolean
    views?: number
    helpful?: number
    notHelpful?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type KnowledgeBaseCategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: KnowledgeBaseCategoryUpdateManyWithoutParentNestedInput
    articles?: KnowledgeBaseArticleUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeBaseCategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: KnowledgeBaseCategoryUncheckedUpdateManyWithoutParentNestedInput
    articles?: KnowledgeBaseArticleUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type KnowledgeBaseCategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeBaseArticleUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    helpful?: IntFieldUpdateOperationsInput | number
    notHelpful?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: UserUpdateOneRequiredWithoutKnowledgeBaseArticlesNestedInput
    versions?: ArticleVersionUpdateManyWithoutArticleNestedInput
  }

  export type KnowledgeBaseArticleUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    helpful?: IntFieldUpdateOperationsInput | number
    notHelpful?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versions?: ArticleVersionUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type KnowledgeBaseArticleUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    tags?: JsonNullValueInput | InputJsonValue
    published?: BoolFieldUpdateOperationsInput | boolean
    views?: IntFieldUpdateOperationsInput | number
    helpful?: IntFieldUpdateOperationsInput | number
    notHelpful?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NodeCountOutputTypeDefaultArgs instead
     */
    export type NodeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NodeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameServerCountOutputTypeDefaultArgs instead
     */
    export type GameServerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameServerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameClusterCountOutputTypeDefaultArgs instead
     */
    export type GameClusterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameClusterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanCountOutputTypeDefaultArgs instead
     */
    export type PlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupportTicketCountOutputTypeDefaultArgs instead
     */
    export type SupportTicketCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeBaseArticleCountOutputTypeDefaultArgs instead
     */
    export type KnowledgeBaseArticleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeBaseArticleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeBaseCategoryCountOutputTypeDefaultArgs instead
     */
    export type KnowledgeBaseCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeBaseCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemLicenseDefaultArgs instead
     */
    export type SystemLicenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemLicenseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NodeDefaultArgs instead
     */
    export type NodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NetworkAllocationDefaultArgs instead
     */
    export type NetworkAllocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NetworkAllocationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubdomainDefaultArgs instead
     */
    export type SubdomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubdomainDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameServerDefaultArgs instead
     */
    export type GameServerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameServerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GameClusterDefaultArgs instead
     */
    export type GameClusterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GameClusterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BackupDefaultArgs instead
     */
    export type BackupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BackupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MetricDefaultArgs instead
     */
    export type MetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertDefaultArgs instead
     */
    export type AlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResourceQuotaDefaultArgs instead
     */
    export type ResourceQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResourceQuotaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApiKeyDefaultArgs instead
     */
    export type ApiKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApiKeyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncidentDefaultArgs instead
     */
    export type IncidentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncidentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlanDefaultArgs instead
     */
    export type PlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromotionDefaultArgs instead
     */
    export type PromotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromotionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentEventDefaultArgs instead
     */
    export type PaymentEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupportTicketDefaultArgs instead
     */
    export type SupportTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupportTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SlaPolicyDefaultArgs instead
     */
    export type SlaPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SlaPolicyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketCommentDefaultArgs instead
     */
    export type TicketCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeBaseArticleDefaultArgs instead
     */
    export type KnowledgeBaseArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeBaseArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KnowledgeBaseCategoryDefaultArgs instead
     */
    export type KnowledgeBaseCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KnowledgeBaseCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleVersionDefaultArgs instead
     */
    export type ArticleVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceMetadataDefaultArgs instead
     */
    export type InvoiceMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceMetadataDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}